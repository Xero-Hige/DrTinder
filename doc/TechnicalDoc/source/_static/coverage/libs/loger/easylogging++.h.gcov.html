<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage_total.info - libs/loger/easylogging++.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">libs/loger</a> - easylogging++.h<span style="font-size: 80%;"> (source / <a href="easylogging++.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage_total.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">998</td>
            <td class="headerCovTableEntry">1404</td>
            <td class="headerCovTableEntryLo">71.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-07-07 11:34:36</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">269</td>
            <td class="headerCovTableEntry">400</td>
            <td class="headerCovTableEntryLo">67.2 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //</a>
<span class="lineNum">       2 </span>            : //  Easylogging++ v9.80
<span class="lineNum">       3 </span>            : //  Single-header only, cross-platform logging library for C++ applications
<span class="lineNum">       4 </span>            : //
<span class="lineNum">       5 </span>            : //  Copyright (c) 2015 muflihun.com
<span class="lineNum">       6 </span>            : //
<span class="lineNum">       7 </span>            : //  This library is released under the MIT Licence.
<span class="lineNum">       8 </span>            : //  http://easylogging.muflihun.com/licence.php
<span class="lineNum">       9 </span>            : //
<span class="lineNum">      10 </span>            : //  easylogging@muflihun.com
<span class="lineNum">      11 </span>            : //
<span class="lineNum">      12 </span>            : //  https://github.com/easylogging/easyloggingpp
<span class="lineNum">      13 </span>            : //  http://easylogging.muflihun.com
<span class="lineNum">      14 </span>            : //  http://muflihun.com
<span class="lineNum">      15 </span>            : //
<span class="lineNum">      16 </span>            : #ifndef EASYLOGGINGPP_H
<span class="lineNum">      17 </span>            : #define EASYLOGGINGPP_H
<span class="lineNum">      18 </span>            : // Compilers and C++0x/C++11 Evaluation
<span class="lineNum">      19 </span>            : #if defined(__GNUC__)
<span class="lineNum">      20 </span>            : #   define ELPP_COMPILER_GCC 1
<span class="lineNum">      21 </span>            : #   define ELPP_GCC_VERSION (__GNUC__ * 10000 \
<span class="lineNum">      22 </span>            :                                + __GNUC_MINOR__ * 100 \
<span class="lineNum">      23 </span>            :                                + __GNUC_PATCHLEVEL__)
<span class="lineNum">      24 </span>            : #   if defined(__GXX_EXPERIMENTAL_CXX0X__)
<span class="lineNum">      25 </span>            : #      define ELPP_CXX0X 1
<span class="lineNum">      26 </span>            : #   elif(ELPP_GCC_VERSION &gt;= 40801)
<span class="lineNum">      27 </span>            : #      define ELPP_CXX11 1
<span class="lineNum">      28 </span>            : #   endif  // defined(__GXX_EXPERIMENTAL_CXX0X__)
<span class="lineNum">      29 </span>            : #endif  // defined(__GNUC__)
<span class="lineNum">      30 </span>            : // Visual C++
<span class="lineNum">      31 </span>            : #if defined(_MSC_VER)
<span class="lineNum">      32 </span>            : #   define ELPP_COMPILER_MSVC 1
<span class="lineNum">      33 </span>            : #   define ELPP_CRT_DBG_WARNINGS 1
<span class="lineNum">      34 </span>            : #   if (_MSC_VER == 1600)
<span class="lineNum">      35 </span>            : #      define ELPP_CXX0X 1
<span class="lineNum">      36 </span>            : #   elif(_MSC_VER &gt;= 1700)
<span class="lineNum">      37 </span>            : #      define ELPP_CXX11 1
<span class="lineNum">      38 </span>            : #   endif  // (_MSC_VER == 1600)
<span class="lineNum">      39 </span>            : #endif  // defined(_MSC_VER)
<span class="lineNum">      40 </span>            : // Clang++
<span class="lineNum">      41 </span>            : #if defined(__clang__) &amp;&amp; (__clang__ == 1)
<span class="lineNum">      42 </span>            : #   define ELPP_COMPILER_CLANG 1
<span class="lineNum">      43 </span>            : #   define ELPP_CLANG_VERSION (__clang_major__ * 10000 \
<span class="lineNum">      44 </span>            :                                 + __clang_minor__ * 100 \
<span class="lineNum">      45 </span>            :                                 + __clang_patchlevel__)
<span class="lineNum">      46 </span>            : #   if (ELPP_CLANG_VERSION &gt;= 30300)
<span class="lineNum">      47 </span>            : #      define ELPP_CXX11 1
<span class="lineNum">      48 </span>            : #   endif  // (ELPP_CLANG_VERSION &gt;= 30300)
<span class="lineNum">      49 </span>            : #endif  // defined(__clang__) &amp;&amp; (__clang__ == 1)
<span class="lineNum">      50 </span>            : // MinGW
<span class="lineNum">      51 </span>            : #if defined(__MINGW32__) || defined(__MINGW64__)
<span class="lineNum">      52 </span>            : #   define ELPP_MINGW 1
<span class="lineNum">      53 </span>            : #endif  // defined(__MINGW32__) || defined(__MINGW64__)
<span class="lineNum">      54 </span>            : // Cygwin
<span class="lineNum">      55 </span>            : #if defined(__CYGWIN__) &amp;&amp; (__CYGWIN__ == 1)
<span class="lineNum">      56 </span>            : #   define ELPP_CYGWIN 1
<span class="lineNum">      57 </span>            : #endif  // defined(__CYGWIN__) &amp;&amp; (__CYGWIN__ == 1)
<span class="lineNum">      58 </span>            : // Intel C++
<span class="lineNum">      59 </span>            : #if defined(__INTEL_COMPILER)
<span class="lineNum">      60 </span>            : #   define ELPP_COMPILER_INTEL 1
<span class="lineNum">      61 </span>            : #endif
<span class="lineNum">      62 </span>            : // Operating System Evaluation
<span class="lineNum">      63 </span>            : // Windows
<span class="lineNum">      64 </span>            : #if defined(_WIN32) || defined(_WIN64)
<span class="lineNum">      65 </span>            : #   define ELPP_OS_WINDOWS 1
<span class="lineNum">      66 </span>            : #endif  // defined(_WIN32) || defined(_WIN64)
<span class="lineNum">      67 </span>            : // Linux
<span class="lineNum">      68 </span>            : #if (defined(__linux) || defined(__linux__))
<span class="lineNum">      69 </span>            : #   define ELPP_OS_LINUX 1
<span class="lineNum">      70 </span>            : #endif  // (defined(__linux) || defined(__linux__))
<span class="lineNum">      71 </span>            : // Mac
<span class="lineNum">      72 </span>            : #if defined(__APPLE__)
<span class="lineNum">      73 </span>            : #   define ELPP_OS_MAC 1
<span class="lineNum">      74 </span>            : #endif  // defined(__APPLE__)
<span class="lineNum">      75 </span>            : // FreeBSD
<span class="lineNum">      76 </span>            : #if defined(__FreeBSD__)
<span class="lineNum">      77 </span>            : #   define ELPP_OS_FREEBSD 1
<span class="lineNum">      78 </span>            : #endif
<span class="lineNum">      79 </span>            : // Solaris
<span class="lineNum">      80 </span>            : #if defined(__sun)
<span class="lineNum">      81 </span>            : #   define ELPP_OS_SOLARIS 1
<span class="lineNum">      82 </span>            : #endif
<span class="lineNum">      83 </span>            : // Unix
<span class="lineNum">      84 </span>            : #if ((ELPP_OS_LINUX || ELPP_OS_MAC || ELPP_OS_FREEBSD || ELPP_OS_SOLARIS) &amp;&amp; (!ELPP_OS_WINDOWS))
<span class="lineNum">      85 </span>            : #   define ELPP_OS_UNIX 1
<span class="lineNum">      86 </span>            : #endif  // ((ELPP_OS_LINUX || ELPP_OS_MAC || ELPP_OS_FREEBSD || ELPP_OS_SOLARIS) &amp;&amp; (!ELPP_OS_WINDOWS))
<span class="lineNum">      87 </span>            : // Android
<span class="lineNum">      88 </span>            : #if defined(__ANDROID__)
<span class="lineNum">      89 </span>            : #   define ELPP_OS_ANDROID 1
<span class="lineNum">      90 </span>            : #endif  // defined(__ANDROID__)
<span class="lineNum">      91 </span>            : // Evaluating Cygwin as *nix OS
<span class="lineNum">      92 </span>            : #if !ELPP_OS_UNIX &amp;&amp; !ELPP_OS_WINDOWS &amp;&amp; ELPP_CYGWIN
<span class="lineNum">      93 </span>            : #   undef ELPP_OS_UNIX
<span class="lineNum">      94 </span>            : #   undef ELPP_OS_LINUX
<span class="lineNum">      95 </span>            : #   define ELPP_OS_UNIX 1
<span class="lineNum">      96 </span>            : #   define ELPP_OS_LINUX 1
<span class="lineNum">      97 </span>            : #endif //  !ELPP_OS_UNIX &amp;&amp; !ELPP_OS_WINDOWS &amp;&amp; ELPP_CYGWIN
<span class="lineNum">      98 </span>            : #if !defined(ELPP_INTERNAL_DEBUGGING_OUT_INFO)
<span class="lineNum">      99 </span>            : #   define ELPP_INTERNAL_DEBUGGING_OUT_INFO std::cout
<span class="lineNum">     100 </span>            : #endif // !defined(ELPP_INTERNAL_DEBUGGING_OUT)
<span class="lineNum">     101 </span>            : #if !defined(ELPP_INTERNAL_DEBUGGING_OUT_ERROR)
<span class="lineNum">     102 </span>            : #   define ELPP_INTERNAL_DEBUGGING_OUT_ERROR std::cerr
<span class="lineNum">     103 </span>            : #endif // !defined(ELPP_INTERNAL_DEBUGGING_OUT)
<span class="lineNum">     104 </span>            : #if !defined(ELPP_INTERNAL_DEBUGGING_ENDL)
<span class="lineNum">     105 </span>            : #   define ELPP_INTERNAL_DEBUGGING_ENDL std::endl
<span class="lineNum">     106 </span>            : #endif // !defined(ELPP_INTERNAL_DEBUGGING_OUT)
<span class="lineNum">     107 </span>            : #if !defined(ELPP_INTERNAL_DEBUGGING_MSG)
<span class="lineNum">     108 </span>            : #   define ELPP_INTERNAL_DEBUGGING_MSG(msg) msg
<span class="lineNum">     109 </span>            : #endif // !defined(ELPP_INTERNAL_DEBUGGING_OUT)
<span class="lineNum">     110 </span>            : // Internal Assertions and errors
<span class="lineNum">     111 </span>            : #if !defined(ELPP_DISABLE_ASSERT)
<span class="lineNum">     112 </span>            : #   if (defined(ELPP_DEBUG_ASSERT_FAILURE))
<span class="lineNum">     113 </span>            : #      define ELPP_ASSERT(expr, msg) if (!(expr)) { \
<span class="lineNum">     114 </span>            :           std::stringstream internalInfoStream; internalInfoStream &lt;&lt; msg; \
<span class="lineNum">     115 </span>            :           ELPP_INTERNAL_DEBUGGING_OUT_ERROR \
<span class="lineNum">     116 </span>            :               &lt;&lt; &quot;EASYLOGGING++ ASSERTION FAILED (LINE: &quot; &lt;&lt; __LINE__ &lt;&lt; &quot;) [&quot; #expr &lt;&lt; &quot;] WITH MESSAGE \&quot;&quot; \
<span class="lineNum">     117 </span>            :               &lt;&lt; ELPP_INTERNAL_DEBUGGING_MSG(internalInfoStream.str()) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; ELPP_INTERNAL_DEBUGGING_ENDL; base::utils::abort(1, \
<span class="lineNum">     118 </span>            :                   &quot;ELPP Assertion failure, please define ELPP_DEBUG_ASSERT_FAILURE&quot;); }
<span class="lineNum">     119 </span>            : #   else
<span class="lineNum">     120 </span>            : #      define ELPP_ASSERT(expr, msg) if (!(expr)) { \
<span class="lineNum">     121 </span>            :           std::stringstream internalInfoStream; internalInfoStream &lt;&lt; msg; \
<span class="lineNum">     122 </span>            :           ELPP_INTERNAL_DEBUGGING_OUT_ERROR\
<span class="lineNum">     123 </span>            :              &lt;&lt; &quot;ASSERTION FAILURE FROM EASYLOGGING++ (LINE: &quot; \
<span class="lineNum">     124 </span>            :              &lt;&lt; __LINE__ &lt;&lt; &quot;) [&quot; #expr &lt;&lt; &quot;] WITH MESSAGE \&quot;&quot; &lt;&lt; ELPP_INTERNAL_DEBUGGING_MSG(internalInfoStream.str()) &lt;&lt; &quot;\&quot;&quot; \
<span class="lineNum">     125 </span>            :              &lt;&lt; ELPP_INTERNAL_DEBUGGING_ENDL; }
<span class="lineNum">     126 </span>            : #   endif  // (defined(ELPP_DEBUG_ASSERT_FAILURE))
<span class="lineNum">     127 </span>            : #else
<span class="lineNum">     128 </span>            : #   define ELPP_ASSERT(x, y)
<span class="lineNum">     129 </span>            : #endif  //(!defined(ELPP_DISABLE_ASSERT)
<span class="lineNum">     130 </span>            : #if ELPP_COMPILER_MSVC
<span class="lineNum">     131 </span>            : #   define ELPP_INTERNAL_DEBUGGING_WRITE_PERROR \
<span class="lineNum">     132 </span>            :        { char buff[256]; strerror_s(buff, 256, errno); \
<span class="lineNum">     133 </span>            :        ELPP_INTERNAL_DEBUGGING_OUT_ERROR &lt;&lt; &quot;: &quot; &lt;&lt; buff &lt;&lt; &quot; [&quot; &lt;&lt; errno &lt;&lt; &quot;]&quot;;} (void)0
<span class="lineNum">     134 </span>            : #else
<span class="lineNum">     135 </span>            : #   define ELPP_INTERNAL_DEBUGGING_WRITE_PERROR \
<span class="lineNum">     136 </span>            :         ELPP_INTERNAL_DEBUGGING_OUT_ERROR &lt;&lt; &quot;: &quot; &lt;&lt; strerror(errno) &lt;&lt; &quot; [&quot; &lt;&lt; errno &lt;&lt; &quot;]&quot;; (void)0
<span class="lineNum">     137 </span>            : #endif  // ELPP_COMPILER_MSVC
<span class="lineNum">     138 </span>            : #if defined(ELPP_DEBUG_ERRORS)
<span class="lineNum">     139 </span>            : #   if !defined(ELPP_INTERNAL_ERROR)
<span class="lineNum">     140 </span>            : #      define ELPP_INTERNAL_ERROR(msg, pe) { \
<span class="lineNum">     141 </span>            :           std::stringstream internalInfoStream; internalInfoStream &lt;&lt; &quot;&lt;ERROR&gt; &quot; &lt;&lt; msg; \
<span class="lineNum">     142 </span>            :           ELPP_INTERNAL_DEBUGGING_OUT_ERROR \
<span class="lineNum">     143 </span>            :           &lt;&lt; &quot;ERROR FROM EASYLOGGING++ (LINE: &quot; &lt;&lt; __LINE__ &lt;&lt; &quot;) &quot; \
<span class="lineNum">     144 </span>            :           &lt;&lt; ELPP_INTERNAL_DEBUGGING_MSG(internalInfoStream.str()) &lt;&lt; ELPP_INTERNAL_DEBUGGING_ENDL; \
<span class="lineNum">     145 </span>            :           if (pe) { ELPP_INTERNAL_DEBUGGING_OUT_ERROR &lt;&lt; &quot;    &quot;; ELPP_INTERNAL_DEBUGGING_WRITE_PERROR; }} (void)0
<span class="lineNum">     146 </span>            : #   endif
<span class="lineNum">     147 </span>            : #else
<span class="lineNum">     148 </span>            : #   undef ELPP_INTERNAL_INFO
<span class="lineNum">     149 </span>            : #   define ELPP_INTERNAL_ERROR(msg, pe)
<span class="lineNum">     150 </span>            : #endif  // defined(ELPP_DEBUG_ERRORS)
<span class="lineNum">     151 </span>            : #if (defined(ELPP_DEBUG_INFO))
<span class="lineNum">     152 </span>            : #   if !(defined(ELPP_INTERNAL_INFO_LEVEL))
<span class="lineNum">     153 </span>            : #      define ELPP_INTERNAL_INFO_LEVEL 9
<span class="lineNum">     154 </span>            : #   endif  // !(defined(ELPP_INTERNAL_INFO_LEVEL))
<span class="lineNum">     155 </span>            : #   if !defined(ELPP_INTERNAL_INFO)
<span class="lineNum">     156 </span>            : #      define ELPP_INTERNAL_INFO(lvl, msg) { if (lvl &lt;= ELPP_INTERNAL_INFO_LEVEL) { \
<span class="lineNum">     157 </span>            :           std::stringstream internalInfoStream; internalInfoStream &lt;&lt; &quot;&lt;INFO&gt; &quot; &lt;&lt; msg; \
<span class="lineNum">     158 </span>            :           ELPP_INTERNAL_DEBUGGING_OUT_INFO &lt;&lt; ELPP_INTERNAL_DEBUGGING_MSG(internalInfoStream.str()) \
<span class="lineNum">     159 </span>            :              &lt;&lt; ELPP_INTERNAL_DEBUGGING_ENDL; }}
<span class="lineNum">     160 </span>            : #   endif
<span class="lineNum">     161 </span>            : #else
<span class="lineNum">     162 </span>            : #   undef ELPP_INTERNAL_INFO
<span class="lineNum">     163 </span>            : #   define ELPP_INTERNAL_INFO(lvl, msg)
<span class="lineNum">     164 </span>            : #endif  // (defined(ELPP_DEBUG_INFO))
<span class="lineNum">     165 </span>            : #if defined(ELPP_STACKTRACE_ON_CRASH)
<span class="lineNum">     166 </span>            : #   if (ELPP_COMPILER_GCC &amp;&amp; !ELPP_MINGW)
<span class="lineNum">     167 </span>            : #      define ELPP_STACKTRACE 1
<span class="lineNum">     168 </span>            : #   else
<span class="lineNum">     169 </span>            : #      if ELPP_COMPILER_MSVC
<span class="lineNum">     170 </span>            : #         pragma message(&quot;Stack trace not available for this compiler&quot;)
<span class="lineNum">     171 </span>            : #      else
<span class="lineNum">     172 </span>            : #         warning &quot;Stack trace not available for this compiler&quot;;
<span class="lineNum">     173 </span>            : #      endif  // ELPP_COMPILER_MSVC
<span class="lineNum">     174 </span>            : #   endif  // ELPP_COMPILER_GCC
<span class="lineNum">     175 </span>            : #endif  // (defined(ELPP_STACKTRACE_ON_CRASH))
<span class="lineNum">     176 </span>            : // Miscellaneous macros
<span class="lineNum">     177 </span>            : #define ELPP_UNUSED(x) (void)x
<span class="lineNum">     178 </span>            : #if ELPP_OS_UNIX
<span class="lineNum">     179 </span>            : // Log file permissions for unix-based systems
<span class="lineNum">     180 </span>            : #   define ELPP_LOG_PERMS S_IRUSR | S_IWUSR | S_IXUSR | S_IWGRP | S_IRGRP | S_IXGRP | S_IWOTH | S_IXOTH
<span class="lineNum">     181 </span>            : #endif  // ELPP_OS_UNIX
<span class="lineNum">     182 </span>            : #if defined(ELPP_AS_DLL) &amp;&amp; ELPP_COMPILER_MSVC
<span class="lineNum">     183 </span>            : #   if defined(ELPP_EXPORT_SYMBOLS)
<span class="lineNum">     184 </span>            : #      define ELPP_EXPORT __declspec(dllexport)
<span class="lineNum">     185 </span>            : #   else
<span class="lineNum">     186 </span>            : #      define ELPP_EXPORT __declspec(dllimport)
<span class="lineNum">     187 </span>            : #   endif  // defined(ELPP_EXPORT_SYMBOLS)
<span class="lineNum">     188 </span>            : #else
<span class="lineNum">     189 </span>            : #   define ELPP_EXPORT
<span class="lineNum">     190 </span>            : #endif  // defined(ELPP_AS_DLL) &amp;&amp; ELPP_COMPILER_MSVC
<span class="lineNum">     191 </span>            : // Some special functions that are VC++ specific
<span class="lineNum">     192 </span>            : #undef STRTOK
<span class="lineNum">     193 </span>            : #undef STRERROR
<span class="lineNum">     194 </span>            : #undef STRCAT
<span class="lineNum">     195 </span>            : #undef STRCPY
<span class="lineNum">     196 </span>            : #if ELPP_CRT_DBG_WARNINGS
<span class="lineNum">     197 </span>            : #   define STRTOK(a, b, c) strtok_s(a, b, c)
<span class="lineNum">     198 </span>            : #   define STRERROR(a, b, c) strerror_s(a, b, c)
<span class="lineNum">     199 </span>            : #   define STRCAT(a, b, len) strcat_s(a, len, b)
<span class="lineNum">     200 </span>            : #   define STRCPY(a, b, len) strcpy_s(a, len, b)
<span class="lineNum">     201 </span>            : #else
<span class="lineNum">     202 </span>            : #   define STRTOK(a, b, c) strtok(a, b)
<span class="lineNum">     203 </span>            : #   define STRERROR(a, b, c) strerror(c)
<span class="lineNum">     204 </span>            : #   define STRCAT(a, b, len) strcat(a, b)
<span class="lineNum">     205 </span>            : #   define STRCPY(a, b, len) strcpy(a, b)
<span class="lineNum">     206 </span>            : #endif
<span class="lineNum">     207 </span>            : // Compiler specific support evaluations
<span class="lineNum">     208 </span>            : #if (!ELPP_MINGW &amp;&amp; !ELPP_COMPILER_CLANG) || defined(ELPP_FORCE_USE_STD_THREAD)
<span class="lineNum">     209 </span>            : #   define ELPP_USE_STD_THREADING 1
<span class="lineNum">     210 </span>            : #endif  // (!ELPP_MINGW &amp;&amp; !ELPP_COMPILER_CLANG) || defined(ELPP_FORCE_USE_STD_THREAD)
<span class="lineNum">     211 </span>            : #undef ELPP_FINAL
<span class="lineNum">     212 </span>            : #if ELPP_COMPILER_INTEL || (ELPP_GCC_VERSION &lt; 40702)
<span class="lineNum">     213 </span>            : #   define ELPP_FINAL
<span class="lineNum">     214 </span>            : #else
<span class="lineNum">     215 </span>            : #   define ELPP_FINAL final
<span class="lineNum">     216 </span>            : #endif  // ELPP_COMPILER_INTEL || (ELPP_GCC_VERSION &lt; 40702)
<span class="lineNum">     217 </span>            : #if defined(ELPP_EXPERIMENTAL_ASYNC)
<span class="lineNum">     218 </span>            : #   define ELPP_ASYNC_LOGGING 1
<span class="lineNum">     219 </span>            : #else
<span class="lineNum">     220 </span>            : #   define ELPP_ASYNC_LOGGING 0
<span class="lineNum">     221 </span>            : #endif  // defined(ELPP_EXPERIMENTAL_ASYNC)
<span class="lineNum">     222 </span>            : #if defined(ELPP_THREAD_SAFE) || ELPP_ASYNC_LOGGING
<span class="lineNum">     223 </span>            : #   define ELPP_THREADING_ENABLED 1
<span class="lineNum">     224 </span>            : #endif  // defined(ELPP_THREAD_SAFE) || ELPP_ASYNC_LOGGING
<span class="lineNum">     225 </span>            : // Function macro ELPP_FUNC
<span class="lineNum">     226 </span>            : #undef ELPP_FUNC
<span class="lineNum">     227 </span>            : #if ELPP_COMPILER_MSVC  // Visual C++
<span class="lineNum">     228 </span>            : #   define ELPP_FUNC __FUNCSIG__
<span class="lineNum">     229 </span>            : #elif ELPP_COMPILER_GCC  // GCC
<span class="lineNum">     230 </span>            : #   define ELPP_FUNC __PRETTY_FUNCTION__
<span class="lineNum">     231 </span>            : #elif ELPP_COMPILER_INTEL  // Intel C++
<span class="lineNum">     232 </span>            : #   define ELPP_FUNC __PRETTY_FUNCTION__
<span class="lineNum">     233 </span>            : #elif ELPP_COMPILER_CLANG  // Clang++
<span class="lineNum">     234 </span>            : #   define ELPP_FUNC __PRETTY_FUNCTION__
<span class="lineNum">     235 </span>            : #else
<span class="lineNum">     236 </span>            : #   if defined(__func__)
<span class="lineNum">     237 </span>            : #      define ELPP_FUNC __func__
<span class="lineNum">     238 </span>            : #   else
<span class="lineNum">     239 </span>            : #      define ELPP_FUNC &quot;&quot;
<span class="lineNum">     240 </span>            : #   endif  // defined(__func__)
<span class="lineNum">     241 </span>            : #endif  // defined(_MSC_VER)
<span class="lineNum">     242 </span>            : #undef ELPP_VARIADIC_TEMPLATES_SUPPORTED
<span class="lineNum">     243 </span>            : // Keep following line commented until features are fixed
<span class="lineNum">     244 </span>            : #if ELPP_COMPILER_GCC || ELPP_COMPILER_CLANG || ELPP_COMPILER_INTEL || (ELPP_COMPILER_MSVC &amp;&amp; _MSC_VER &gt;= 1800)
<span class="lineNum">     245 </span>            : #   define ELPP_VARIADIC_TEMPLATES_SUPPORTED 1
<span class="lineNum">     246 </span>            : #endif  // ELPP_COMPILER_GCC || ELPP_COMPILER_CLANG || ELPP_COMPILER_INTEL || (ELPP_COMPILER_MSVC &amp;&amp; _MSC_VER &gt;= 1800)
<span class="lineNum">     247 </span>            : // Logging Enable/Disable macros
<span class="lineNum">     248 </span>            : #if (!defined(ELPP_DISABLE_LOGS))
<span class="lineNum">     249 </span>            : #   define ELPP_LOGGING_ENABLED 1
<span class="lineNum">     250 </span>            : #endif  // (!defined(ELPP_DISABLE_LOGS))
<span class="lineNum">     251 </span>            : #if (!defined(ELPP_DISABLE_DEBUG_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED) &amp;&amp; ((defined(_DEBUG)) || (!defined(NDEBUG))))
<span class="lineNum">     252 </span>            : #   define ELPP_DEBUG_LOG 1
<span class="lineNum">     253 </span>            : #else
<span class="lineNum">     254 </span>            : #   define ELPP_DEBUG_LOG 0
<span class="lineNum">     255 </span>            : #endif  // (!defined(ELPP_DISABLE_DEBUG_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED) &amp;&amp; ((defined(_DEBUG)) || (!defined(NDEBUG))))
<span class="lineNum">     256 </span>            : #if (!defined(ELPP_DISABLE_INFO_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     257 </span>            : #   define ELPP_INFO_LOG 1
<span class="lineNum">     258 </span>            : #else
<span class="lineNum">     259 </span>            : #   define ELPP_INFO_LOG 0
<span class="lineNum">     260 </span>            : #endif  // (!defined(ELPP_DISABLE_INFO_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     261 </span>            : #if (!defined(ELPP_DISABLE_WARNING_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     262 </span>            : #   define ELPP_WARNING_LOG 1
<span class="lineNum">     263 </span>            : #else
<span class="lineNum">     264 </span>            : #   define ELPP_WARNING_LOG 0
<span class="lineNum">     265 </span>            : #endif  // (!defined(ELPP_DISABLE_WARNING_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     266 </span>            : #if (!defined(ELPP_DISABLE_ERROR_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     267 </span>            : #   define ELPP_ERROR_LOG 1
<span class="lineNum">     268 </span>            : #else
<span class="lineNum">     269 </span>            : #   define ELPP_ERROR_LOG 0
<span class="lineNum">     270 </span>            : #endif  // (!defined(ELPP_DISABLE_ERROR_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     271 </span>            : #if (!defined(ELPP_DISABLE_FATAL_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     272 </span>            : #   define ELPP_FATAL_LOG 1
<span class="lineNum">     273 </span>            : #else
<span class="lineNum">     274 </span>            : #   define ELPP_FATAL_LOG 0
<span class="lineNum">     275 </span>            : #endif  // (!defined(ELPP_DISABLE_FATAL_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     276 </span>            : #if (!defined(ELPP_DISABLE_TRACE_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     277 </span>            : #   define ELPP_TRACE_LOG 1
<span class="lineNum">     278 </span>            : #else
<span class="lineNum">     279 </span>            : #   define ELPP_TRACE_LOG 0
<span class="lineNum">     280 </span>            : #endif  // (!defined(ELPP_DISABLE_TRACE_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     281 </span>            : #if (!defined(ELPP_DISABLE_VERBOSE_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     282 </span>            : #   define ELPP_VERBOSE_LOG 1
<span class="lineNum">     283 </span>            : #else
<span class="lineNum">     284 </span>            : #   define ELPP_VERBOSE_LOG 0
<span class="lineNum">     285 </span>            : #endif  // (!defined(ELPP_DISABLE_VERBOSE_LOGS) &amp;&amp; (ELPP_LOGGING_ENABLED))
<span class="lineNum">     286 </span>            : #if (!(ELPP_CXX0X || ELPP_CXX11))
<span class="lineNum">     287 </span>            : #   error &quot;Easylogging++ 9.0+ is only compatible with C++0x (or higher) compliant compiler&quot;
<span class="lineNum">     288 </span>            : #endif  // (!(ELPP_CXX0X || ELPP_CXX11))
<span class="lineNum">     289 </span>            : // Headers
<span class="lineNum">     290 </span>            : #if defined(ELPP_SYSLOG)
<span class="lineNum">     291 </span>            : #   include &lt;syslog.h&gt;
<span class="lineNum">     292 </span>            : #endif  // defined(ELPP_SYSLOG)
<span class="lineNum">     293 </span>            : #include &lt;ctime&gt;
<span class="lineNum">     294 </span>            : #include &lt;cstring&gt;
<span class="lineNum">     295 </span>            : #include &lt;cstdlib&gt;
<span class="lineNum">     296 </span>            : #include &lt;cctype&gt;
<span class="lineNum">     297 </span>            : #include &lt;cwchar&gt;
<span class="lineNum">     298 </span>            : #include &lt;csignal&gt;
<span class="lineNum">     299 </span>            : #include &lt;cerrno&gt;
<span class="lineNum">     300 </span>            : #include &lt;cstdarg&gt;
<span class="lineNum">     301 </span>            : #if defined(ELPP_UNICODE)
<span class="lineNum">     302 </span>            : #   include &lt;locale&gt;
<span class="lineNum">     303 </span>            : #   if ELPP_OS_WINDOWS
<span class="lineNum">     304 </span>            : #      include &lt;codecvt&gt;
<span class="lineNum">     305 </span>            : #   endif // ELPP_OS_WINDOWS
<span class="lineNum">     306 </span>            : #endif  // defined(ELPP_UNICODE)
<span class="lineNum">     307 </span>            : #if ELPP_STACKTRACE
<span class="lineNum">     308 </span>            : #   include &lt;cxxabi.h&gt;
<span class="lineNum">     309 </span>            : #   include &lt;execinfo.h&gt;
<span class="lineNum">     310 </span>            : #endif  // ELPP_STACKTRACE
<span class="lineNum">     311 </span>            : #if ELPP_OS_ANDROID
<span class="lineNum">     312 </span>            : #   include &lt;sys/system_properties.h&gt;
<span class="lineNum">     313 </span>            : #endif  // ELPP_OS_ANDROID
<span class="lineNum">     314 </span>            : #if ELPP_OS_UNIX
<span class="lineNum">     315 </span>            : #   include &lt;sys/stat.h&gt;
<span class="lineNum">     316 </span>            : #   include &lt;sys/time.h&gt;
<span class="lineNum">     317 </span>            : #elif ELPP_OS_WINDOWS
<span class="lineNum">     318 </span>            : #   include &lt;direct.h&gt;
<span class="lineNum">     319 </span>            : #   include &lt;windows.h&gt;
<span class="lineNum">     320 </span>            : #   if defined(WIN32_LEAN_AND_MEAN)
<span class="lineNum">     321 </span>            : #      if defined(ELPP_WINSOCK2)
<span class="lineNum">     322 </span>            : #         include &lt;winsock2.h&gt;
<span class="lineNum">     323 </span>            : #          else
<span class="lineNum">     324 </span>            : #         include &lt;winsock.h&gt;
<span class="lineNum">     325 </span>            : #      endif // defined(ELPP_WINSOCK2)
<span class="lineNum">     326 </span>            : #   endif // defined(WIN32_LEAN_AND_MEAN)
<span class="lineNum">     327 </span>            : #endif  // ELPP_OS_UNIX
<span class="lineNum">     328 </span>            : #include &lt;string&gt;
<span class="lineNum">     329 </span>            : #include &lt;vector&gt;
<span class="lineNum">     330 </span>            : #include &lt;map&gt;
<span class="lineNum">     331 </span>            : #include &lt;utility&gt;
<span class="lineNum">     332 </span>            : #include &lt;functional&gt;
<span class="lineNum">     333 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">     334 </span>            : #include &lt;fstream&gt;
<span class="lineNum">     335 </span>            : #include &lt;iostream&gt;
<span class="lineNum">     336 </span>            : #include &lt;sstream&gt;
<span class="lineNum">     337 </span>            : #include &lt;memory&gt;
<span class="lineNum">     338 </span>            : #include &lt;type_traits&gt;
<span class="lineNum">     339 </span>            : #if ELPP_THREADING_ENABLED
<span class="lineNum">     340 </span>            : #   if ELPP_USE_STD_THREADING
<span class="lineNum">     341 </span>            : #      include &lt;mutex&gt;
<span class="lineNum">     342 </span>            : #      include &lt;thread&gt;
<span class="lineNum">     343 </span>            : #   else
<span class="lineNum">     344 </span>            : #      if ELPP_OS_UNIX
<span class="lineNum">     345 </span>            : #         include &lt;pthread.h&gt;
<span class="lineNum">     346 </span>            : #      endif  // ELPP_OS_UNIX
<span class="lineNum">     347 </span>            : #   endif  // ELPP_USE_STD_THREADING
<span class="lineNum">     348 </span>            : #endif  // ELPP_THREADING_ENABLED
<span class="lineNum">     349 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">     350 </span>            : #   include &lt;thread&gt;
<span class="lineNum">     351 </span>            : #   include &lt;queue&gt;
<span class="lineNum">     352 </span>            : #   include &lt;condition_variable&gt;
<span class="lineNum">     353 </span>            : #endif  // ELPP_ASYNC_LOGGING 
<span class="lineNum">     354 </span>            : #if defined(ELPP_STL_LOGGING)
<span class="lineNum">     355 </span>            : // For logging STL based templates
<span class="lineNum">     356 </span>            : #   include &lt;list&gt;
<span class="lineNum">     357 </span>            : #   include &lt;queue&gt;
<span class="lineNum">     358 </span>            : #   include &lt;deque&gt;
<span class="lineNum">     359 </span>            : #   include &lt;set&gt;
<span class="lineNum">     360 </span>            : #   include &lt;bitset&gt;
<span class="lineNum">     361 </span>            : #   include &lt;stack&gt;
<span class="lineNum">     362 </span>            : #   if defined(ELPP_LOG_STD_ARRAY)
<span class="lineNum">     363 </span>            : #      include &lt;array&gt;
<span class="lineNum">     364 </span>            : #   endif  // defined(ELPP_LOG_STD_ARRAY)
<span class="lineNum">     365 </span>            : #   if defined(ELPP_LOG_UNORDERED_MAP)
<span class="lineNum">     366 </span>            : #      include &lt;unordered_map&gt;
<span class="lineNum">     367 </span>            : #   endif  // defined(ELPP_LOG_UNORDERED_MAP)
<span class="lineNum">     368 </span>            : #   if defined(ELPP_LOG_UNORDERED_SET)
<span class="lineNum">     369 </span>            : #      include &lt;unordered_set&gt;
<span class="lineNum">     370 </span>            : #   endif  // defined(ELPP_UNORDERED_SET)
<span class="lineNum">     371 </span>            : #endif  // defined(ELPP_STL_LOGGING)
<span class="lineNum">     372 </span>            : #if defined(ELPP_QT_LOGGING)
<span class="lineNum">     373 </span>            : // For logging Qt based classes &amp; templates
<span class="lineNum">     374 </span>            : #   include &lt;QString&gt;
<span class="lineNum">     375 </span>            : #   include &lt;QByteArray&gt;
<span class="lineNum">     376 </span>            : #   include &lt;QVector&gt;
<span class="lineNum">     377 </span>            : #   include &lt;QList&gt;
<span class="lineNum">     378 </span>            : #   include &lt;QPair&gt;
<span class="lineNum">     379 </span>            : #   include &lt;QMap&gt;
<span class="lineNum">     380 </span>            : #   include &lt;QQueue&gt;
<span class="lineNum">     381 </span>            : #   include &lt;QSet&gt;
<span class="lineNum">     382 </span>            : #   include &lt;QLinkedList&gt;
<span class="lineNum">     383 </span>            : #   include &lt;QHash&gt;
<span class="lineNum">     384 </span>            : #   include &lt;QMultiHash&gt;
<span class="lineNum">     385 </span>            : #   include &lt;QStack&gt;
<span class="lineNum">     386 </span>            : #endif  // defined(ELPP_QT_LOGGING)
<span class="lineNum">     387 </span>            : #if defined(ELPP_BOOST_LOGGING)
<span class="lineNum">     388 </span>            : // For logging boost based classes &amp; templates
<span class="lineNum">     389 </span>            : #   include &lt;boost/container/vector.hpp&gt;
<span class="lineNum">     390 </span>            : #   include &lt;boost/container/stable_vector.hpp&gt;
<span class="lineNum">     391 </span>            : #   include &lt;boost/container/list.hpp&gt;
<span class="lineNum">     392 </span>            : #   include &lt;boost/container/deque.hpp&gt;
<span class="lineNum">     393 </span>            : #   include &lt;boost/container/map.hpp&gt;
<span class="lineNum">     394 </span>            : #   include &lt;boost/container/flat_map.hpp&gt;
<span class="lineNum">     395 </span>            : #   include &lt;boost/container/set.hpp&gt;
<span class="lineNum">     396 </span>            : #   include &lt;boost/container/flat_set.hpp&gt;
<span class="lineNum">     397 </span>            : #endif  // defined(ELPP_BOOST_LOGGING)
<span class="lineNum">     398 </span>            : #if defined(ELPP_WXWIDGETS_LOGGING)
<span class="lineNum">     399 </span>            : // For logging wxWidgets based classes &amp; templates
<span class="lineNum">     400 </span>            : #   include &lt;wx/vector.h&gt;
<span class="lineNum">     401 </span>            : #endif  // defined(ELPP_WXWIDGETS_LOGGING)
<span class="lineNum">     402 </span>            : // Forward declarations
<span class="lineNum">     403 </span>            : namespace el {
<span class="lineNum">     404 </span>            : class Logger;
<span class="lineNum">     405 </span>            : class LogMessage;
<span class="lineNum">     406 </span>            : class PerformanceTrackingData;
<span class="lineNum">     407 </span>            : class Loggers;
<span class="lineNum">     408 </span>            : class Helpers;
<span class="lineNum">     409 </span>            : template &lt;typename T&gt; class Callback;
<span class="lineNum">     410 </span>            : class LogDispatchCallback;
<span class="lineNum">     411 </span>            : class PerformanceTrackingCallback;
<span class="lineNum">     412 </span>            : class LogDispatchData;
<span class="lineNum">     413 </span>            : namespace base {
<span class="lineNum">     414 </span>            : class Storage;
<span class="lineNum">     415 </span>            : class RegisteredLoggers;
<span class="lineNum">     416 </span>            : class PerformanceTracker;
<span class="lineNum">     417 </span>            : class MessageBuilder;
<span class="lineNum">     418 </span>            : class Writer;
<span class="lineNum">     419 </span>            : class PErrorWriter;
<span class="lineNum">     420 </span>            : class LogDispatcher;
<span class="lineNum">     421 </span>            : class DefaultLogBuilder;
<span class="lineNum">     422 </span>            : class DefaultLogDispatchCallback;
<span class="lineNum">     423 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">     424 </span>            : class AsyncLogDispatchCallback;
<span class="lineNum">     425 </span>            : class AsyncDispatchWorker;
<span class="lineNum">     426 </span>            : #endif // ELPP_ASYNC_LOGGING
<span class="lineNum">     427 </span>            : class DefaultPerformanceTrackingCallback;
<span class="lineNum">     428 </span>            : }  // namespace base
<span class="lineNum">     429 </span>            : }  // namespace el
<span class="lineNum">     430 </span>            : /// @brief Easylogging++ entry namespace
<span class="lineNum">     431 </span>            : namespace el {
<span class="lineNum">     432 </span>            : /// @brief Namespace containing base/internal functionality used by Easylogging++
<span class="lineNum">     433 </span>            : namespace base {
<span class="lineNum">     434 </span>            : /// @brief Data types used by Easylogging++
<span class="lineNum">     435 </span>            : namespace type {
<span class="lineNum">     436 </span>            : #undef ELPP_LITERAL
<span class="lineNum">     437 </span>            : #undef ELPP_STRLEN
<span class="lineNum">     438 </span>            : #undef ELPP_COUT
<span class="lineNum">     439 </span>            : #if defined(ELPP_UNICODE)
<span class="lineNum">     440 </span>            : #   define ELPP_LITERAL(txt) L##txt
<span class="lineNum">     441 </span>            : #   define ELPP_STRLEN wcslen
<span class="lineNum">     442 </span>            : #   if defined ELPP_CUSTOM_COUT
<span class="lineNum">     443 </span>            : #      define ELPP_COUT ELPP_CUSTOM_COUT
<span class="lineNum">     444 </span>            : #   else
<span class="lineNum">     445 </span>            : #      define ELPP_COUT std::wcout
<span class="lineNum">     446 </span>            : #   endif  // defined ELPP_CUSTOM_COUT
<span class="lineNum">     447 </span>            : typedef wchar_t char_t;
<span class="lineNum">     448 </span>            : typedef std::wstring string_t;
<span class="lineNum">     449 </span>            : typedef std::wstringstream stringstream_t;
<span class="lineNum">     450 </span>            : typedef std::wfstream fstream_t;
<span class="lineNum">     451 </span>            : typedef std::wostream ostream_t;
<span class="lineNum">     452 </span>            : #else
<span class="lineNum">     453 </span>            : #   define ELPP_LITERAL(txt) txt
<span class="lineNum">     454 </span>            : #   define ELPP_STRLEN strlen
<span class="lineNum">     455 </span>            : #   if defined ELPP_CUSTOM_COUT
<span class="lineNum">     456 </span>            : #      define ELPP_COUT ELPP_CUSTOM_COUT
<span class="lineNum">     457 </span>            : #   else
<span class="lineNum">     458 </span>            : #      define ELPP_COUT std::cout
<span class="lineNum">     459 </span>            : #   endif  // defined ELPP_CUSTOM_COUT
<span class="lineNum">     460 </span>            : typedef char char_t;
<span class="lineNum">     461 </span>            : typedef std::string string_t;
<span class="lineNum">     462 </span>            : typedef std::stringstream stringstream_t;
<span class="lineNum">     463 </span>            : typedef std::fstream fstream_t;
<span class="lineNum">     464 </span>            : typedef std::ostream ostream_t;
<span class="lineNum">     465 </span>            : #endif  // defined(ELPP_UNICODE)
<span class="lineNum">     466 </span>            : #if defined(ELPP_CUSTOM_COUT_LINE)
<span class="lineNum">     467 </span>            : #   define ELPP_COUT_LINE(logLine) ELPP_CUSTOM_COUT_LINE(logLine)
<span class="lineNum">     468 </span>            : #else
<span class="lineNum">     469 </span>            : #   define ELPP_COUT_LINE(logLine) logLine &lt;&lt; std::flush
<span class="lineNum">     470 </span>            : #endif // defined(ELPP_CUSTOM_COUT_LINE)
<span class="lineNum">     471 </span>            : typedef unsigned short EnumType;
<span class="lineNum">     472 </span>            : typedef std::shared_ptr&lt;base::Storage&gt; StoragePointer;
<span class="lineNum">     473 </span>            : typedef int VerboseLevel;
<span class="lineNum">     474 </span>            : typedef std::shared_ptr&lt;LogDispatchCallback&gt; LogDispatchCallbackPtr;
<span class="lineNum">     475 </span>            : typedef std::shared_ptr&lt;PerformanceTrackingCallback&gt; PerformanceTrackingCallbackPtr;
<span class="lineNum">     476 </span>            : }  // namespace type
<span class="lineNum">     477 </span>            : /// @brief Internal helper class that prevent copy constructor for class
<span class="lineNum">     478 </span>            : ///
<span class="lineNum">     479 </span>            : /// @detail When using this class simply inherit it privately
<a name="480"><span class="lineNum">     480 </span>            : class NoCopy {</a>
<span class="lineNum">     481 </span>            : protected:
<span class="lineNum">     482 </span><span class="lineCov">      15046 :     NoCopy(void) {}</span>
<span class="lineNum">     483 </span>            : private:
<span class="lineNum">     484 </span>            :     NoCopy(const NoCopy&amp;);
<span class="lineNum">     485 </span>            :     NoCopy&amp; operator=(const NoCopy&amp;);
<span class="lineNum">     486 </span>            : };
<span class="lineNum">     487 </span>            : /// @brief Internal helper class that makes all default constructors private.
<span class="lineNum">     488 </span>            : ///
<span class="lineNum">     489 </span>            : /// @detail This prevents initializing class making it static unless an explicit constructor is declared.
<span class="lineNum">     490 </span>            : /// When using this class simply inherit it privately
<span class="lineNum">     491 </span>            : class StaticClass {
<span class="lineNum">     492 </span>            : private:
<span class="lineNum">     493 </span>            :     StaticClass(void);
<span class="lineNum">     494 </span>            :     StaticClass(const StaticClass&amp;);
<span class="lineNum">     495 </span>            :     StaticClass&amp; operator=(const StaticClass&amp;);
<span class="lineNum">     496 </span>            : };
<span class="lineNum">     497 </span>            : }  // namespace base
<span class="lineNum">     498 </span>            : /// @brief Represents enumeration for severity level used to determine level of logging
<span class="lineNum">     499 </span>            : ///
<span class="lineNum">     500 </span>            : /// @detail With Easylogging++, developers may disable or enable any level regardless of
<span class="lineNum">     501 </span>            : /// what the severity is. Or they can choose to log using hierarchical logging flag
<span class="lineNum">     502 </span>            : enum class Level : base::type::EnumType {
<span class="lineNum">     503 </span>            :         /// @brief Generic level that represents all the levels. Useful when setting global configuration for all levels
<span class="lineNum">     504 </span>            :         Global = 1,
<span class="lineNum">     505 </span>            :         /// @brief Information that can be useful to back-trace certain events - mostly useful than debug logs.
<span class="lineNum">     506 </span>            :         Trace = 2,
<span class="lineNum">     507 </span>            :         /// @brief Informational events most useful for developers to debug application
<span class="lineNum">     508 </span>            :         Debug = 4,
<span class="lineNum">     509 </span>            :         /// @brief Severe error information that will presumably abort application
<span class="lineNum">     510 </span>            :         Fatal = 8, 
<span class="lineNum">     511 </span>            :         /// @brief Information representing errors in application but application will keep running
<span class="lineNum">     512 </span>            :         Error = 16,
<span class="lineNum">     513 </span>            :         /// @brief Useful when application has potentially harmful situtaions
<span class="lineNum">     514 </span>            :         Warning = 32, 
<span class="lineNum">     515 </span>            :         /// @brief Information that can be highly useful and vary with verbose logging level.
<span class="lineNum">     516 </span>            :         Verbose = 64,
<span class="lineNum">     517 </span>            :         /// @brief Mainly useful to represent current progress of application
<span class="lineNum">     518 </span>            :         Info = 128, 
<span class="lineNum">     519 </span>            :         /// @brief Represents unknown level
<span class="lineNum">     520 </span>            :         Unknown = 1010
<span class="lineNum">     521 </span>            : };
<span class="lineNum">     522 </span>            : /// @brief Static class that contains helper functions for el::Level
<span class="lineNum">     523 </span>            : class LevelHelper : base::StaticClass {
<span class="lineNum">     524 </span>            : public:
<span class="lineNum">     525 </span>            :     /// @brief Represents minimum valid level. Useful when iterating through enum.
<span class="lineNum">     526 </span>            :     static const base::type::EnumType kMinValid = static_cast&lt;base::type::EnumType&gt;(Level::Trace);
<span class="lineNum">     527 </span>            :     /// @brief Represents maximum valid level. This is used internally and you should not need it.
<a name="528"><span class="lineNum">     528 </span>            :     static const base::type::EnumType kMaxValid = static_cast&lt;base::type::EnumType&gt;(Level::Info);</a>
<span class="lineNum">     529 </span>            :     /// @brief Casts level to int, useful for iterating through enum.
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     static base::type::EnumType castToInt(Level level) {</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :         return static_cast&lt;base::type::EnumType&gt;(level);</span>
<a name="532"><span class="lineNum">     532 </span>            :     }</a>
<span class="lineNum">     533 </span>            :     /// @brief Casts int(ushort) to level, useful for iterating through enum.
<span class="lineNum">     534 </span><span class="lineCov">       2422 :     static Level castFromInt(base::type::EnumType l) {</span>
<span class="lineNum">     535 </span><span class="lineCov">       2422 :         return static_cast&lt;Level&gt;(l);</span>
<span class="lineNum">     536 </span>            :     }
<a name="537"><span class="lineNum">     537 </span>            :     /// @brief Converts level to associated const char*</a>
<span class="lineNum">     538 </span>            :     /// @return Upper case string based level.
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     static const char* convertToString(Level level) {</span>
<span class="lineNum">     540 </span>            :        // Do not use switch over strongly typed enums because Intel C++ compilers dont support them yet.
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         if (level == Level::Global) return &quot;GLOBAL&quot;;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         if (level == Level::Debug) return &quot;DEBUG&quot;;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         if (level == Level::Info) return &quot;INFO&quot;;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         if (level == Level::Warning) return &quot;WARNING&quot;;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :         if (level == Level::Error) return &quot;ERROR&quot;;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         if (level == Level::Fatal) return &quot;FATAL&quot;;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         if (level == Level::Verbose) return &quot;VERBOSE&quot;;</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         if (level == Level::Trace) return &quot;TRACE&quot;;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         return &quot;UNKNOWN&quot;;</span>
<span class="lineNum">     550 </span>            :     }
<span class="lineNum">     551 </span>            :     /// @brief Converts from levelStr to Level
<a name="552"><span class="lineNum">     552 </span>            :     /// @param levelStr Upper case string based level.</a>
<span class="lineNum">     553 </span>            :     ///        Lower case is also valid but providing upper case is recommended.
<span class="lineNum">     554 </span><span class="lineCov">         72 :     static Level convertFromString(const char* levelStr) {</span>
<span class="lineNum">     555 </span><span class="lineCov">         72 :         if ((strcmp(levelStr, &quot;GLOBAL&quot;) == 0) || (strcmp(levelStr, &quot;global&quot;) == 0))</span>
<span class="lineNum">     556 </span><span class="lineCov">         12 :             return Level::Global;</span>
<span class="lineNum">     557 </span><span class="lineCov">         60 :         if ((strcmp(levelStr, &quot;DEBUG&quot;) == 0) || (strcmp(levelStr, &quot;debug&quot;) == 0))</span>
<span class="lineNum">     558 </span><span class="lineCov">         12 :             return Level::Debug;</span>
<span class="lineNum">     559 </span><span class="lineCov">         48 :         if ((strcmp(levelStr, &quot;INFO&quot;) == 0) || (strcmp(levelStr, &quot;info&quot;) == 0))</span>
<span class="lineNum">     560 </span><span class="lineCov">         12 :             return Level::Info;</span>
<span class="lineNum">     561 </span><span class="lineCov">         36 :         if ((strcmp(levelStr, &quot;WARNING&quot;) == 0) || (strcmp(levelStr, &quot;warning&quot;) == 0))</span>
<span class="lineNum">     562 </span><span class="lineCov">         12 :             return Level::Warning;</span>
<span class="lineNum">     563 </span><span class="lineCov">         24 :         if ((strcmp(levelStr, &quot;ERROR&quot;) == 0) || (strcmp(levelStr, &quot;error&quot;) == 0))</span>
<span class="lineNum">     564 </span><span class="lineCov">         12 :             return Level::Error;</span>
<span class="lineNum">     565 </span><span class="lineCov">         12 :         if ((strcmp(levelStr, &quot;FATAL&quot;) == 0) || (strcmp(levelStr, &quot;fatal&quot;) == 0))</span>
<span class="lineNum">     566 </span><span class="lineCov">         12 :             return Level::Fatal;</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :         if ((strcmp(levelStr, &quot;VERBOSE&quot;) == 0) || (strcmp(levelStr, &quot;verbose&quot;) == 0))</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :             return Level::Verbose;</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :         if ((strcmp(levelStr, &quot;TRACE&quot;) == 0) || (strcmp(levelStr, &quot;trace&quot;) == 0))</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :             return Level::Trace;</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         return Level::Unknown;</span>
<span class="lineNum">     572 </span>            :     }
<span class="lineNum">     573 </span>            :     /// @brief Applies specified function to each level starting from startIndex
<span class="lineNum">     574 </span>            :     /// @param startIndex initial value to start the iteration from. This is passed as pointer and 
<a name="575"><span class="lineNum">     575 </span>            :     ///        is left-shifted so this can be used inside function (fn) to represent current level.</a>
<span class="lineNum">     576 </span>            :     /// @param fn function to apply with each level. This bool represent whether or not to stop iterating through levels.
<span class="lineNum">     577 </span><span class="lineCov">        346 :     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function&lt;bool(void)&gt;&amp; fn) {</span>
<span class="lineNum">     578 </span><span class="lineCov">        346 :         base::type::EnumType lIndexMax = LevelHelper::kMaxValid;</span>
<span class="lineNum">     579 </span><span class="lineCov">       2422 :         do {</span>
<span class="lineNum">     580 </span><span class="lineCov">       2422 :             if (fn()) {</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     582 </span>            :             }
<span class="lineNum">     583 </span><span class="lineCov">       2422 :             *startIndex = static_cast&lt;base::type::EnumType&gt;(*startIndex &lt;&lt; 1);</span>
<span class="lineNum">     584 </span><span class="lineCov">       2422 :         } while (*startIndex &lt;= lIndexMax);</span>
<span class="lineNum">     585 </span><span class="lineCov">        346 :     }</span>
<span class="lineNum">     586 </span>            : };
<span class="lineNum">     587 </span>            : /// @brief Represents enumeration of ConfigurationType used to configure or access certain aspect
<span class="lineNum">     588 </span>            : /// of logging
<span class="lineNum">     589 </span>            : enum class ConfigurationType : base::type::EnumType {
<span class="lineNum">     590 </span>            :    /// @brief Determines whether or not corresponding level and logger of logging is enabled
<span class="lineNum">     591 </span>            :    /// You may disable all logs by using el::Level::Global
<span class="lineNum">     592 </span>            :     Enabled = 1,
<span class="lineNum">     593 </span>            :    /// @brief Whether or not to write corresponding log to log file
<span class="lineNum">     594 </span>            :     ToFile = 2,
<span class="lineNum">     595 </span>            :    /// @brief Whether or not to write corresponding level and logger log to standard output.
<span class="lineNum">     596 </span>            :    /// By standard output meaning termnal, command prompt etc
<span class="lineNum">     597 </span>            :     ToStandardOutput = 4,
<span class="lineNum">     598 </span>            :    /// @brief Determines format of logging corresponding level and logger.
<span class="lineNum">     599 </span>            :     Format = 8,
<span class="lineNum">     600 </span>            :    /// @brief Determines log file (full path) to write logs to for correponding level and logger
<span class="lineNum">     601 </span>            :     Filename = 16,
<span class="lineNum">     602 </span>            :    /// @brief Specifies milliseconds width. Width can be within range (1-6)
<span class="lineNum">     603 </span>            :     MillisecondsWidth = 32,
<span class="lineNum">     604 </span>            :    /// @brief Determines whether or not performance tracking is enabled.
<span class="lineNum">     605 </span>            :    ///
<span class="lineNum">     606 </span>            :    /// @detail This does not depend on logger or level. Performance tracking always uses 'performance' logger
<span class="lineNum">     607 </span>            :     PerformanceTracking = 64,
<span class="lineNum">     608 </span>            :    /// @brief Specifies log file max size.
<span class="lineNum">     609 </span>            :    ///
<span class="lineNum">     610 </span>            :    /// @detail If file size of corresponding log file (for corresponding level) is &gt;= specified size, log file will 
<span class="lineNum">     611 </span>            :    /// be truncated and re-initiated.
<span class="lineNum">     612 </span>            :     MaxLogFileSize = 128,
<span class="lineNum">     613 </span>            :    /// @brief Specifies number of log entries to hold until we flush pending log data
<span class="lineNum">     614 </span>            :     LogFlushThreshold = 256,
<span class="lineNum">     615 </span>            :    /// @brief Represents unknown configuration
<span class="lineNum">     616 </span>            :     Unknown = 1010
<span class="lineNum">     617 </span>            : };
<span class="lineNum">     618 </span>            : /// @brief Static class that contains helper functions for el::ConfigurationType
<span class="lineNum">     619 </span>            : class ConfigurationTypeHelper : base::StaticClass {
<span class="lineNum">     620 </span>            : public:
<span class="lineNum">     621 </span>            :     /// @brief Represents minimum valid configuration type. Useful when iterating through enum.
<span class="lineNum">     622 </span>            :     static const base::type::EnumType kMinValid = static_cast&lt;base::type::EnumType&gt;(ConfigurationType::Enabled);
<span class="lineNum">     623 </span>            :     /// @brief Represents maximum valid configuration type. This is used internally and you should not need it.
<span class="lineNum">     624 </span>            :     static const base::type::EnumType kMaxValid = static_cast&lt;base::type::EnumType&gt;(ConfigurationType::MaxLogFileSize);
<span class="lineNum">     625 </span>            :     /// @brief Casts configuration type to int, useful for iterating through enum.
<span class="lineNum">     626 </span>            :     static base::type::EnumType castToInt(ConfigurationType configurationType) {
<span class="lineNum">     627 </span>            :         return static_cast&lt;base::type::EnumType&gt;(configurationType);
<span class="lineNum">     628 </span>            :     }
<span class="lineNum">     629 </span>            :     /// @brief Casts int(ushort) to configurationt type, useful for iterating through enum.
<span class="lineNum">     630 </span>            :     static ConfigurationType castFromInt(base::type::EnumType c) {
<span class="lineNum">     631 </span>            :         return static_cast&lt;ConfigurationType&gt;(c);
<span class="lineNum">     632 </span>            :     }
<a name="633"><span class="lineNum">     633 </span>            :     /// @brief Converts configuration type to associated const char*</a>
<span class="lineNum">     634 </span>            :     /// @returns Upper case string based configuration type.
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     static const char* convertToString(ConfigurationType configurationType) {</span>
<span class="lineNum">     636 </span>            :         // Do not use switch over strongly typed enums because Intel C++ compilers dont support them yet.
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         if (configurationType == ConfigurationType::Enabled) return &quot;ENABLED&quot;;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         if (configurationType == ConfigurationType::Filename) return &quot;FILENAME&quot;;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         if (configurationType == ConfigurationType::Format) return &quot;FORMAT&quot;;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         if (configurationType == ConfigurationType::ToFile) return &quot;TO_FILE&quot;;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :         if (configurationType == ConfigurationType::ToStandardOutput) return &quot;TO_STANDARD_OUTPUT&quot;;</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :         if (configurationType == ConfigurationType::MillisecondsWidth) return &quot;MILLISECONDS_WIDTH&quot;;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :         if (configurationType == ConfigurationType::PerformanceTracking) return &quot;PERFORMANCE_TRACKING&quot;;</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         if (configurationType == ConfigurationType::MaxLogFileSize) return &quot;MAX_LOG_FILE_SIZE&quot;;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         if (configurationType == ConfigurationType::LogFlushThreshold) return &quot;LOG_FLUSH_THRESHOLD&quot;;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         return &quot;UNKNOWN&quot;;</span>
<span class="lineNum">     647 </span>            :     }
<span class="lineNum">     648 </span>            :     /// @brief Converts from configStr to ConfigurationType
<a name="649"><span class="lineNum">     649 </span>            :     /// @param configStr Upper case string based configuration type.</a>
<span class="lineNum">     650 </span>            :     ///        Lower case is also valid but providing upper case is recommended.
<span class="lineNum">     651 </span><span class="lineCov">        120 :     static ConfigurationType convertFromString(const char* configStr) {</span>
<span class="lineNum">     652 </span><span class="lineCov">        120 :         if ((strcmp(configStr, &quot;ENABLED&quot;) == 0) || (strcmp(configStr, &quot;enabled&quot;) == 0))</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :             return ConfigurationType::Enabled;</span>
<span class="lineNum">     654 </span><span class="lineCov">        120 :         if ((strcmp(configStr, &quot;TO_FILE&quot;) == 0) || (strcmp(configStr, &quot;to_file&quot;) == 0))</span>
<span class="lineNum">     655 </span><span class="lineCov">         12 :             return ConfigurationType::ToFile;</span>
<span class="lineNum">     656 </span><span class="lineCov">        108 :         if ((strcmp(configStr, &quot;TO_STANDARD_OUTPUT&quot;) == 0) || (strcmp(configStr, &quot;to_standard_output&quot;) == 0))</span>
<span class="lineNum">     657 </span><span class="lineCov">         72 :             return ConfigurationType::ToStandardOutput;</span>
<span class="lineNum">     658 </span><span class="lineCov">         36 :         if ((strcmp(configStr, &quot;FORMAT&quot;) == 0) || (strcmp(configStr, &quot;format&quot;) == 0))</span>
<span class="lineNum">     659 </span><span class="lineCov">         24 :             return ConfigurationType::Format;</span>
<span class="lineNum">     660 </span><span class="lineCov">         12 :         if ((strcmp(configStr, &quot;FILENAME&quot;) == 0) || (strcmp(configStr, &quot;filename&quot;) == 0))</span>
<span class="lineNum">     661 </span><span class="lineCov">         12 :             return ConfigurationType::Filename;</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         if ((strcmp(configStr, &quot;MILLISECONDS_WIDTH&quot;) == 0) || (strcmp(configStr, &quot;milliseconds_width&quot;) == 0))</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :             return ConfigurationType::MillisecondsWidth;</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :         if ((strcmp(configStr, &quot;PERFORMANCE_TRACKING&quot;) == 0) || (strcmp(configStr, &quot;performance_tracking&quot;) == 0))</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :             return ConfigurationType::PerformanceTracking;</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :         if ((strcmp(configStr, &quot;MAX_LOG_FILE_SIZE&quot;) == 0) || (strcmp(configStr, &quot;max_log_file_size&quot;) == 0))</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :             return ConfigurationType::MaxLogFileSize;</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         if ((strcmp(configStr, &quot;LOG_FLUSH_THRESHOLD&quot;) == 0) || (strcmp(configStr, &quot;log_flush_threshold&quot;) == 0))</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :             return ConfigurationType::LogFlushThreshold;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :         return ConfigurationType::Unknown;</span>
<span class="lineNum">     671 </span>            :     }
<span class="lineNum">     672 </span>            :     /// @brief Applies specified function to each configuration type starting from startIndex
<span class="lineNum">     673 </span>            :     /// @param startIndex initial value to start the iteration from. This is passed by pointer and is left-shifted
<span class="lineNum">     674 </span>            :     ///        so this can be used inside function (fn) to represent current configuration type.
<span class="lineNum">     675 </span>            :     /// @param fn function to apply with each configuration type. 
<span class="lineNum">     676 </span>            :     ///        This bool represent whether or not to stop iterating through configurations.
<span class="lineNum">     677 </span>            :     static inline void forEachConfigType(base::type::EnumType* startIndex, const std::function&lt;bool(void)&gt;&amp; fn) {
<span class="lineNum">     678 </span>            :         base::type::EnumType cIndexMax = ConfigurationTypeHelper::kMaxValid;
<span class="lineNum">     679 </span>            :         do {
<span class="lineNum">     680 </span>            :             if (fn()) {
<span class="lineNum">     681 </span>            :                 break;
<span class="lineNum">     682 </span>            :             }
<span class="lineNum">     683 </span>            :             *startIndex = static_cast&lt;base::type::EnumType&gt;(*startIndex &lt;&lt; 1);
<span class="lineNum">     684 </span>            :         } while (*startIndex &lt;= cIndexMax);
<span class="lineNum">     685 </span>            :     }
<span class="lineNum">     686 </span>            : };
<span class="lineNum">     687 </span>            : /// @brief Flags used while writing logs. This flags are set by user
<span class="lineNum">     688 </span>            : enum class LoggingFlag : base::type::EnumType {
<span class="lineNum">     689 </span>            :     /// @brief Makes sure we have new line for each container log entry
<span class="lineNum">     690 </span>            :     NewLineForContainer = 1,
<span class="lineNum">     691 </span>            :     /// @brief Makes sure if -vmodule is used and does not specifies a module, then verbose
<span class="lineNum">     692 </span>            :     /// logging is allowed via that module.
<span class="lineNum">     693 </span>            :     AllowVerboseIfModuleNotSpecified = 2,
<span class="lineNum">     694 </span>            :     /// @brief When handling crashes by default, detailed crash reason will be logged as well
<span class="lineNum">     695 </span>            :     LogDetailedCrashReason = 4,
<span class="lineNum">     696 </span>            :     /// @brief Allows to disable application abortion when logged using FATAL level
<span class="lineNum">     697 </span>            :     DisableApplicationAbortOnFatalLog = 8,
<span class="lineNum">     698 </span>            :     /// @brief Flushes log with every log-entry (performance sensative) - Disabled by default
<span class="lineNum">     699 </span>            :     ImmediateFlush = 16,
<span class="lineNum">     700 </span>            :     /// @brief Enables strict file rolling
<span class="lineNum">     701 </span>            :     StrictLogFileSizeCheck = 32,
<span class="lineNum">     702 </span>            :     /// @brief Make terminal output colorful for supported terminals
<span class="lineNum">     703 </span>            :     ColoredTerminalOutput = 64,
<span class="lineNum">     704 </span>            :     /// @brief Supports use of multiple logging in same macro, e.g, CLOG(INFO, &quot;default&quot;, &quot;network&quot;)
<span class="lineNum">     705 </span>            :     MultiLoggerSupport = 128,
<span class="lineNum">     706 </span>            :     /// @brief Disables comparing performance tracker's checkpoints
<span class="lineNum">     707 </span>            :     DisablePerformanceTrackingCheckpointComparison = 256,
<span class="lineNum">     708 </span>            :     /// @brief Disable VModules
<span class="lineNum">     709 </span>            :     DisableVModules = 512,
<span class="lineNum">     710 </span>            :     /// @brief Disable VModules extensions
<span class="lineNum">     711 </span>            :     DisableVModulesExtensions = 1024,
<span class="lineNum">     712 </span>            :     /// @brief Enables hierarchical logging
<span class="lineNum">     713 </span>            :     HierarchicalLogging = 2048,
<span class="lineNum">     714 </span>            :     /// @brief Creates logger automatically when not available
<span class="lineNum">     715 </span>            :     CreateLoggerAutomatically = 4096,
<span class="lineNum">     716 </span>            :     /// @brief Adds spaces b/w logs that separated by left-shift operator
<span class="lineNum">     717 </span>            :     AutoSpacing = 8192,
<span class="lineNum">     718 </span>            :     /// @brief Preserves time format and does not convert it to sec, hour etc (performance tracking only)
<span class="lineNum">     719 </span>            :     FixedTimeFormat = 16384
<span class="lineNum">     720 </span>            : };
<span class="lineNum">     721 </span>            : namespace base {
<span class="lineNum">     722 </span>            : /// @brief Namespace containing constants used internally.
<span class="lineNum">     723 </span>            : namespace consts {
<span class="lineNum">     724 </span>            :     // Level log values - These are values that are replaced in place of %level format specifier
<span class="lineNum">     725 </span>            :     static const base::type::char_t* kInfoLevelLogValue     =   ELPP_LITERAL(&quot;INFO &quot;);
<span class="lineNum">     726 </span>            :     static const base::type::char_t* kDebugLevelLogValue    =   ELPP_LITERAL(&quot;DEBUG&quot;);
<span class="lineNum">     727 </span>            :     static const base::type::char_t* kWarningLevelLogValue  =   ELPP_LITERAL(&quot;WARN &quot;);
<span class="lineNum">     728 </span>            :     static const base::type::char_t* kErrorLevelLogValue    =   ELPP_LITERAL(&quot;ERROR&quot;);
<span class="lineNum">     729 </span>            :     static const base::type::char_t* kFatalLevelLogValue    =   ELPP_LITERAL(&quot;FATAL&quot;);
<span class="lineNum">     730 </span>            :     static const base::type::char_t* kVerboseLevelLogValue  =   ELPP_LITERAL(&quot;VER&quot;);
<span class="lineNum">     731 </span>            :     static const base::type::char_t* kTraceLevelLogValue    =   ELPP_LITERAL(&quot;TRACE&quot;);
<span class="lineNum">     732 </span>            :     static const base::type::char_t* kInfoLevelShortLogValue     =   ELPP_LITERAL(&quot;I&quot;);
<span class="lineNum">     733 </span>            :     static const base::type::char_t* kDebugLevelShortLogValue    =   ELPP_LITERAL(&quot;D&quot;);
<span class="lineNum">     734 </span>            :     static const base::type::char_t* kWarningLevelShortLogValue  =   ELPP_LITERAL(&quot;W&quot;);
<span class="lineNum">     735 </span>            :     static const base::type::char_t* kErrorLevelShortLogValue    =   ELPP_LITERAL(&quot;E&quot;);
<span class="lineNum">     736 </span>            :     static const base::type::char_t* kFatalLevelShortLogValue    =   ELPP_LITERAL(&quot;F&quot;);
<span class="lineNum">     737 </span>            :     static const base::type::char_t* kVerboseLevelShortLogValue  =   ELPP_LITERAL(&quot;V&quot;);
<span class="lineNum">     738 </span>            :     static const base::type::char_t* kTraceLevelShortLogValue    =   ELPP_LITERAL(&quot;T&quot;);
<span class="lineNum">     739 </span>            :     // Format specifiers - These are used to define log format
<span class="lineNum">     740 </span>            :     static const base::type::char_t* kAppNameFormatSpecifier          =      ELPP_LITERAL(&quot;%app&quot;);
<span class="lineNum">     741 </span>            :     static const base::type::char_t* kLoggerIdFormatSpecifier         =      ELPP_LITERAL(&quot;%logger&quot;);
<span class="lineNum">     742 </span>            :     static const base::type::char_t* kThreadIdFormatSpecifier         =      ELPP_LITERAL(&quot;%thread&quot;);
<span class="lineNum">     743 </span>            :     static const base::type::char_t* kSeverityLevelFormatSpecifier    =      ELPP_LITERAL(&quot;%level&quot;);
<span class="lineNum">     744 </span>            :     static const base::type::char_t* kSeverityLevelShortFormatSpecifier    =      ELPP_LITERAL(&quot;%levshort&quot;);
<span class="lineNum">     745 </span>            :     static const base::type::char_t* kDateTimeFormatSpecifier         =      ELPP_LITERAL(&quot;%datetime&quot;);
<span class="lineNum">     746 </span>            :     static const base::type::char_t* kLogFileFormatSpecifier          =      ELPP_LITERAL(&quot;%file&quot;);
<span class="lineNum">     747 </span>            :     static const base::type::char_t* kLogFileBaseFormatSpecifier      =      ELPP_LITERAL(&quot;%fbase&quot;);
<span class="lineNum">     748 </span>            :     static const base::type::char_t* kLogLineFormatSpecifier          =      ELPP_LITERAL(&quot;%line&quot;);
<span class="lineNum">     749 </span>            :     static const base::type::char_t* kLogLocationFormatSpecifier      =      ELPP_LITERAL(&quot;%loc&quot;);
<span class="lineNum">     750 </span>            :     static const base::type::char_t* kLogFunctionFormatSpecifier      =      ELPP_LITERAL(&quot;%func&quot;);
<span class="lineNum">     751 </span>            :     static const base::type::char_t* kCurrentUserFormatSpecifier      =      ELPP_LITERAL(&quot;%user&quot;);
<span class="lineNum">     752 </span>            :     static const base::type::char_t* kCurrentHostFormatSpecifier      =      ELPP_LITERAL(&quot;%host&quot;);
<span class="lineNum">     753 </span>            :     static const base::type::char_t* kMessageFormatSpecifier          =      ELPP_LITERAL(&quot;%msg&quot;);
<span class="lineNum">     754 </span>            :     static const base::type::char_t* kVerboseLevelFormatSpecifier     =      ELPP_LITERAL(&quot;%vlevel&quot;);
<span class="lineNum">     755 </span>            :     static const char* kDateTimeFormatSpecifierForFilename            =      &quot;%datetime&quot;;
<span class="lineNum">     756 </span>            :     // Date/time
<span class="lineNum">     757 </span>            :     static const char* kDays[7]                         =      { &quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot; };
<span class="lineNum">     758 </span>            :     static const char* kDaysAbbrev[7]                   =      { &quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot; };
<span class="lineNum">     759 </span>            :     static const char* kMonths[12]                      =      { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;Apri&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;,
<span class="lineNum">     760 </span>            :             &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; };
<span class="lineNum">     761 </span>            :     static const char* kMonthsAbbrev[12]                =      { &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; };
<span class="lineNum">     762 </span>            :     static const char* kDefaultDateTimeFormat           =      &quot;%Y-%M-%d %H:%m:%s,%g&quot;;
<span class="lineNum">     763 </span>            :     static const char* kDefaultDateTimeFormatInFilename =      &quot;%Y-%M-%d_%H-%m&quot;;
<span class="lineNum">     764 </span>            :     static const int kYearBase                          =      1900;
<span class="lineNum">     765 </span>            :     static const char* kAm                              =      &quot;AM&quot;;
<span class="lineNum">     766 </span>            :     static const char* kPm                              =      &quot;PM&quot;;
<span class="lineNum">     767 </span>            :     // Miscellaneous constants
<span class="lineNum">     768 </span>            :     static const char* kDefaultLoggerId                        =      &quot;default&quot;;
<span class="lineNum">     769 </span>            :     static const char* kPerformanceLoggerId                    =      &quot;performance&quot;;
<span class="lineNum">     770 </span>            :     static const char* kSysLogLoggerId                         =      &quot;syslog&quot;;
<span class="lineNum">     771 </span>            :     static const char* kNullPointer                            =      &quot;nullptr&quot;;
<span class="lineNum">     772 </span>            :     static const char  kFormatSpecifierChar                    =      '%';
<span class="lineNum">     773 </span>            : #if ELPP_VARIADIC_TEMPLATES_SUPPORTED
<span class="lineNum">     774 </span>            :     static const char  kFormatSpecifierCharValue               =      'v';
<span class="lineNum">     775 </span>            : #endif  // ELPP_VARIADIC_TEMPLATES_SUPPORTED
<span class="lineNum">     776 </span>            :     static const unsigned int kMaxLogPerContainer              =      100;
<span class="lineNum">     777 </span>            :     static const unsigned int kMaxLogPerCounter                =      100000;
<span class="lineNum">     778 </span>            :     static const unsigned int  kDefaultMillisecondsWidth       =      3;
<span class="lineNum">     779 </span>            :     static const base::type::VerboseLevel kMaxVerboseLevel     =      9;
<span class="lineNum">     780 </span>            :     static const char* kUnknownUser                            =      &quot;user&quot;;
<span class="lineNum">     781 </span>            :     static const char* kUnknownHost                            =      &quot;unknown-host&quot;;
<span class="lineNum">     782 </span>            : #if defined(ELPP_DEFAULT_LOG_FILE)
<span class="lineNum">     783 </span>            :     static const char* kDefaultLogFile                         =      ELPP_DEFAULT_LOG_FILE;
<span class="lineNum">     784 </span>            : #else
<span class="lineNum">     785 </span>            : #   if ELPP_OS_UNIX
<span class="lineNum">     786 </span>            : #      if ELPP_OS_ANDROID
<span class="lineNum">     787 </span>            :     static const char* kDefaultLogFile                         =      &quot;logs/myeasylog.log&quot;;
<span class="lineNum">     788 </span>            : #      else
<span class="lineNum">     789 </span>            :     static const char* kDefaultLogFile                         =      &quot;logs/myeasylog.log&quot;;
<span class="lineNum">     790 </span>            : #      endif  // ELPP_OS_ANDROID
<span class="lineNum">     791 </span>            : #   elif ELPP_OS_WINDOWS
<span class="lineNum">     792 </span>            :     static const char* kDefaultLogFile                         =      &quot;logs\\myeasylog.log&quot;;
<span class="lineNum">     793 </span>            : #   endif  // ELPP_OS_UNIX
<span class="lineNum">     794 </span>            : #endif  // defined(ELPP_DEFAULT_LOG_FILE)
<span class="lineNum">     795 </span>            : #if !defined(ELPP_DISABLE_LOG_FILE_FROM_ARG)
<span class="lineNum">     796 </span>            :     static const char* kDefaultLogFileParam                    =      &quot;--default-log-file&quot;;
<span class="lineNum">     797 </span>            : #endif  // !defined(ELPP_DISABLE_LOG_FILE_FROM_ARG)
<span class="lineNum">     798 </span>            : #if defined(ELPP_LOGGING_FLAGS_FROM_ARG)
<span class="lineNum">     799 </span>            :     static const char* kLoggingFlagsParam                      =      &quot;--logging-flags&quot;;
<span class="lineNum">     800 </span>            : #endif  // defined(ELPP_LOGGING_FLAGS_FROM_ARG)
<span class="lineNum">     801 </span>            : #if ELPP_OS_WINDOWS
<span class="lineNum">     802 </span>            :     static const char* kFilePathSeperator                      =      &quot;\\&quot;;
<span class="lineNum">     803 </span>            : #else
<span class="lineNum">     804 </span>            :     static const char* kFilePathSeperator                      =      &quot;/&quot;;
<span class="lineNum">     805 </span>            : #endif  // ELPP_OS_WINDOWS
<span class="lineNum">     806 </span>            :     static const char* kValidLoggerIdSymbols                   =      &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._&quot;;
<span class="lineNum">     807 </span>            :     static const char* kConfigurationComment                   =      &quot;##&quot;;
<span class="lineNum">     808 </span>            :     static const char* kConfigurationLevel                     =      &quot;*&quot;;
<span class="lineNum">     809 </span>            :     static const char* kConfigurationLoggerId                  =      &quot;--&quot;;
<span class="lineNum">     810 </span>            :     static const std::size_t kSourceFilenameMaxLength          =      100;
<span class="lineNum">     811 </span>            :     static const std::size_t kSourceLineMaxLength              =      10;
<span class="lineNum">     812 </span>            :     static const Level kPerformanceTrackerDefaultLevel         =      Level::Info;
<span class="lineNum">     813 </span>            :     const struct {
<span class="lineNum">     814 </span>            :         double value;
<span class="lineNum">     815 </span>            :         const base::type::char_t* unit;
<span class="lineNum">     816 </span>            :     } kTimeFormats[] = {
<span class="lineNum">     817 </span>            :        { 1000.0f, ELPP_LITERAL(&quot;mis&quot;) },
<span class="lineNum">     818 </span>            :        { 1000.0f, ELPP_LITERAL(&quot;ms&quot;) },
<span class="lineNum">     819 </span>            :        { 60.0f, ELPP_LITERAL(&quot;seconds&quot;) },
<span class="lineNum">     820 </span>            :        { 60.0f, ELPP_LITERAL(&quot;minutes&quot;) },
<span class="lineNum">     821 </span>            :        { 24.0f, ELPP_LITERAL(&quot;hours&quot;) },
<span class="lineNum">     822 </span>            :        { 7.0f, ELPP_LITERAL(&quot;days&quot;) }
<span class="lineNum">     823 </span>            :     };
<span class="lineNum">     824 </span>            :     static const int kTimeFormatsCount                           =      sizeof(kTimeFormats) / sizeof(kTimeFormats[0]);
<span class="lineNum">     825 </span>            :     const struct {
<span class="lineNum">     826 </span>            :         int numb;
<span class="lineNum">     827 </span>            :         const char* name;
<span class="lineNum">     828 </span>            :         const char* brief;
<span class="lineNum">     829 </span>            :         const char* detail;
<span class="lineNum">     830 </span>            :     } kCrashSignals[] = {
<span class="lineNum">     831 </span>            :         // NOTE: Do not re-order, if you do please check CrashHandler(bool) constructor and CrashHandler::setHandler(..)
<span class="lineNum">     832 </span>            :         { SIGABRT, &quot;SIGABRT&quot;, &quot;Abnormal termination&quot;,
<span class="lineNum">     833 </span>            :                 &quot;Program was abnormally terminated.&quot; },
<span class="lineNum">     834 </span>            :         { SIGFPE, &quot;SIGFPE&quot;, &quot;Erroneous arithmetic operation&quot;,
<span class="lineNum">     835 </span>            :                 &quot;Arithemetic operation issue such as division by zero or operation resulting in overflow.&quot; },
<span class="lineNum">     836 </span>            :         { SIGILL, &quot;SIGILL&quot;, &quot;Illegal instruction&quot;,
<span class="lineNum">     837 </span>            :                 &quot;Generally due to a corruption in the code or to an attempt to execute data.&quot;},
<span class="lineNum">     838 </span>            :         { SIGSEGV, &quot;SIGSEGV&quot;, &quot;Invalid access to memory&quot;,
<span class="lineNum">     839 </span>            :                 &quot;Program is trying to read an invalid (unallocated, deleted or corrupted) or inaccessible memory.&quot; },
<span class="lineNum">     840 </span>            :         { SIGINT, &quot;SIGINT&quot;, &quot;Interactive attention signal&quot;,
<span class="lineNum">     841 </span>            :                  &quot;Interruption generated (generally) by user or operating system.&quot; },
<span class="lineNum">     842 </span>            :     };
<span class="lineNum">     843 </span>            :     static const int kCrashSignalsCount                          =      sizeof(kCrashSignals) / sizeof(kCrashSignals[0]);
<span class="lineNum">     844 </span>            : }  // namespace consts
<span class="lineNum">     845 </span>            : }  // namespace base
<a name="846"><span class="lineNum">     846 </span>            : typedef std::function&lt;void(const char*, std::size_t)&gt; PreRollOutCallback;</a>
<span class="lineNum">     847 </span>            : namespace base {
<span class="lineNum">     848 </span><span class="lineNoCov">          0 : static inline void defaultPreRollOutCallback(const char*, std::size_t) {}</span>
<span class="lineNum">     849 </span>            : /// @brief Enum to represent timestamp unit
<span class="lineNum">     850 </span>            : enum class TimestampUnit : base::type::EnumType {
<span class="lineNum">     851 </span>            :     Microsecond = 0, Millisecond = 1, Second = 2, Minute = 3, Hour = 4, Day = 5
<span class="lineNum">     852 </span>            : };
<span class="lineNum">     853 </span>            : /// @brief Format flags used to determine specifiers that are active for performance improvements.
<span class="lineNum">     854 </span>            : enum class FormatFlags : base::type::EnumType {
<span class="lineNum">     855 </span>            :     DateTime = 1&lt;&lt;1, LoggerId = 1&lt;&lt;2, File = 1&lt;&lt;3, Line = 1&lt;&lt;4, Location = 1&lt;&lt;5, Function = 1&lt;&lt;6,
<span class="lineNum">     856 </span>            :     User = 1&lt;&lt;7, Host = 1&lt;&lt;8, LogMessage = 1&lt;&lt;9, VerboseLevel = 1&lt;&lt;10, AppName = 1&lt;&lt;11, ThreadId = 1&lt;&lt;12,
<span class="lineNum">     857 </span>            :     Level = 1&lt;&lt;13, FileBase = 1&lt;&lt;14, LevelShort = 1&lt;&lt;15
<span class="lineNum">     858 </span>            : };
<span class="lineNum">     859 </span>            : /// @brief A milliseconds width class containing actual width and offset for date/time
<span class="lineNum">     860 </span>            : class MillisecondsWidth {
<a name="861"><span class="lineNum">     861 </span>            : public:</a>
<a name="862"><span class="lineNum">     862 </span>            :     MillisecondsWidth(void) { init(base::consts::kDefaultMillisecondsWidth); }</a>
<span class="lineNum">     863 </span><span class="lineCov">        176 :     explicit MillisecondsWidth(int width) { init(width); }</span>
<span class="lineNum">     864 </span><span class="lineCov">         98 :     bool operator==(const MillisecondsWidth&amp; msWidth) { return m_width == msWidth.m_width &amp;&amp; m_offset == msWidth.m_offset; }</span>
<a name="865"><span class="lineNum">     865 </span>            :     int m_width; unsigned int m_offset;</a>
<span class="lineNum">     866 </span>            : private:
<span class="lineNum">     867 </span><span class="lineCov">        176 :     void init(int width) {</span>
<span class="lineNum">     868 </span><span class="lineCov">        176 :         if (width &lt; 1 || width &gt; 6) {</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :             width = base::consts::kDefaultMillisecondsWidth;</span>
<span class="lineNum">     870 </span>            :         }
<span class="lineNum">     871 </span><span class="lineCov">        176 :         m_width = width;</span>
<span class="lineNum">     872 </span><span class="lineCov">        176 :         switch (m_width) {</span>
<span class="lineNum">     873 </span><span class="lineCov">        176 :         case 3: m_offset = 1000; break;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         case 4: m_offset = 100; break;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         case 5: m_offset = 10; break;</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :         case 6: m_offset = 1; break;</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :         default: m_offset = 1000; break;</span>
<span class="lineNum">     878 </span>            :         }
<span class="lineNum">     879 </span><span class="lineCov">        176 :     }</span>
<span class="lineNum">     880 </span>            : };
<span class="lineNum">     881 </span>            : /// @brief Namespace containing utility functions/static classes used internally
<span class="lineNum">     882 </span>            : namespace utils {
<span class="lineNum">     883 </span>            : /// @brief Deletes memory safely and points to null
<span class="lineNum">     884 </span>            : template &lt;typename T&gt;
<a name="885"><span class="lineNum">     885 </span>            : static inline</a>
<span class="lineNum">     886 </span>            : typename std::enable_if&lt;std::is_pointer&lt;T*&gt;::value, void&gt;::type
<span class="lineNum">     887 </span><span class="lineCov">        270 : safeDelete(T*&amp; pointer) {</span>
<span class="lineNum">     888 </span><span class="lineCov">        270 :     if (pointer == nullptr)</span>
<span class="lineNum">     889 </span><span class="lineCov">        274 :         return;</span>
<span class="lineNum">     890 </span><span class="lineCov">        266 :     delete pointer;</span>
<span class="lineNum">     891 </span><span class="lineCov">        266 :     pointer = nullptr;</span>
<span class="lineNum">     892 </span>            : }
<span class="lineNum">     893 </span>            : /// @brief Gets value of const char* but if it is nullptr, a string nullptr is returned
<span class="lineNum">     894 </span>            : static inline const char* charPtrVal(const char* pointer) {
<span class="lineNum">     895 </span>            :     return pointer == nullptr ? base::consts::kNullPointer : pointer;
<a name="896"><span class="lineNum">     896 </span>            : }</a>
<span class="lineNum">     897 </span>            : /// @brief Aborts application due with user-defined status
<span class="lineNum">     898 </span><span class="lineNoCov">          0 : static inline void abort(int status, const std::string&amp; reason = std::string()) {</span>
<span class="lineNum">     899 </span>            :     // Both status and reason params are there for debugging with tools like gdb etc
<span class="lineNum">     900 </span>            :     ELPP_UNUSED(status);
<span class="lineNum">     901 </span>            :     ELPP_UNUSED(reason);
<span class="lineNum">     902 </span>            : #if defined(ELPP_COMPILER_MSVC) &amp;&amp; defined(_M_IX86) &amp;&amp; defined(_DEBUG)
<span class="lineNum">     903 </span>            :    // Ignore msvc critical error dialog - break instead (on debug mode)
<span class="lineNum">     904 </span>            :     _asm int 3
<span class="lineNum">     905 </span>            : #else
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     ::abort();</span>
<span class="lineNum">     907 </span>            : #endif  // defined(ELPP_COMPILER_MSVC) &amp;&amp; defined(_M_IX86) &amp;&amp; defined(_DEBUG)
<span class="lineNum">     908 </span>            : }
<span class="lineNum">     909 </span>            : /// @brief Bitwise operations for C++11 strong enum class. This casts e into Flag_T and returns value after bitwise operation
<span class="lineNum">     910 </span>            : /// Use these function as &lt;pre&gt;flag = bitwise::Or&lt;MyEnum&gt;(MyEnum::val1, flag);&lt;/pre&gt;
<a name="911"><span class="lineNum">     911 </span>            : namespace bitwise {</a>
<span class="lineNum">     912 </span>            : template &lt;typename Enum&gt;
<span class="lineNum">     913 </span><span class="lineCov">      24637 : static inline base::type::EnumType And(Enum e, base::type::EnumType flag) {</span>
<span class="lineNum">     914 </span><span class="lineCov">      24637 :     return static_cast&lt;base::type::EnumType&gt;(flag) &amp; static_cast&lt;base::type::EnumType&gt;(e);</span>
<span class="lineNum">     915 </span>            : }
<span class="lineNum">     916 </span>            : template &lt;typename Enum&gt;
<span class="lineNum">     917 </span>            : static inline base::type::EnumType Not(Enum e, base::type::EnumType flag) {
<span class="lineNum">     918 </span>            :     return static_cast&lt;base::type::EnumType&gt;(flag) &amp; ~(static_cast&lt;base::type::EnumType&gt;(e));
<a name="919"><span class="lineNum">     919 </span>            : }</a>
<span class="lineNum">     920 </span>            : template &lt;typename Enum&gt;
<span class="lineNum">     921 </span><span class="lineCov">        516 : static inline base::type::EnumType Or(Enum e, base::type::EnumType flag) {</span>
<span class="lineNum">     922 </span><span class="lineCov">        516 :     return static_cast&lt;base::type::EnumType&gt;(flag) | static_cast&lt;base::type::EnumType&gt;(e);</span>
<span class="lineNum">     923 </span>            : }
<a name="924"><span class="lineNum">     924 </span>            : }  // namespace bitwise</a>
<span class="lineNum">     925 </span>            : template &lt;typename Enum&gt;
<span class="lineNum">     926 </span><span class="lineCov">        516 : static inline void addFlag(Enum e, base::type::EnumType* flag) {</span>
<span class="lineNum">     927 </span><span class="lineCov">        516 :     *flag = base::utils::bitwise::Or&lt;Enum&gt;(e, *flag);</span>
<span class="lineNum">     928 </span><span class="lineCov">        516 : }</span>
<span class="lineNum">     929 </span>            : template &lt;typename Enum&gt;
<span class="lineNum">     930 </span>            : static inline void removeFlag(Enum e, base::type::EnumType* flag) {
<span class="lineNum">     931 </span>            :     *flag = base::utils::bitwise::Not&lt;Enum&gt;(e, *flag);
<a name="932"><span class="lineNum">     932 </span>            : }</a>
<span class="lineNum">     933 </span>            : template &lt;typename Enum&gt;
<span class="lineNum">     934 </span><span class="lineCov">      24637 : static inline bool hasFlag(Enum e, base::type::EnumType flag) {</span>
<span class="lineNum">     935 </span><span class="lineCov">      24637 :     return base::utils::bitwise::And&lt;Enum&gt;(e, flag) &gt; 0x0;</span>
<span class="lineNum">     936 </span>            : }
<span class="lineNum">     937 </span>            : }  // namespace utils
<span class="lineNum">     938 </span>            : namespace threading {
<span class="lineNum">     939 </span>            : #if ELPP_THREADING_ENABLED
<span class="lineNum">     940 </span>            : #   if !ELPP_USE_STD_THREADING
<span class="lineNum">     941 </span>            : namespace internal {
<span class="lineNum">     942 </span>            : /// @brief A mutex wrapper for compiler that dont yet support std::mutex
<span class="lineNum">     943 </span>            : class Mutex : base::NoCopy {
<span class="lineNum">     944 </span>            : public:
<span class="lineNum">     945 </span>            :     Mutex(void) {
<span class="lineNum">     946 </span>            : #   if ELPP_OS_UNIX
<span class="lineNum">     947 </span>            :         pthread_mutex_init(&amp;m_underlyingMutex, nullptr);
<span class="lineNum">     948 </span>            : #   elif ELPP_OS_WINDOWS
<span class="lineNum">     949 </span>            :         InitializeCriticalSection(&amp;m_underlyingMutex);
<span class="lineNum">     950 </span>            : #   endif  // ELPP_OS_UNIX
<span class="lineNum">     951 </span>            :     }
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            :     virtual ~Mutex(void) {
<span class="lineNum">     954 </span>            : #   if ELPP_OS_UNIX
<span class="lineNum">     955 </span>            :         pthread_mutex_destroy(&amp;m_underlyingMutex);
<span class="lineNum">     956 </span>            : #   elif ELPP_OS_WINDOWS
<span class="lineNum">     957 </span>            :         DeleteCriticalSection(&amp;m_underlyingMutex);
<span class="lineNum">     958 </span>            : #   endif  // ELPP_OS_UNIX
<span class="lineNum">     959 </span>            :     }
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            :     inline void lock(void) {
<span class="lineNum">     962 </span>            : #   if ELPP_OS_UNIX
<span class="lineNum">     963 </span>            :         pthread_mutex_lock(&amp;m_underlyingMutex);
<span class="lineNum">     964 </span>            : #   elif ELPP_OS_WINDOWS
<span class="lineNum">     965 </span>            :         EnterCriticalSection(&amp;m_underlyingMutex);
<span class="lineNum">     966 </span>            : #   endif  // ELPP_OS_UNIX
<span class="lineNum">     967 </span>            :     }
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :     inline bool try_lock(void) {
<span class="lineNum">     970 </span>            : #   if ELPP_OS_UNIX
<span class="lineNum">     971 </span>            :         return (pthread_mutex_trylock(&amp;m_underlyingMutex) == 0);
<span class="lineNum">     972 </span>            : #   elif ELPP_OS_WINDOWS
<span class="lineNum">     973 </span>            :         return TryEnterCriticalSection(&amp;m_underlyingMutex);
<span class="lineNum">     974 </span>            : #   endif  // ELPP_OS_UNIX
<span class="lineNum">     975 </span>            :     }
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :     inline void unlock(void) {
<span class="lineNum">     978 </span>            : #   if ELPP_OS_UNIX
<span class="lineNum">     979 </span>            :         pthread_mutex_unlock(&amp;m_underlyingMutex);
<span class="lineNum">     980 </span>            : #   elif ELPP_OS_WINDOWS
<span class="lineNum">     981 </span>            :         LeaveCriticalSection(&amp;m_underlyingMutex);
<span class="lineNum">     982 </span>            : #   endif  // ELPP_OS_UNIX
<span class="lineNum">     983 </span>            :     }
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            : private:
<span class="lineNum">     986 </span>            : #   if ELPP_OS_UNIX
<span class="lineNum">     987 </span>            :     pthread_mutex_t m_underlyingMutex;
<span class="lineNum">     988 </span>            : #   elif ELPP_OS_WINDOWS
<span class="lineNum">     989 </span>            :     CRITICAL_SECTION m_underlyingMutex;
<span class="lineNum">     990 </span>            : #   endif  // ELPP_OS_UNIX
<span class="lineNum">     991 </span>            : };
<span class="lineNum">     992 </span>            : /// @brief Scoped lock for compiler that dont yet support std::lock_guard
<span class="lineNum">     993 </span>            : template &lt;typename M&gt;
<span class="lineNum">     994 </span>            : class ScopedLock : base::NoCopy {
<span class="lineNum">     995 </span>            : public:
<span class="lineNum">     996 </span>            :     explicit ScopedLock(M&amp; mutex) {
<span class="lineNum">     997 </span>            :         m_mutex = &amp;mutex;
<span class="lineNum">     998 </span>            :         m_mutex-&gt;lock();
<span class="lineNum">     999 </span>            :     }
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            :     virtual ~ScopedLock(void) {
<span class="lineNum">    1002 </span>            :         m_mutex-&gt;unlock();
<span class="lineNum">    1003 </span>            :     }
<span class="lineNum">    1004 </span>            : private:
<span class="lineNum">    1005 </span>            :     M* m_mutex;
<span class="lineNum">    1006 </span>            :     ScopedLock(void);
<span class="lineNum">    1007 </span>            : };
<span class="lineNum">    1008 </span>            : } // namespace internal
<span class="lineNum">    1009 </span>            : /// @brief Gets ID of currently running threading in windows systems. On unix, nothing is returned.
<span class="lineNum">    1010 </span>            : static inline std::string getCurrentThreadId(void) {
<span class="lineNum">    1011 </span>            :     std::stringstream ss;
<span class="lineNum">    1012 </span>            : #      if (ELPP_OS_WINDOWS)
<span class="lineNum">    1013 </span>            :     ss &lt;&lt; GetCurrentThreadId();
<span class="lineNum">    1014 </span>            : #      endif  // (ELPP_OS_WINDOWS)
<span class="lineNum">    1015 </span>            :     return ss.str();
<span class="lineNum">    1016 </span>            : }
<span class="lineNum">    1017 </span>            : static inline void msleep(int) {
<span class="lineNum">    1018 </span>            :     // No implementation for non std::thread version
<span class="lineNum">    1019 </span>            : }
<span class="lineNum">    1020 </span>            : typedef base::threading::internal::Mutex Mutex;
<span class="lineNum">    1021 </span>            : typedef base::threading::internal::ScopedLock&lt;base::threading::Mutex&gt; ScopedLock;
<span class="lineNum">    1022 </span>            : #   else
<span class="lineNum">    1023 </span>            : /// @brief Gets ID of currently running threading using std::this_thread::get_id()
<span class="lineNum">    1024 </span>            : static inline std::string getCurrentThreadId(void) {
<span class="lineNum">    1025 </span>            :     std::stringstream ss;
<span class="lineNum">    1026 </span>            :     ss &lt;&lt; std::this_thread::get_id();
<span class="lineNum">    1027 </span>            :     return ss.str();
<span class="lineNum">    1028 </span>            : }
<span class="lineNum">    1029 </span>            : static inline void msleep(int ms) {
<span class="lineNum">    1030 </span>            :     // Only when async logging enabled - this is because async is strict on compiler
<span class="lineNum">    1031 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    1032 </span>            :     std::this_thread::sleep_for(std::chrono::milliseconds(ms));
<span class="lineNum">    1033 </span>            : #endif  // ELPP_ASYNC_LOGGING
<span class="lineNum">    1034 </span>            : }
<span class="lineNum">    1035 </span>            : typedef std::mutex Mutex;
<span class="lineNum">    1036 </span>            : typedef std::lock_guard&lt;std::mutex&gt; ScopedLock;
<span class="lineNum">    1037 </span>            : #   endif  // !ELPP_USE_STD_THREADING
<span class="lineNum">    1038 </span>            : #else
<span class="lineNum">    1039 </span>            : namespace internal {
<span class="lineNum">    1040 </span>            : /// @brief Mutex wrapper used when multi-threading is disabled.
<a name="1041"><span class="lineNum">    1041 </span>            : class NoMutex : base::NoCopy {</a>
<a name="1042"><span class="lineNum">    1042 </span>            : public:</a>
<span class="lineNum">    1043 </span><span class="lineCov">         40 :     NoMutex(void) {}</span>
<a name="1044"><span class="lineNum">    1044 </span><span class="lineCov">       2488 :     inline void lock(void) {}</span></a>
<span class="lineNum">    1045 </span>            :     inline bool try_lock(void) { return true; }
<span class="lineNum">    1046 </span><span class="lineCov">       2488 :     inline void unlock(void) {}</span>
<span class="lineNum">    1047 </span>            : };
<span class="lineNum">    1048 </span>            : /// @brief Lock guard wrapper used when multi-threading is disabled.
<span class="lineNum">    1049 </span>            : template &lt;typename Mutex&gt;
<a name="1050"><span class="lineNum">    1050 </span>            : class NoScopedLock : base::NoCopy {</a>
<span class="lineNum">    1051 </span>            : public:
<a name="1052"><span class="lineNum">    1052 </span><span class="lineCov">      12510 :     explicit NoScopedLock(Mutex&amp;) {</span></a>
<span class="lineNum">    1053 </span><span class="lineCov">      12510 :     }</span>
<span class="lineNum">    1054 </span><span class="lineCov">      12510 :     virtual ~NoScopedLock(void) {</span>
<span class="lineNum">    1055 </span><span class="lineCov">      12510 :     }</span>
<span class="lineNum">    1056 </span>            : private:
<span class="lineNum">    1057 </span>            :     NoScopedLock(void);
<a name="1058"><span class="lineNum">    1058 </span>            : };</a>
<span class="lineNum">    1059 </span>            : }  // namespace internal
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 : static inline std::string getCurrentThreadId(void) {</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     return std::string();</span>
<span class="lineNum">    1062 </span>            : }
<span class="lineNum">    1063 </span>            : static inline void msleep(int) {
<span class="lineNum">    1064 </span>            :     // No custom implementation
<span class="lineNum">    1065 </span>            : }
<span class="lineNum">    1066 </span>            : typedef base::threading::internal::NoMutex Mutex;
<span class="lineNum">    1067 </span>            : typedef base::threading::internal::NoScopedLock&lt;base::threading::Mutex&gt; ScopedLock;
<span class="lineNum">    1068 </span>            : #endif  // ELPP_THREADING_ENABLED
<span class="lineNum">    1069 </span>            : /// @brief Base of thread safe class, this class is inheritable-only
<a name="1070"><span class="lineNum">    1070 </span>            : class ThreadSafe {</a>
<a name="1071"><span class="lineNum">    1071 </span>            : public:</a>
<a name="1072"><span class="lineNum">    1072 </span><span class="lineCov">       2488 :     virtual inline void acquireLock(void) ELPP_FINAL { m_mutex.lock(); }</span></a>
<span class="lineNum">    1073 </span><span class="lineCov">       2488 :     virtual inline void releaseLock(void) ELPP_FINAL { m_mutex.unlock(); }</span>
<a name="1074"><span class="lineNum">    1074 </span><span class="lineCov">      12510 :     virtual inline base::threading::Mutex&amp; lock(void) ELPP_FINAL { return m_mutex; }</span></a>
<a name="1075"><span class="lineNum">    1075 </span>            : protected:</a>
<span class="lineNum">    1076 </span><span class="lineCov">         40 :     ThreadSafe(void) {}</span>
<span class="lineNum">    1077 </span><span class="lineCov">         14 :     virtual ~ThreadSafe(void) {}</span>
<span class="lineNum">    1078 </span>            : private:
<span class="lineNum">    1079 </span>            :     base::threading::Mutex m_mutex;
<span class="lineNum">    1080 </span>            : };
<span class="lineNum">    1081 </span>            : }  // namespace threading
<span class="lineNum">    1082 </span>            : namespace utils {
<span class="lineNum">    1083 </span>            : class File : base::StaticClass {
<span class="lineNum">    1084 </span>            : public:
<a name="1085"><span class="lineNum">    1085 </span>            :     /// @brief Creates new out file stream for specified filename.</a>
<span class="lineNum">    1086 </span>            :     /// @return Pointer to newly created fstream or nullptr
<span class="lineNum">    1087 </span><span class="lineCov">          4 :     static base::type::fstream_t* newFileStream(const std::string&amp; filename) {</span>
<span class="lineNum">    1088 </span>            :         base::type::fstream_t *fs = new base::type::fstream_t(filename.c_str(), 
<span class="lineNum">    1089 </span><span class="lineCov">          4 :             base::type::fstream_t::out | base::type::fstream_t::app);</span>
<span class="lineNum">    1090 </span>            : #if defined(ELPP_UNICODE)
<span class="lineNum">    1091 </span>            :         std::locale elppUnicodeLocale(&quot;&quot;);
<span class="lineNum">    1092 </span>            : #if ELPP_OS_WINDOWS
<span class="lineNum">    1093 </span>            :         std::locale elppUnicodeLocaleWindows(elppUnicodeLocale, new std::codecvt_utf8_utf16&lt;wchar_t&gt;);
<span class="lineNum">    1094 </span>            :         elppUnicodeLocale = elppUnicodeLocaleWindows;
<span class="lineNum">    1095 </span>            : #endif
<span class="lineNum">    1096 </span>            :         fs-&gt;imbue(elppUnicodeLocale);
<span class="lineNum">    1097 </span>            : #endif  // defined(ELPP_UNICODE)
<span class="lineNum">    1098 </span><span class="lineCov">          4 :         if (fs-&gt;is_open()) {</span>
<span class="lineNum">    1099 </span><span class="lineCov">          4 :             fs-&gt;flush();</span>
<span class="lineNum">    1100 </span>            :         } else {
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :             base::utils::safeDelete(fs);</span>
<span class="lineNum">    1102 </span>            :             ELPP_INTERNAL_ERROR(&quot;Bad file [&quot; &lt;&lt; filename &lt;&lt; &quot;]&quot;, true);
<span class="lineNum">    1103 </span>            :         }
<span class="lineNum">    1104 </span><span class="lineCov">          4 :         return fs;</span>
<span class="lineNum">    1105 </span>            :     }
<a name="1106"><span class="lineNum">    1106 </span>            : </a>
<span class="lineNum">    1107 </span>            :     /// @brief Gets size of file provided in stream
<span class="lineNum">    1108 </span><span class="lineCov">        112 :     static std::size_t getSizeOfFile(base::type::fstream_t* fs) {</span>
<span class="lineNum">    1109 </span><span class="lineCov">        112 :         if (fs == nullptr) {</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    1111 </span>            :         }
<span class="lineNum">    1112 </span><span class="lineCov">        112 :         std::streampos currPos = fs-&gt;tellg();</span>
<span class="lineNum">    1113 </span><span class="lineCov">        112 :         fs-&gt;seekg(0, fs-&gt;end);</span>
<span class="lineNum">    1114 </span><span class="lineCov">        112 :         std::size_t size = static_cast&lt;std::size_t&gt;(fs-&gt;tellg());</span>
<span class="lineNum">    1115 </span><span class="lineCov">        112 :         fs-&gt;seekg(currPos);</span>
<span class="lineNum">    1116 </span><span class="lineCov">        112 :         return size;</span>
<span class="lineNum">    1117 </span>            :     }
<a name="1118"><span class="lineNum">    1118 </span>            : </a>
<span class="lineNum">    1119 </span>            :     /// @brief Determines whether or not provided path exist in current file system
<span class="lineNum">    1120 </span><span class="lineCov">        116 :     static inline bool pathExists(const char* path, bool considerFile = false) {</span>
<span class="lineNum">    1121 </span><span class="lineCov">        116 :         if (path == nullptr) {</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1123 </span>            :         }
<span class="lineNum">    1124 </span>            : #if ELPP_OS_UNIX
<span class="lineNum">    1125 </span>            :         ELPP_UNUSED(considerFile);
<span class="lineNum">    1126 </span>            :         struct stat st;
<span class="lineNum">    1127 </span><span class="lineCov">        116 :         return (stat(path, &amp;st) == 0);</span>
<span class="lineNum">    1128 </span>            : #elif ELPP_OS_WINDOWS
<span class="lineNum">    1129 </span>            :         DWORD fileType = GetFileAttributesA(path);
<span class="lineNum">    1130 </span>            :         if (fileType == INVALID_FILE_ATTRIBUTES) {
<span class="lineNum">    1131 </span>            :             return false;
<span class="lineNum">    1132 </span>            :         }
<span class="lineNum">    1133 </span>            :         return considerFile ? true : ((fileType &amp; FILE_ATTRIBUTE_DIRECTORY) == 0 ? false : true);
<span class="lineNum">    1134 </span>            : #endif  // ELPP_OS_UNIX
<span class="lineNum">    1135 </span>            :     }
<span class="lineNum">    1136 </span>            : 
<a name="1137"><span class="lineNum">    1137 </span>            :     /// @brief Creates specified path on file system</a>
<span class="lineNum">    1138 </span>            :     /// @param path Path to create.
<span class="lineNum">    1139 </span><span class="lineCov">        112 :     static bool createPath(const std::string&amp; path) {</span>
<span class="lineNum">    1140 </span><span class="lineCov">        112 :         if (path.empty()) {</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1142 </span>            :         }
<span class="lineNum">    1143 </span><span class="lineCov">        112 :         if (base::utils::File::pathExists(path.c_str())) {</span>
<span class="lineNum">    1144 </span><span class="lineCov">        112 :             return true;</span>
<span class="lineNum">    1145 </span>            :         }
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :         int status = -1;</span>
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :         char* currPath = const_cast&lt;char*&gt;(path.c_str());</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :         std::string builtPath = std::string();</span>
<span class="lineNum">    1150 </span>            : #if ELPP_OS_UNIX
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :         if (path[0] == '/') {</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :             builtPath = &quot;/&quot;;</span>
<span class="lineNum">    1153 </span>            :         }
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :         currPath = STRTOK(currPath, base::consts::kFilePathSeperator, 0);</span>
<span class="lineNum">    1155 </span>            : #elif ELPP_OS_WINDOWS
<span class="lineNum">    1156 </span>            :         // Use secure functions API
<span class="lineNum">    1157 </span>            :         char* nextTok_ = nullptr;
<span class="lineNum">    1158 </span>            :         currPath = STRTOK(currPath, base::consts::kFilePathSeperator, &amp;nextTok_);
<span class="lineNum">    1159 </span>            :         ELPP_UNUSED(nextTok_);
<span class="lineNum">    1160 </span>            : #endif  // ELPP_OS_UNIX
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :         while (currPath != nullptr) {</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :             builtPath.append(currPath);</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :             builtPath.append(base::consts::kFilePathSeperator);</span>
<span class="lineNum">    1164 </span>            : #if ELPP_OS_UNIX
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :             status = mkdir(builtPath.c_str(), ELPP_LOG_PERMS);</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :             currPath = STRTOK(nullptr, base::consts::kFilePathSeperator, 0);</span>
<span class="lineNum">    1167 </span>            : #elif ELPP_OS_WINDOWS
<span class="lineNum">    1168 </span>            :             status = _mkdir(builtPath.c_str());
<span class="lineNum">    1169 </span>            :             currPath = STRTOK(nullptr, base::consts::kFilePathSeperator, &amp;nextTok_);
<span class="lineNum">    1170 </span>            : #endif  // ELPP_OS_UNIX
<span class="lineNum">    1171 </span>            :         }
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :         if (status == -1) {</span>
<span class="lineNum">    1173 </span>            :             ELPP_INTERNAL_ERROR(&quot;Error while creating path [&quot; &lt;&lt; path &lt;&lt; &quot;]&quot;, true);
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1175 </span>            :         }
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :         return true;</span>
<a name="1177"><span class="lineNum">    1177 </span>            :     }</a>
<span class="lineNum">    1178 </span>            :     /// @brief Extracts path of filename with leading slash
<span class="lineNum">    1179 </span><span class="lineCov">        112 :     static std::string extractPathFromFilename(const std::string&amp; fullPath,</span>
<span class="lineNum">    1180 </span>            :             const char* seperator = base::consts::kFilePathSeperator) {
<span class="lineNum">    1181 </span><span class="lineCov">        112 :         if ((fullPath == &quot;&quot;) || (fullPath.find(seperator) == std::string::npos)) {</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :             return fullPath;</span>
<span class="lineNum">    1183 </span>            :         }
<span class="lineNum">    1184 </span><span class="lineCov">        112 :         std::size_t lastSlashAt = fullPath.find_last_of(seperator);</span>
<span class="lineNum">    1185 </span><span class="lineCov">        112 :         if (lastSlashAt == 0) {</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :             return std::string(seperator);</span>
<span class="lineNum">    1187 </span>            :         }
<span class="lineNum">    1188 </span><span class="lineCov">        112 :         return fullPath.substr(0, lastSlashAt + 1);</span>
<a name="1189"><span class="lineNum">    1189 </span>            :     }</a>
<span class="lineNum">    1190 </span>            :     /// @brief builds stripped filename and puts it in buff
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :     static void buildStrippedFilename(const char* filename, char buff[], </span>
<span class="lineNum">    1192 </span>            :             std::size_t limit = base::consts::kSourceFilenameMaxLength) {
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :         std::size_t sizeOfFilename = strlen(filename);</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         if (sizeOfFilename &gt;= limit) {</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :             filename += (sizeOfFilename - limit);</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :             if (filename[0] != '.' &amp;&amp; filename[1] != '.') {  // prepend if not already</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :                 filename += 3;  // 3 = '..'</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :                 STRCAT(buff, &quot;..&quot;, limit);</span>
<span class="lineNum">    1199 </span>            :             }
<span class="lineNum">    1200 </span>            :         }
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :         STRCAT(buff, filename, limit);</span>
<a name="1202"><span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    1203 </span>            :     /// @brief builds base filename and puts it in buff
<span class="lineNum">    1204 </span><span class="lineCov">       1049 :     static void buildBaseFilename(const std::string&amp; fullPath, char buff[], </span>
<span class="lineNum">    1205 </span>            :             std::size_t limit = base::consts::kSourceFilenameMaxLength,
<span class="lineNum">    1206 </span>            :             const char* seperator = base::consts::kFilePathSeperator) {
<span class="lineNum">    1207 </span><span class="lineCov">       1049 :         const char *filename = fullPath.c_str();</span>
<span class="lineNum">    1208 </span><span class="lineCov">       1049 :         std::size_t lastSlashAt = fullPath.find_last_of(seperator);</span>
<span class="lineNum">    1209 </span><span class="lineCov">       1049 :         filename += lastSlashAt ? lastSlashAt+1 : 0;</span>
<span class="lineNum">    1210 </span><span class="lineCov">       1049 :         std::size_t sizeOfFilename = strlen(filename);</span>
<span class="lineNum">    1211 </span><span class="lineCov">       1049 :         if (sizeOfFilename &gt;= limit) {</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :             filename += (sizeOfFilename - limit);</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :             if (filename[0] != '.' &amp;&amp; filename[1] != '.') {  // prepend if not already</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                 filename += 3;  // 3 = '..'</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :                 STRCAT(buff, &quot;..&quot;, limit);</span>
<span class="lineNum">    1216 </span>            :             }
<span class="lineNum">    1217 </span>            :         }
<span class="lineNum">    1218 </span><span class="lineCov">       1049 :         STRCAT(buff, filename, limit);</span>
<span class="lineNum">    1219 </span><span class="lineCov">       1049 :     }</span>
<span class="lineNum">    1220 </span>            : };
<span class="lineNum">    1221 </span>            : /// @brief String utilities helper class used internally. You should not use it.
<span class="lineNum">    1222 </span>            : class Str : base::StaticClass {
<a name="1223"><span class="lineNum">    1223 </span>            : public:</a>
<span class="lineNum">    1224 </span>            :     /// @brief Checks if character is digit. Dont use libc implementation of it to prevent locale issues.
<span class="lineNum">    1225 </span><span class="lineCov">        336 :     static inline bool isDigit(char c) {</span>
<span class="lineNum">    1226 </span><span class="lineCov">        336 :         return c &gt;= '0' &amp;&amp; c &lt;= '9';</span>
<span class="lineNum">    1227 </span>            :     }
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            :     /// @brief Matches wildcards, '*' and '?' only supported.
<span class="lineNum">    1230 </span>            :     static bool wildCardMatch(const char* str, const char* pattern) {
<span class="lineNum">    1231 </span>            :         while (*pattern) {
<span class="lineNum">    1232 </span>            :             switch (*pattern) {
<span class="lineNum">    1233 </span>            :             case '?':
<span class="lineNum">    1234 </span>            :                 if (!*str)
<span class="lineNum">    1235 </span>            :                     return false;
<span class="lineNum">    1236 </span>            :                 ++str;
<span class="lineNum">    1237 </span>            :                 ++pattern;
<span class="lineNum">    1238 </span>            :                 break;
<span class="lineNum">    1239 </span>            :             case '*':
<span class="lineNum">    1240 </span>            :                 if (wildCardMatch(str, pattern + 1))
<span class="lineNum">    1241 </span>            :                     return true;
<span class="lineNum">    1242 </span>            :                 if (*str &amp;&amp; wildCardMatch(str + 1, pattern))
<span class="lineNum">    1243 </span>            :                     return true;
<span class="lineNum">    1244 </span>            :                 return false;
<span class="lineNum">    1245 </span>            :                 break;
<span class="lineNum">    1246 </span>            :             default:
<span class="lineNum">    1247 </span>            :                 if (*str++ != *pattern++)
<span class="lineNum">    1248 </span>            :                     return false;
<span class="lineNum">    1249 </span>            :                 break;
<span class="lineNum">    1250 </span>            :             }
<span class="lineNum">    1251 </span>            :         }
<span class="lineNum">    1252 </span>            :         return !*str &amp;&amp; !*pattern;
<span class="lineNum">    1253 </span>            :     }
<span class="lineNum">    1254 </span>            : 
<a name="1255"><span class="lineNum">    1255 </span>            :     /// @brief Trims string from start</a>
<span class="lineNum">    1256 </span>            :     /// @param [in,out] str String to trim
<span class="lineNum">    1257 </span><span class="lineCov">       1024 :     static inline std::string&amp; ltrim(std::string&amp; str) {</span>
<span class="lineNum">    1258 </span><span class="lineCov">       1024 :         str.erase(str.begin(), std::find_if(str.begin(), str.end(), std::not1(std::ptr_fun&lt;int, int&gt;(&amp;std::isspace))));</span>
<span class="lineNum">    1259 </span><span class="lineCov">       1024 :         return str;</span>
<span class="lineNum">    1260 </span>            :     }
<span class="lineNum">    1261 </span>            : 
<a name="1262"><span class="lineNum">    1262 </span>            :     /// @brief Trim string from end</a>
<span class="lineNum">    1263 </span>            :     /// @param [in,out] str String to trim
<span class="lineNum">    1264 </span><span class="lineCov">       1024 :     static inline std::string&amp; rtrim(std::string&amp; str) {</span>
<span class="lineNum">    1265 </span><span class="lineCov">       1024 :         str.erase(std::find_if(str.rbegin(), str.rend(), std::not1(std::ptr_fun&lt;int, int&gt;(&amp;std::isspace))).base(), str.end());</span>
<span class="lineNum">    1266 </span><span class="lineCov">       1024 :         return str;</span>
<span class="lineNum">    1267 </span>            :     }
<span class="lineNum">    1268 </span>            : 
<a name="1269"><span class="lineNum">    1269 </span>            :     /// @brief Trims string from left and right</a>
<span class="lineNum">    1270 </span>            :     /// @param [in,out] str String to trim
<span class="lineNum">    1271 </span><span class="lineCov">       1024 :     static inline std::string&amp; trim(std::string&amp; str) {</span>
<span class="lineNum">    1272 </span><span class="lineCov">       1024 :         return ltrim(rtrim(str));</span>
<span class="lineNum">    1273 </span>            :     }
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            :     /// @brief Determines whether or not str starts with specified string
<span class="lineNum">    1276 </span>            :     /// @param str String to check
<a name="1277"><span class="lineNum">    1277 </span>            :     /// @param start String to check against</a>
<span class="lineNum">    1278 </span>            :     /// @return Returns true if starts with specified string, false otherwise
<span class="lineNum">    1279 </span><span class="lineCov">        396 :     static inline bool startsWith(const std::string&amp; str, const std::string&amp; start) {</span>
<span class="lineNum">    1280 </span><span class="lineCov">        396 :         return (str.length() &gt;= start.length()) &amp;&amp; (str.compare(0, start.length(), start) == 0);</span>
<span class="lineNum">    1281 </span>            :     }
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :     /// @brief Determines whether or not str ends with specified string
<span class="lineNum">    1284 </span>            :     /// @param str String to check
<span class="lineNum">    1285 </span>            :     /// @param end String to check against
<span class="lineNum">    1286 </span>            :     /// @return Returns true if ends with specified string, false otherwise
<span class="lineNum">    1287 </span>            :     static inline bool endsWith(const std::string&amp; str, const std::string&amp; end) {
<span class="lineNum">    1288 </span>            :         return (str.length() &gt;= end.length()) &amp;&amp; (str.compare(str.length() - end.length(), end.length(), end) == 0);
<span class="lineNum">    1289 </span>            :     }
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span>            :     /// @brief Replaces all instances of replaceWhat with 'replaceWith'. Original variable is changed for performance.
<span class="lineNum">    1292 </span>            :     /// @param [in,out] str String to replace from
<span class="lineNum">    1293 </span>            :     /// @param replaceWhat Character to replace
<a name="1294"><span class="lineNum">    1294 </span>            :     /// @param replaceWith Character to replace with</a>
<span class="lineNum">    1295 </span>            :     /// @return Modified version of str
<span class="lineNum">    1296 </span><span class="lineCov">         64 :     static inline std::string&amp; replaceAll(std::string&amp; str, char replaceWhat, char replaceWith) {</span>
<span class="lineNum">    1297 </span><span class="lineCov">         64 :         std::replace(str.begin(), str.end(), replaceWhat, replaceWith);</span>
<span class="lineNum">    1298 </span><span class="lineCov">         64 :         return str;</span>
<span class="lineNum">    1299 </span>            :     }
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            :     /// @brief Replaces all instances of 'replaceWhat' with 'replaceWith'. (String version) Replaces in place
<span class="lineNum">    1302 </span>            :     /// @param str String to replace from
<span class="lineNum">    1303 </span>            :     /// @param replaceWhat Character to replace
<a name="1304"><span class="lineNum">    1304 </span>            :     /// @param replaceWith Character to replace with</a>
<span class="lineNum">    1305 </span>            :     /// @return Modified (original) str
<span class="lineNum">    1306 </span><span class="lineCov">         64 :     static inline std::string&amp; replaceAll(std::string&amp; str, const std::string&amp; replaceWhat, // NOLINT</span>
<span class="lineNum">    1307 </span>            :             const std::string&amp; replaceWith) {
<span class="lineNum">    1308 </span><span class="lineCov">         64 :         if (replaceWhat == replaceWith)</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :             return str;</span>
<span class="lineNum">    1310 </span><span class="lineCov">         64 :         std::size_t foundAt = std::string::npos;</span>
<span class="lineNum">    1311 </span><span class="lineCov">        192 :         while ((foundAt = str.find(replaceWhat, foundAt + 1)) != std::string::npos) {</span>
<span class="lineNum">    1312 </span><span class="lineCov">         64 :             str.replace(foundAt, replaceWhat.length(), replaceWith);</span>
<span class="lineNum">    1313 </span>            :         }
<span class="lineNum">    1314 </span><span class="lineCov">         64 :         return str;</span>
<a name="1315"><span class="lineNum">    1315 </span>            :     }</a>
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span><span class="lineCov">       4888 :     static void replaceFirstWithEscape(base::type::string_t&amp; str, const base::type::string_t&amp; replaceWhat, // NOLINT</span>
<span class="lineNum">    1318 </span>            :             const base::type::string_t&amp; replaceWith) {
<span class="lineNum">    1319 </span><span class="lineCov">       4888 :         std::size_t foundAt = base::type::string_t::npos;</span>
<span class="lineNum">    1320 </span><span class="lineCov">       9776 :         while ((foundAt = str.find(replaceWhat, foundAt + 1)) != base::type::string_t::npos) {</span>
<span class="lineNum">    1321 </span><span class="lineCov">       4720 :             if (foundAt &gt; 0 &amp;&amp; str[foundAt - 1] == base::consts::kFormatSpecifierChar) {</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :                 str.erase(foundAt &gt; 0 ? foundAt - 1 : 0, 1);</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :                 ++foundAt;</span>
<span class="lineNum">    1324 </span>            :             } else {
<span class="lineNum">    1325 </span><span class="lineCov">       4720 :                 str.replace(foundAt, replaceWhat.length(), replaceWith);</span>
<span class="lineNum">    1326 </span><span class="lineCov">       9608 :                 return;</span>
<span class="lineNum">    1327 </span>            :             }
<span class="lineNum">    1328 </span>            :         }
<span class="lineNum">    1329 </span>            :     }
<span class="lineNum">    1330 </span>            : #if defined(ELPP_UNICODE)
<span class="lineNum">    1331 </span>            :     static void replaceFirstWithEscape(base::type::string_t&amp; str, const base::type::string_t&amp; replaceWhat, // NOLINT
<span class="lineNum">    1332 </span>            :             const std::string&amp; replaceWith) {
<span class="lineNum">    1333 </span>            :         replaceFirstWithEscape(str, replaceWhat, base::type::string_t(replaceWith.begin(), replaceWith.end()));
<span class="lineNum">    1334 </span>            :     }
<span class="lineNum">    1335 </span>            : #endif  // defined(ELPP_UNICODE)
<span class="lineNum">    1336 </span>            :     /// @brief Converts string to uppercase
<a name="1337"><span class="lineNum">    1337 </span>            :     /// @param str String to convert</a>
<span class="lineNum">    1338 </span>            :     /// @return Uppercase string
<span class="lineNum">    1339 </span><span class="lineCov">        192 :     static inline std::string&amp; toUpper(std::string&amp; str) {</span>
<span class="lineNum">    1340 </span><span class="lineCov">        192 :         std::transform(str.begin(), str.end(), str.begin(), ::toupper);</span>
<span class="lineNum">    1341 </span><span class="lineCov">        192 :         return str;</span>
<span class="lineNum">    1342 </span>            :     }
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span>            :     /// @brief Compares cstring equality - uses strcmp
<span class="lineNum">    1345 </span>            :     static inline bool cStringEq(const char* s1, const char* s2) {
<span class="lineNum">    1346 </span>            :         if (s1 == nullptr &amp;&amp; s2 == nullptr) return true;
<span class="lineNum">    1347 </span>            :         if (s1 == nullptr || s2 == nullptr) return false;
<span class="lineNum">    1348 </span>            :         return strcmp(s1, s2) == 0;
<span class="lineNum">    1349 </span>            :     }
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span>            :     /// @brief Compares cstring equality (case-insensitive) - uses toupper(char)
<span class="lineNum">    1352 </span>            :     /// Dont use strcasecmp because of CRT (VC++)
<span class="lineNum">    1353 </span>            :     static bool cStringCaseEq(const char* s1, const char* s2) {
<span class="lineNum">    1354 </span>            :         if (s1 == nullptr &amp;&amp; s2 == nullptr) return true;
<span class="lineNum">    1355 </span>            :         if (s1 == nullptr || s2 == nullptr) return false;
<span class="lineNum">    1356 </span>            :         if (strlen(s1) != strlen(s2)) return false;
<span class="lineNum">    1357 </span>            :         while (*s1 != '\0' &amp;&amp; *s2 != '\0') {
<span class="lineNum">    1358 </span>            :             if (::toupper(*s1) != ::toupper(*s2)) return false;
<span class="lineNum">    1359 </span>            :             ++s1;
<span class="lineNum">    1360 </span>            :             ++s2;
<span class="lineNum">    1361 </span>            :         }
<span class="lineNum">    1362 </span>            :         return true;
<span class="lineNum">    1363 </span>            :     }
<a name="1364"><span class="lineNum">    1364 </span>            : </a>
<span class="lineNum">    1365 </span>            :     /// @brief Returns true if c exist in str
<span class="lineNum">    1366 </span><span class="lineCov">         36 :     static inline bool contains(const char* str, char c) {</span>
<span class="lineNum">    1367 </span><span class="lineCov">        366 :         for (; *str; ++str) {</span>
<span class="lineNum">    1368 </span><span class="lineCov">        366 :             if (*str == c)</span>
<span class="lineNum">    1369 </span><span class="lineCov">         36 :                 return true;</span>
<span class="lineNum">    1370 </span>            :         }
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :         return false;</span>
<a name="1372"><span class="lineNum">    1372 </span>            :     }</a>
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span><span class="lineCov">       4973 :     static inline char* convertAndAddToBuff(std::size_t n, int len, char* buf, const char* bufLim, bool zeroPadded = true) {</span>
<span class="lineNum">    1375 </span><span class="lineCov">       4973 :         char localBuff[10] = &quot;&quot;;</span>
<span class="lineNum">    1376 </span><span class="lineCov">       4973 :         char* p = localBuff + sizeof(localBuff) - 2;</span>
<span class="lineNum">    1377 </span><span class="lineCov">       4973 :         if (n &gt; 0) {</span>
<span class="lineNum">    1378 </span><span class="lineCov">      14706 :             for (; n &gt; 0 &amp;&amp; p &gt; localBuff &amp;&amp; len &gt; 0; n /= 10, --len)</span>
<span class="lineNum">    1379 </span><span class="lineCov">       9754 :                 *--p = static_cast&lt;char&gt;(n % 10 + '0');</span>
<span class="lineNum">    1380 </span>            :         } else {
<span class="lineNum">    1381 </span><span class="lineCov">         21 :             *--p = '0';</span>
<span class="lineNum">    1382 </span><span class="lineCov">         21 :             --len;</span>
<span class="lineNum">    1383 </span>            :         }
<span class="lineNum">    1384 </span><span class="lineCov">       4973 :         if (zeroPadded)</span>
<span class="lineNum">    1385 </span><span class="lineCov">       3924 :             while (p &gt; localBuff &amp;&amp; len-- &gt; 0) *--p = static_cast&lt;char&gt;('0');</span>
<span class="lineNum">    1386 </span><span class="lineCov">       4973 :         return addToBuff(p, buf, bufLim);</span>
<a name="1387"><span class="lineNum">    1387 </span>            :     }</a>
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span><span class="lineCov">       6022 :     static inline char* addToBuff(const char* str, char* buf, const char* bufLim) {</span>
<span class="lineNum">    1390 </span><span class="lineCov">      41124 :         while ((buf &lt; bufLim) &amp;&amp; ((*buf = *str++) != '\0'))</span>
<span class="lineNum">    1391 </span><span class="lineCov">      29080 :             ++buf;</span>
<span class="lineNum">    1392 </span><span class="lineCov">       6022 :         return buf;</span>
<a name="1393"><span class="lineNum">    1393 </span>            :     }</a>
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span><span class="lineCov">       2098 :     static inline char* clearBuff(char buff[], std::size_t lim) {</span>
<span class="lineNum">    1396 </span><span class="lineCov">       2098 :         STRCPY(buff, &quot;&quot;, lim);</span>
<span class="lineNum">    1397 </span>            :         ELPP_UNUSED(lim);  // For *nix we dont have anything using lim in above STRCPY macro
<span class="lineNum">    1398 </span><span class="lineCov">       2098 :         return buff;</span>
<span class="lineNum">    1399 </span>            :     }
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span>            :     /// @brief Converst wchar* to char*
<span class="lineNum">    1402 </span>            :     ///        NOTE: Need to free return value after use!
<span class="lineNum">    1403 </span>            :     static char* wcharPtrToCharPtr(const wchar_t* line) {
<span class="lineNum">    1404 </span>            :         std::size_t len_ = wcslen(line) + 1;
<span class="lineNum">    1405 </span>            :         char* buff_ = static_cast&lt;char*&gt;(malloc(len_ + 1));
<span class="lineNum">    1406 </span>            : #      if ELPP_OS_UNIX || (ELPP_OS_WINDOWS &amp;&amp; !ELPP_CRT_DBG_WARNINGS)
<span class="lineNum">    1407 </span>            :         std::wcstombs(buff_, line, len_);
<span class="lineNum">    1408 </span>            : #      elif ELPP_OS_WINDOWS
<span class="lineNum">    1409 </span>            :         std::size_t convCount_ = 0;
<span class="lineNum">    1410 </span>            :         mbstate_t mbState_;
<span class="lineNum">    1411 </span>            :         ::memset(static_cast&lt;void*&gt;(&amp;mbState_), 0, sizeof(mbState_));
<span class="lineNum">    1412 </span>            :         wcsrtombs_s(&amp;convCount_, buff_, len_, &amp;line, len_, &amp;mbState_);
<span class="lineNum">    1413 </span>            : #      endif  // ELPP_OS_UNIX || (ELPP_OS_WINDOWS &amp;&amp; !ELPP_CRT_DBG_WARNINGS)
<span class="lineNum">    1414 </span>            :        return buff_;
<span class="lineNum">    1415 </span>            :     }
<span class="lineNum">    1416 </span>            : };
<span class="lineNum">    1417 </span>            : /// @brief Operating System helper static class used internally. You should not use it.
<span class="lineNum">    1418 </span>            : class OS : base::StaticClass {
<span class="lineNum">    1419 </span>            : public:
<span class="lineNum">    1420 </span>            : #if ELPP_OS_WINDOWS
<span class="lineNum">    1421 </span>            :     /// @brief Gets environment variables for Windows based OS. 
<span class="lineNum">    1422 </span>            :     ///        We are not using &lt;code&gt;getenv(const char*)&lt;/code&gt; because of CRT deprecation
<span class="lineNum">    1423 </span>            :     /// @param varname Variable name to get environment variable value for
<span class="lineNum">    1424 </span>            :     /// @return If variable exist the value of it otherwise nullptr
<span class="lineNum">    1425 </span>            :     static const char* getWindowsEnvironmentVariable(const char* varname) {
<span class="lineNum">    1426 </span>            :         const DWORD bufferLen = 50;
<span class="lineNum">    1427 </span>            :         static char buffer[bufferLen];
<span class="lineNum">    1428 </span>            :         if (GetEnvironmentVariableA(varname, buffer, bufferLen)) {
<span class="lineNum">    1429 </span>            :             return buffer;
<span class="lineNum">    1430 </span>            :         }
<span class="lineNum">    1431 </span>            :         return nullptr;
<span class="lineNum">    1432 </span>            :     }
<span class="lineNum">    1433 </span>            : #endif  // ELPP_OS_WINDOWS
<span class="lineNum">    1434 </span>            : #if ELPP_OS_ANDROID
<span class="lineNum">    1435 </span>            :     /// @brief Reads android property value
<span class="lineNum">    1436 </span>            :     static inline std::string getProperty(const char* prop) {
<span class="lineNum">    1437 </span>            :         char propVal[PROP_VALUE_MAX + 1];
<span class="lineNum">    1438 </span>            :         int ret = __system_property_get(prop, propVal);
<span class="lineNum">    1439 </span>            :         return ret == 0 ? std::string() : std::string(propVal);
<span class="lineNum">    1440 </span>            :     }
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            :     /// @brief Reads android device name
<span class="lineNum">    1443 </span>            :     static std::string getDeviceName(void) {
<span class="lineNum">    1444 </span>            :         std::stringstream ss;
<span class="lineNum">    1445 </span>            :         std::string manufacturer = getProperty(&quot;ro.product.manufacturer&quot;);
<span class="lineNum">    1446 </span>            :         std::string model = getProperty(&quot;ro.product.model&quot;);
<span class="lineNum">    1447 </span>            :         if (manufacturer.empty() || model.empty()) {
<span class="lineNum">    1448 </span>            :             return std::string();
<span class="lineNum">    1449 </span>            :         }
<span class="lineNum">    1450 </span>            :         ss &lt;&lt; manufacturer &lt;&lt; &quot;-&quot; &lt;&lt; model;
<span class="lineNum">    1451 </span>            :         return ss.str();
<span class="lineNum">    1452 </span>            :     }
<span class="lineNum">    1453 </span>            : #endif  // ELPP_OS_ANDROID
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span>            :     /// @brief Runs command on terminal and returns the output.
<span class="lineNum">    1456 </span>            :     ///
<span class="lineNum">    1457 </span>            :     /// @detail This is applicable only on unix based systems, for all other OS, an empty string is returned.
<span class="lineNum">    1458 </span>            :     /// @param command Bash command
<span class="lineNum">    1459 </span>            :     /// @return Result of bash output or empty string if no result found.
<span class="lineNum">    1460 </span>            :     static const std::string getBashOutput(const char* command) {
<span class="lineNum">    1461 </span>            : #if (ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID &amp;&amp; !ELPP_CYGWIN)
<span class="lineNum">    1462 </span>            :         if (command == nullptr) {
<span class="lineNum">    1463 </span>            :             return std::string();
<span class="lineNum">    1464 </span>            :         }
<span class="lineNum">    1465 </span>            :         FILE* proc = nullptr;
<span class="lineNum">    1466 </span>            :         if ((proc = popen(command, &quot;r&quot;)) == nullptr) {
<span class="lineNum">    1467 </span>            :             ELPP_INTERNAL_ERROR(&quot;\nUnable to run command [&quot; &lt;&lt; command &lt;&lt; &quot;]&quot;, true);
<span class="lineNum">    1468 </span>            :             return std::string();
<span class="lineNum">    1469 </span>            :         }
<span class="lineNum">    1470 </span>            :         char hBuff[4096];
<span class="lineNum">    1471 </span>            :         if (fgets(hBuff, sizeof(hBuff), proc) != nullptr) {
<span class="lineNum">    1472 </span>            :             pclose(proc);
<span class="lineNum">    1473 </span>            :             if (hBuff[strlen(hBuff) - 1] == '\n') {
<span class="lineNum">    1474 </span>            :                 hBuff[strlen(hBuff) - 1] = '\0';
<span class="lineNum">    1475 </span>            :             }
<span class="lineNum">    1476 </span>            :             return std::string(hBuff);
<span class="lineNum">    1477 </span>            :         }
<span class="lineNum">    1478 </span>            :         return std::string();
<span class="lineNum">    1479 </span>            : #else
<span class="lineNum">    1480 </span>            :         ELPP_UNUSED(command);
<span class="lineNum">    1481 </span>            :         return std::string();
<span class="lineNum">    1482 </span>            : #endif  // (ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID &amp;&amp; !ELPP_CYGWIN)
<span class="lineNum">    1483 </span>            :     }
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span>            :     /// @brief Gets environment variable. This is cross-platform and CRT safe (for VC++)
<span class="lineNum">    1486 </span>            :     /// @param variableName Environment variable name
<span class="lineNum">    1487 </span>            :     /// @param defaultVal If no environment variable or value found the value to return by default
<a name="1488"><span class="lineNum">    1488 </span>            :     /// @param alternativeBashCommand If environment variable not found what would be alternative bash command</a>
<span class="lineNum">    1489 </span>            :     ///        in order to look for value user is looking for. E.g, for 'user' alternative command will 'whoami'
<span class="lineNum">    1490 </span><span class="lineCov">          6 :     static std::string getEnvironmentVariable(const char* variableName, const char* defaultVal, const char* alternativeBashCommand = nullptr) {</span>
<span class="lineNum">    1491 </span>            : #if ELPP_OS_UNIX
<span class="lineNum">    1492 </span><span class="lineCov">          6 :         const char* val = getenv(variableName);</span>
<span class="lineNum">    1493 </span>            : #elif ELPP_OS_WINDOWS
<span class="lineNum">    1494 </span>            :         const char* val = getWindowsEnvironmentVariable(variableName);
<span class="lineNum">    1495 </span>            : #endif  // ELPP_OS_UNIX
<span class="lineNum">    1496 </span><span class="lineCov">          6 :         if ((val == nullptr) || ((strcmp(val, &quot;&quot;) == 0))) {</span>
<span class="lineNum">    1497 </span>            : #if ELPP_OS_UNIX &amp;&amp; defined(ELPP_FORCE_ENV_VAR_FROM_BASH)
<span class="lineNum">    1498 </span>            :            // Try harder on unix-based systems
<span class="lineNum">    1499 </span>            :             std::string valBash = base::utils::OS::getBashOutput(alternativeBashCommand);
<span class="lineNum">    1500 </span>            :             if (valBash.empty()) {
<span class="lineNum">    1501 </span>            :                 return std::string(defaultVal);
<span class="lineNum">    1502 </span>            :             } else {
<span class="lineNum">    1503 </span>            :                 return valBash;
<span class="lineNum">    1504 </span>            :             }
<span class="lineNum">    1505 </span>            : #elif ELPP_OS_WINDOWS || ELPP_OS_UNIX
<span class="lineNum">    1506 </span>            :             ELPP_UNUSED(alternativeBashCommand);
<span class="lineNum">    1507 </span><span class="lineCov">          2 :             return std::string(defaultVal);</span>
<span class="lineNum">    1508 </span>            : #endif  // ELPP_OS_UNIX &amp;&amp; defined(ELPP_FORCE_ENV_VAR_FROM_BASH)
<span class="lineNum">    1509 </span>            :         }
<span class="lineNum">    1510 </span><span class="lineCov">          4 :         return std::string(val);</span>
<a name="1511"><span class="lineNum">    1511 </span>            :     }</a>
<span class="lineNum">    1512 </span>            :    /// @brief Gets current username.
<span class="lineNum">    1513 </span><span class="lineCov">          2 :     static inline std::string currentUser(void) {</span>
<span class="lineNum">    1514 </span>            : #if ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID
<span class="lineNum">    1515 </span><span class="lineCov">          2 :         return getEnvironmentVariable(&quot;USER&quot;, base::consts::kUnknownUser, &quot;whoami&quot;);</span>
<span class="lineNum">    1516 </span>            : #elif ELPP_OS_WINDOWS
<span class="lineNum">    1517 </span>            :         return getEnvironmentVariable(&quot;USERNAME&quot;, base::consts::kUnknownUser);
<span class="lineNum">    1518 </span>            : #elif ELPP_OS_ANDROID
<span class="lineNum">    1519 </span>            :         ELPP_UNUSED(base::consts::kUnknownUser);
<span class="lineNum">    1520 </span>            :         return std::string(&quot;android&quot;);
<span class="lineNum">    1521 </span>            : #else
<span class="lineNum">    1522 </span>            :         return std::string();
<span class="lineNum">    1523 </span>            : #endif  // ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID
<span class="lineNum">    1524 </span>            :     }
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            :     /// @brief Gets current host name or computer name.
<a name="1527"><span class="lineNum">    1527 </span>            :     ///</a>
<span class="lineNum">    1528 </span>            :     /// @detail For android systems this is device name with its manufacturer and model seperated by hyphen
<span class="lineNum">    1529 </span><span class="lineCov">          2 :     static inline std::string currentHost(void) {</span>
<span class="lineNum">    1530 </span>            : #if ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID
<span class="lineNum">    1531 </span><span class="lineCov">          2 :         return getEnvironmentVariable(&quot;HOSTNAME&quot;, base::consts::kUnknownHost, &quot;hostname&quot;);</span>
<span class="lineNum">    1532 </span>            : #elif ELPP_OS_WINDOWS
<span class="lineNum">    1533 </span>            :         return getEnvironmentVariable(&quot;COMPUTERNAME&quot;, base::consts::kUnknownHost);
<span class="lineNum">    1534 </span>            : #elif ELPP_OS_ANDROID
<span class="lineNum">    1535 </span>            :         ELPP_UNUSED(base::consts::kUnknownHost);
<span class="lineNum">    1536 </span>            :         return getDeviceName();
<span class="lineNum">    1537 </span>            : #else
<span class="lineNum">    1538 </span>            :         return std::string();
<span class="lineNum">    1539 </span>            : #endif  // ELPP_OS_UNIX &amp;&amp; !ELPP_OS_ANDROID
<a name="1540"><span class="lineNum">    1540 </span>            :     }</a>
<span class="lineNum">    1541 </span>            :     /// @brief Whether or not terminal supports colors
<span class="lineNum">    1542 </span><span class="lineCov">          2 :     static inline bool termSupportsColor(void) {</span>
<span class="lineNum">    1543 </span><span class="lineCov">          2 :         std::string term = getEnvironmentVariable(&quot;TERM&quot;, &quot;&quot;);</span>
<span class="lineNum">    1544 </span><span class="lineCov">          2 :         return term == &quot;xterm&quot; || term == &quot;xterm-color&quot; || term == &quot;xterm-256color&quot; ||</span>
<span class="lineNum">    1545 </span><span class="lineCov">          2 :                               term == &quot;screen&quot; || term == &quot;linux&quot; || term == &quot;cygwin&quot;;</span>
<span class="lineNum">    1546 </span>            :     }
<span class="lineNum">    1547 </span>            : };
<span class="lineNum">    1548 </span>            : extern std::string s_currentUser;
<span class="lineNum">    1549 </span>            : extern std::string s_currentHost;
<span class="lineNum">    1550 </span>            : extern bool s_termSupportsColor;
<span class="lineNum">    1551 </span>            : #define ELPP_INITI_BASIC_DECLR \
<span class="lineNum">    1552 </span>            :     namespace el {\
<span class="lineNum">    1553 </span>            :         namespace base {\
<span class="lineNum">    1554 </span>            :             namespace utils {\
<span class="lineNum">    1555 </span>            :                 std::string s_currentUser = el::base::utils::OS::currentUser(); \
<span class="lineNum">    1556 </span>            :                 std::string s_currentHost = el::base::utils::OS::currentHost(); \
<span class="lineNum">    1557 </span>            :                 bool s_termSupportsColor = el::base::utils::OS::termSupportsColor(); \
<span class="lineNum">    1558 </span>            :             }\
<span class="lineNum">    1559 </span>            :         }\
<span class="lineNum">    1560 </span>            :    }
<span class="lineNum">    1561 </span>            : /// @brief Contains utilities for cross-platform date/time. This class make use of el::base::utils::Str
<span class="lineNum">    1562 </span>            : class DateTime : base::StaticClass {
<span class="lineNum">    1563 </span>            : public:
<span class="lineNum">    1564 </span>            :     /// @brief Cross platform gettimeofday for Windows and unix platform. This can be used to determine current millisecond.
<span class="lineNum">    1565 </span>            :     ///
<a name="1566"><span class="lineNum">    1566 </span>            :     /// @detail For unix system it uses gettimeofday(timeval*, timezone*) and for Windows, a seperate implementation is provided</a>
<span class="lineNum">    1567 </span>            :     /// @param [in,out] tv Pointer that gets updated
<span class="lineNum">    1568 </span><span class="lineCov">       1308 :     static void gettimeofday(struct timeval* tv) {</span>
<span class="lineNum">    1569 </span>            : #if ELPP_OS_WINDOWS
<span class="lineNum">    1570 </span>            :         if (tv != nullptr) {
<span class="lineNum">    1571 </span>            : #   if ELPP_COMPILER_MSVC || defined(_MSC_EXTENSIONS)
<span class="lineNum">    1572 </span>            :             const unsigned __int64 delta_ = 11644473600000000Ui64;
<span class="lineNum">    1573 </span>            : #   else
<span class="lineNum">    1574 </span>            :             const unsigned __int64 delta_ = 11644473600000000ULL;
<span class="lineNum">    1575 </span>            : #   endif  // ELPP_COMPILER_MSVC || defined(_MSC_EXTENSIONS)
<span class="lineNum">    1576 </span>            :             const double secOffSet = 0.000001;
<span class="lineNum">    1577 </span>            :             const unsigned long usecOffSet = 1000000;
<span class="lineNum">    1578 </span>            :             FILETIME fileTime;
<span class="lineNum">    1579 </span>            :             GetSystemTimeAsFileTime(&amp;fileTime);
<span class="lineNum">    1580 </span>            :             unsigned __int64 present = 0;
<span class="lineNum">    1581 </span>            :             present |= fileTime.dwHighDateTime;
<span class="lineNum">    1582 </span>            :             present = present &lt;&lt; 32;
<span class="lineNum">    1583 </span>            :             present |= fileTime.dwLowDateTime;
<span class="lineNum">    1584 </span>            :             present /= 10;  // mic-sec
<span class="lineNum">    1585 </span>            :            // Subtract the difference
<span class="lineNum">    1586 </span>            :             present -= delta_;
<span class="lineNum">    1587 </span>            :             tv-&gt;tv_sec = static_cast&lt;long&gt;(present * secOffSet);
<span class="lineNum">    1588 </span>            :             tv-&gt;tv_usec = static_cast&lt;long&gt;(present % usecOffSet);
<span class="lineNum">    1589 </span>            :         }
<span class="lineNum">    1590 </span>            : #else
<span class="lineNum">    1591 </span><span class="lineCov">       1308 :         ::gettimeofday(tv, nullptr);</span>
<span class="lineNum">    1592 </span>            : #endif  // ELPP_OS_WINDOWS
<span class="lineNum">    1593 </span><span class="lineCov">       1308 :     }</span>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span>            :     /// @brief Gets current date and time with milliseconds.
<span class="lineNum">    1596 </span>            :     /// @param format User provided date/time format
<a name="1597"><span class="lineNum">    1597 </span>            :     /// @param msWidth A pointer to base::MillisecondsWidth from configuration (non-null)</a>
<span class="lineNum">    1598 </span>            :     /// @returns string based date time in specified format.
<span class="lineNum">    1599 </span><span class="lineCov">       1308 :     static inline std::string getDateTime(const char* format, const base::MillisecondsWidth* msWidth) {</span>
<span class="lineNum">    1600 </span>            :         struct timeval currTime;
<span class="lineNum">    1601 </span><span class="lineCov">       1308 :         gettimeofday(&amp;currTime);</span>
<span class="lineNum">    1602 </span>            :         struct ::tm timeInfo;
<span class="lineNum">    1603 </span><span class="lineCov">       1308 :         buildTimeInfo(&amp;currTime, &amp;timeInfo);</span>
<span class="lineNum">    1604 </span><span class="lineCov">       1308 :         const int kBuffSize = 30;</span>
<span class="lineNum">    1605 </span><span class="lineCov">       1308 :         char buff_[kBuffSize] = &quot;&quot;;</span>
<span class="lineNum">    1606 </span><span class="lineCov">       1308 :         parseFormat(buff_, kBuffSize, format, &amp;timeInfo, static_cast&lt;std::size_t&gt;(currTime.tv_usec / msWidth-&gt;m_offset), msWidth);</span>
<span class="lineNum">    1607 </span><span class="lineCov">       1308 :         return std::string(buff_);</span>
<span class="lineNum">    1608 </span>            :     }
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span>            :     /// @brief Formats time to get unit accordingly, units like second if &gt; 1000 or minutes if &gt; 60000 etc
<span class="lineNum">    1611 </span>            :     static base::type::string_t formatTime(unsigned long long time, base::TimestampUnit timestampUnit) {
<span class="lineNum">    1612 </span>            :         double result = static_cast&lt;double&gt;(time);
<span class="lineNum">    1613 </span>            :         base::type::EnumType start = static_cast&lt;base::type::EnumType&gt;(timestampUnit);
<span class="lineNum">    1614 </span>            :         const base::type::char_t* unit = base::consts::kTimeFormats[start].unit;
<span class="lineNum">    1615 </span>            :         for (base::type::EnumType i = start; i &lt; base::consts::kTimeFormatsCount - 1; ++i) {
<span class="lineNum">    1616 </span>            :             if (result &lt;= base::consts::kTimeFormats[i].value) {
<span class="lineNum">    1617 </span>            :                 break;
<span class="lineNum">    1618 </span>            :             }
<span class="lineNum">    1619 </span>            :             result /= base::consts::kTimeFormats[i].value;
<span class="lineNum">    1620 </span>            :             unit = base::consts::kTimeFormats[i + 1].unit;
<span class="lineNum">    1621 </span>            :         }
<span class="lineNum">    1622 </span>            :         base::type::stringstream_t ss;
<span class="lineNum">    1623 </span>            :         ss &lt;&lt; result &lt;&lt; &quot; &quot; &lt;&lt; unit;
<span class="lineNum">    1624 </span>            :         return ss.str();
<span class="lineNum">    1625 </span>            :     }
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span>            :     /// @brief Gets time difference in milli/micro second depending on timestampUnit
<span class="lineNum">    1628 </span>            :     static inline unsigned long long getTimeDifference(const struct timeval&amp; endTime, const struct timeval&amp; startTime, base::TimestampUnit timestampUnit) {
<span class="lineNum">    1629 </span>            :         if (timestampUnit == base::TimestampUnit::Microsecond) {
<span class="lineNum">    1630 </span>            :             return static_cast&lt;unsigned long long&gt;(static_cast&lt;unsigned long long&gt;(1000000 * endTime.tv_sec + endTime.tv_usec) -
<span class="lineNum">    1631 </span>            :                     static_cast&lt;unsigned long long&gt;(1000000 * startTime.tv_sec + startTime.tv_usec));
<span class="lineNum">    1632 </span>            :         } else {
<span class="lineNum">    1633 </span>            :             return static_cast&lt;unsigned long long&gt;((((endTime.tv_sec - startTime.tv_sec) * 1000000) + (endTime.tv_usec - startTime.tv_usec)) / 1000);
<span class="lineNum">    1634 </span>            :         }
<span class="lineNum">    1635 </span>            :     }
<a name="1636"><span class="lineNum">    1636 </span>            : </a>
<span class="lineNum">    1637 </span>            : private:
<span class="lineNum">    1638 </span><span class="lineCov">       1308 :     static inline struct ::tm* buildTimeInfo(struct timeval* currTime, struct ::tm* timeInfo) {</span>
<span class="lineNum">    1639 </span>            : #if ELPP_OS_UNIX
<span class="lineNum">    1640 </span><span class="lineCov">       1308 :         time_t rawTime = currTime-&gt;tv_sec;</span>
<span class="lineNum">    1641 </span><span class="lineCov">       1308 :         ::localtime_r(&amp;rawTime, timeInfo);</span>
<span class="lineNum">    1642 </span><span class="lineCov">       1308 :         return timeInfo;</span>
<span class="lineNum">    1643 </span>            : #else
<span class="lineNum">    1644 </span>            : #   if ELPP_COMPILER_MSVC
<span class="lineNum">    1645 </span>            :         ELPP_UNUSED(currTime);
<span class="lineNum">    1646 </span>            :         time_t t;
<span class="lineNum">    1647 </span>            :         _time64(&amp;t);
<span class="lineNum">    1648 </span>            :         localtime_s(timeInfo, &amp;t);
<span class="lineNum">    1649 </span>            :         return timeInfo;
<span class="lineNum">    1650 </span>            : #   else
<span class="lineNum">    1651 </span>            :         // For any other compilers that don't have CRT warnings issue e.g, MinGW or TDM GCC- we use different method
<span class="lineNum">    1652 </span>            :         time_t rawTime = currTime-&gt;tv_sec;
<span class="lineNum">    1653 </span>            :         struct tm* tmInf = localtime(&amp;rawTime);
<span class="lineNum">    1654 </span>            :         *timeInfo = *tmInf;
<span class="lineNum">    1655 </span>            :         return timeInfo;
<span class="lineNum">    1656 </span>            : #   endif  // ELPP_COMPILER_MSVC
<a name="1657"><span class="lineNum">    1657 </span>            : #endif  // ELPP_OS_UNIX</a>
<span class="lineNum">    1658 </span>            :     }
<span class="lineNum">    1659 </span><span class="lineCov">       1308 :     static char* parseFormat(char* buf, std::size_t bufSz, const char* format, const struct tm* tInfo,</span>
<span class="lineNum">    1660 </span>            :             std::size_t msec, const base::MillisecondsWidth* msWidth) {
<span class="lineNum">    1661 </span><span class="lineCov">       1308 :         const char* bufLim = buf + bufSz;</span>
<span class="lineNum">    1662 </span><span class="lineCov">       7720 :         for (; *format; ++format) {</span>
<span class="lineNum">    1663 </span><span class="lineCov">       6412 :             if (*format == base::consts::kFormatSpecifierChar) {</span>
<span class="lineNum">    1664 </span><span class="lineCov">       3924 :                 switch (*++format) {</span>
<span class="lineNum">    1665 </span>            :                 case base::consts::kFormatSpecifierChar:  // Escape
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1667 </span>            :                 case '\0':  // End
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :                     --format;</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1670 </span>            :                 case 'd':  // Day
<span class="lineNum">    1671 </span><span class="lineCov">         64 :                     buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_mday, 2, buf, bufLim);</span>
<span class="lineNum">    1672 </span><span class="lineCov">         64 :                     continue;</span>
<span class="lineNum">    1673 </span>            :                 case 'a':  // Day of week (short)
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :                     buf = base::utils::Str::addToBuff(base::consts::kDaysAbbrev[tInfo-&gt;tm_wday], buf, bufLim);</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1676 </span>            :                 case 'A':  // Day of week (long)
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :                     buf = base::utils::Str::addToBuff(base::consts::kDays[tInfo-&gt;tm_wday], buf, bufLim);</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1679 </span>            :                 case 'M':  // month
<span class="lineNum">    1680 </span><span class="lineCov">         64 :                     buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_mon + 1, 2, buf, bufLim);</span>
<span class="lineNum">    1681 </span><span class="lineCov">         64 :                     continue;</span>
<span class="lineNum">    1682 </span>            :                 case 'b':  // month (short)
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :                     buf = base::utils::Str::addToBuff(base::consts::kMonthsAbbrev[tInfo-&gt;tm_mon], buf, bufLim);</span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1685 </span>            :                 case 'B':  // month (long)
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :                     buf = base::utils::Str::addToBuff(base::consts::kMonths[tInfo-&gt;tm_mon], buf, bufLim);</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1688 </span>            :                 case 'y':  // year (two digits)
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :                     buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_year + base::consts::kYearBase, 2, buf, bufLim);</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1691 </span>            :                 case 'Y':  // year (four digits)
<span class="lineNum">    1692 </span><span class="lineCov">         64 :                     buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_year + base::consts::kYearBase, 4, buf, bufLim);</span>
<span class="lineNum">    1693 </span><span class="lineCov">         64 :                     continue;</span>
<span class="lineNum">    1694 </span>            :                 case 'h':  // hour (12-hour)
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :                     buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_hour % 12, 2, buf, bufLim);</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1697 </span>            :                 case 'H':  // hour (24-hour)
<span class="lineNum">    1698 </span><span class="lineCov">       1244 :                     buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_hour, 2, buf, bufLim);</span>
<span class="lineNum">    1699 </span><span class="lineCov">       1244 :                     continue;</span>
<span class="lineNum">    1700 </span>            :                 case 'm':  // minute
<span class="lineNum">    1701 </span><span class="lineCov">       1244 :                     buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_min, 2, buf, bufLim);</span>
<span class="lineNum">    1702 </span><span class="lineCov">       1244 :                     continue;</span>
<span class="lineNum">    1703 </span>            :                 case 's':  // second
<span class="lineNum">    1704 </span><span class="lineCov">       1244 :                     buf = base::utils::Str::convertAndAddToBuff(tInfo-&gt;tm_sec, 2, buf, bufLim);</span>
<span class="lineNum">    1705 </span><span class="lineCov">       1244 :                     continue;</span>
<span class="lineNum">    1706 </span>            :                 case 'z':  // milliseconds
<span class="lineNum">    1707 </span>            :                 case 'g':
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :                     buf = base::utils::Str::convertAndAddToBuff(msec, msWidth-&gt;m_width, buf, bufLim);</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1710 </span>            :                 case 'F':  // AM/PM
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :                     buf = base::utils::Str::addToBuff((tInfo-&gt;tm_hour &gt;= 12) ? base::consts::kPm : base::consts::kAm, buf, bufLim);</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1713 </span>            :                 default:
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1715 </span>            :                 }
<span class="lineNum">    1716 </span>            :             }
<span class="lineNum">    1717 </span><span class="lineCov">       2488 :             if (buf == bufLim) break;</span>
<span class="lineNum">    1718 </span><span class="lineCov">       2488 :             *buf++ = *format;</span>
<span class="lineNum">    1719 </span>            :         }
<span class="lineNum">    1720 </span><span class="lineCov">       1308 :         return buf;</span>
<span class="lineNum">    1721 </span>            :     }
<span class="lineNum">    1722 </span>            : };
<span class="lineNum">    1723 </span>            : /// @brief Command line arguments for application if specified using el::Helpers::setArgs(..) or START_EASYLOGGINGPP(..)
<a name="1724"><span class="lineNum">    1724 </span>            : class CommandLineArgs {</a>
<span class="lineNum">    1725 </span>            : public:
<span class="lineNum">    1726 </span><span class="lineCov">          2 :     CommandLineArgs(void) {</span>
<span class="lineNum">    1727 </span><span class="lineCov">          2 :         setArgs(0, static_cast&lt;char**&gt;(nullptr));</span>
<span class="lineNum">    1728 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    1729 </span>            :     CommandLineArgs(int argc, const char** argv) {
<span class="lineNum">    1730 </span>            :         setArgs(argc, argv);
<span class="lineNum">    1731 </span>            :     }
<span class="lineNum">    1732 </span>            :     CommandLineArgs(int argc, char** argv) {
<a name="1733"><span class="lineNum">    1733 </span>            :         setArgs(argc, argv);</a>
<span class="lineNum">    1734 </span>            :     }
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :     virtual ~CommandLineArgs(void) {}</span>
<span class="lineNum">    1736 </span>            :     /// @brief Sets arguments and parses them
<span class="lineNum">    1737 </span>            :     inline void setArgs(int argc, const char** argv) {
<span class="lineNum">    1738 </span>            :         setArgs(argc, const_cast&lt;char**&gt;(argv));
<a name="1739"><span class="lineNum">    1739 </span>            :     }</a>
<span class="lineNum">    1740 </span>            :     /// @brief Sets arguments and parses them
<span class="lineNum">    1741 </span><span class="lineCov">          2 :     inline void setArgs(int argc, char** argv) {</span>
<span class="lineNum">    1742 </span><span class="lineCov">          2 :         m_params.clear();</span>
<span class="lineNum">    1743 </span><span class="lineCov">          2 :         m_paramsWithValue.clear();</span>
<span class="lineNum">    1744 </span><span class="lineCov">          2 :         if (argc == 0 || argv == nullptr) {</span>
<span class="lineNum">    1745 </span><span class="lineCov">          4 :             return;</span>
<span class="lineNum">    1746 </span>            :         }
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :         m_argc = argc;</span>
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :         m_argv = argv;</span>
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :         for (int i = 1; i &lt; m_argc; ++i) {</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :             const char* v = (strstr(m_argv[i], &quot;=&quot;));</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :             if (v != nullptr &amp;&amp; strlen(v) &gt; 0) {</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :                 std::string key = std::string(m_argv[i]);</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :                 key = key.substr(0, key.find_first_of('='));</span>
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :                 if (hasParamWithValue(key.c_str())) {</span>
<span class="lineNum">    1755 </span>            :                     ELPP_INTERNAL_INFO(1, &quot;Skipping [&quot; &lt;&lt; key &lt;&lt; &quot;] arg since it already has value [&quot; 
<span class="lineNum">    1756 </span>            :                         &lt;&lt; getParamValue(key.c_str()) &lt;&lt; &quot;]&quot;);
<span class="lineNum">    1757 </span>            :                 } else {
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :                     m_paramsWithValue.insert(std::make_pair(key, std::string(v + 1)));</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    1760 </span>            :             }
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :             if (v == nullptr) {</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :                 if (hasParam(m_argv[i])) {</span>
<span class="lineNum">    1763 </span>            :                     ELPP_INTERNAL_INFO(1, &quot;Skipping [&quot; &lt;&lt; m_argv[i] &lt;&lt; &quot;] arg since it already exists&quot;);
<span class="lineNum">    1764 </span>            :                 } else {
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :                     m_params.push_back(std::string(m_argv[i]));</span>
<span class="lineNum">    1766 </span>            :                 }
<span class="lineNum">    1767 </span>            :             }
<span class="lineNum">    1768 </span>            :         }
<a name="1769"><span class="lineNum">    1769 </span>            :     }</a>
<span class="lineNum">    1770 </span>            :     /// @brief Returns true if arguments contain paramKey with a value (seperated by '=')
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :     inline bool hasParamWithValue(const char* paramKey) const {</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :         return m_paramsWithValue.find(std::string(paramKey)) != m_paramsWithValue.end();</span>
<span class="lineNum">    1773 </span>            :     }
<span class="lineNum">    1774 </span>            :     /// @brief Returns value of arguments
<span class="lineNum">    1775 </span>            :     /// @see hasParamWithValue(const char*)
<span class="lineNum">    1776 </span>            :     inline const char* getParamValue(const char* paramKey) const {
<span class="lineNum">    1777 </span>            :         return m_paramsWithValue.find(std::string(paramKey))-&gt;second.c_str();
<a name="1778"><span class="lineNum">    1778 </span>            :     }</a>
<span class="lineNum">    1779 </span>            :     /// @brief Return true if arguments has a param (not having a value) i,e without '='
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :     inline bool hasParam(const char* paramKey) const {</span>
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :         return std::find(m_params.begin(), m_params.end(), std::string(paramKey)) != m_params.end();</span>
<span class="lineNum">    1782 </span>            :     }
<span class="lineNum">    1783 </span>            :     /// @brief Returns true if no params available. This exclude argv[0]
<span class="lineNum">    1784 </span>            :     inline bool empty(void) const {
<span class="lineNum">    1785 </span>            :         return m_params.empty() &amp;&amp; m_paramsWithValue.empty();
<span class="lineNum">    1786 </span>            :     }
<span class="lineNum">    1787 </span>            :     /// @brief Returns total number of arguments. This exclude argv[0]
<span class="lineNum">    1788 </span>            :     inline std::size_t size(void) const {
<span class="lineNum">    1789 </span>            :         return m_params.size() + m_paramsWithValue.size();
<span class="lineNum">    1790 </span>            :     }
<span class="lineNum">    1791 </span>            :     inline friend base::type::ostream_t&amp; operator&lt;&lt;(base::type::ostream_t&amp; os, const CommandLineArgs&amp; c) {
<span class="lineNum">    1792 </span>            :         for (int i = 1; i &lt; c.m_argc; ++i) {
<span class="lineNum">    1793 </span>            :             os &lt;&lt; ELPP_LITERAL(&quot;[&quot;) &lt;&lt; c.m_argv[i] &lt;&lt; ELPP_LITERAL(&quot;]&quot;);
<span class="lineNum">    1794 </span>            :             if (i &lt; c.m_argc - 1) {
<span class="lineNum">    1795 </span>            :                 os &lt;&lt; ELPP_LITERAL(&quot; &quot;);
<span class="lineNum">    1796 </span>            :             }
<span class="lineNum">    1797 </span>            :         }
<span class="lineNum">    1798 </span>            :         return os;
<span class="lineNum">    1799 </span>            :     }
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span>            : private:
<span class="lineNum">    1802 </span>            :     int m_argc;
<span class="lineNum">    1803 </span>            :     char** m_argv;
<span class="lineNum">    1804 </span>            :     std::map&lt;std::string, std::string&gt; m_paramsWithValue;
<span class="lineNum">    1805 </span>            :     std::vector&lt;std::string&gt; m_params;
<span class="lineNum">    1806 </span>            : };
<span class="lineNum">    1807 </span>            : /// @brief Abstract registry (aka repository) that provides basic interface for pointer repository specified by T_Ptr type.
<span class="lineNum">    1808 </span>            : ///
<span class="lineNum">    1809 </span>            : /// @detail Most of the functions are virtual final methods but anything implementing this abstract class should implement
<span class="lineNum">    1810 </span>            : /// unregisterAll() and deepCopy(const AbstractRegistry&lt;T_Ptr, Container&gt;&amp;) and write registerNew() method according to container
<span class="lineNum">    1811 </span>            : /// and few more methods; get() to find element, unregister() to unregister single entry.
<span class="lineNum">    1812 </span>            : /// Please note that this is thread-unsafe and should also implement thread-safety mechanisms in implementation.
<span class="lineNum">    1813 </span>            : template &lt;typename T_Ptr, typename Container&gt;
<span class="lineNum">    1814 </span>            : class AbstractRegistry : public base::threading::ThreadSafe {
<span class="lineNum">    1815 </span>            : public:
<span class="lineNum">    1816 </span>            :     typedef typename Container::iterator iterator;
<span class="lineNum">    1817 </span>            :     typedef typename Container::const_iterator const_iterator;
<a name="1818"><span class="lineNum">    1818 </span>            : </a>
<span class="lineNum">    1819 </span>            :     /// @brief Default constructor
<span class="lineNum">    1820 </span><span class="lineCov">         14 :     AbstractRegistry(void) {}</span>
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span>            :     /// @brief Move constructor that is useful for base classes
<span class="lineNum">    1823 </span>            :     AbstractRegistry(AbstractRegistry&amp;&amp; sr) {
<span class="lineNum">    1824 </span>            :         if (this == &amp;sr) {
<span class="lineNum">    1825 </span>            :             return;
<span class="lineNum">    1826 </span>            :         }
<span class="lineNum">    1827 </span>            :         unregisterAll();
<span class="lineNum">    1828 </span>            :         m_list = std::move(sr.m_list);
<span class="lineNum">    1829 </span>            :     }
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span>            :     bool operator==(const AbstractRegistry&lt;T_Ptr, Container&gt;&amp; other) {
<span class="lineNum">    1832 </span>            :         if (size() != other.size()) {
<span class="lineNum">    1833 </span>            :             return false;
<span class="lineNum">    1834 </span>            :         }
<span class="lineNum">    1835 </span>            :         for (std::size_t i = 0; i &lt; m_list.size(); ++i) {
<span class="lineNum">    1836 </span>            :             if (m_list.at(i) != other.m_list.at(i)) {
<span class="lineNum">    1837 </span>            :                 return false;
<span class="lineNum">    1838 </span>            :             }
<span class="lineNum">    1839 </span>            :         }
<span class="lineNum">    1840 </span>            :         return true;
<a name="1841"><span class="lineNum">    1841 </span>            :     }</a>
<span class="lineNum">    1842 </span>            : 
<span class="lineNum">    1843 </span><span class="lineCov">         14 :     bool operator!=(const AbstractRegistry&lt;T_Ptr, Container&gt;&amp; other) {</span>
<span class="lineNum">    1844 </span><span class="lineCov">         14 :         if (size() != other.size()) {</span>
<span class="lineNum">    1845 </span><span class="lineCov">         12 :             return true;</span>
<span class="lineNum">    1846 </span>            :         }
<span class="lineNum">    1847 </span><span class="lineCov">        146 :         for (std::size_t i = 0; i &lt; m_list.size(); ++i) {</span>
<span class="lineNum">    1848 </span><span class="lineCov">        144 :             if (m_list.at(i) != other.m_list.at(i)) {</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    1850 </span>            :             }
<span class="lineNum">    1851 </span>            :         }
<span class="lineNum">    1852 </span><span class="lineCov">          2 :         return false;</span>
<span class="lineNum">    1853 </span>            :     }
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span>            :     /// @brief Assignment move operator
<span class="lineNum">    1856 </span>            :     AbstractRegistry&amp; operator=(AbstractRegistry&amp;&amp; sr) {
<span class="lineNum">    1857 </span>            :         if (this == &amp;sr) {
<span class="lineNum">    1858 </span>            :             return *this;
<span class="lineNum">    1859 </span>            :         }
<span class="lineNum">    1860 </span>            :         unregisterAll();
<span class="lineNum">    1861 </span>            :         m_list = std::move(sr.m_list);
<span class="lineNum">    1862 </span>            :         return *this;
<a name="1863"><span class="lineNum">    1863 </span>            :     }</a>
<span class="lineNum">    1864 </span>            : 
<span class="lineNum">    1865 </span><span class="lineCov">          4 :     virtual ~AbstractRegistry(void) {</span>
<span class="lineNum">    1866 </span><span class="lineCov">          4 :     }</span>
<a name="1867"><span class="lineNum">    1867 </span>            : </a>
<span class="lineNum">    1868 </span>            :     /// @return Iterator pointer from start of repository
<span class="lineNum">    1869 </span><span class="lineCov">         32 :     virtual inline iterator begin(void) ELPP_FINAL {</span>
<span class="lineNum">    1870 </span><span class="lineCov">         32 :         return m_list.begin();</span>
<span class="lineNum">    1871 </span>            :     }
<a name="1872"><span class="lineNum">    1872 </span>            : </a>
<span class="lineNum">    1873 </span>            :     /// @return Iterator pointer from end of repository
<span class="lineNum">    1874 </span><span class="lineCov">       2056 :     virtual inline iterator end(void) ELPP_FINAL {</span>
<span class="lineNum">    1875 </span><span class="lineCov">       2056 :         return m_list.end();</span>
<span class="lineNum">    1876 </span>            :     }
<span class="lineNum">    1877 </span>            : 
<a name="1878"><span class="lineNum">    1878 </span>            : </a>
<span class="lineNum">    1879 </span>            :     /// @return Constant iterator pointer from start of repository
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :     virtual inline const_iterator cbegin(void) const ELPP_FINAL {</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :         return m_list.cbegin();</span>
<span class="lineNum">    1882 </span>            :     }
<a name="1883"><span class="lineNum">    1883 </span>            : </a>
<span class="lineNum">    1884 </span>            :     /// @return End of repository
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :     virtual inline const_iterator cend(void) const ELPP_FINAL {</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :         return m_list.cend();</span>
<span class="lineNum">    1887 </span>            :     }
<a name="1888"><span class="lineNum">    1888 </span>            : </a>
<span class="lineNum">    1889 </span>            :     /// @return Whether or not repository is empty
<span class="lineNum">    1890 </span><span class="lineCov">          4 :     virtual inline bool empty(void) const ELPP_FINAL {</span>
<span class="lineNum">    1891 </span><span class="lineCov">          4 :         return m_list.empty();</span>
<span class="lineNum">    1892 </span>            :     }
<a name="1893"><span class="lineNum">    1893 </span>            : </a>
<span class="lineNum">    1894 </span>            :     /// @return Size of repository
<span class="lineNum">    1895 </span><span class="lineCov">         28 :     virtual inline std::size_t size(void) const ELPP_FINAL {</span>
<span class="lineNum">    1896 </span><span class="lineCov">         28 :         return m_list.size();</span>
<span class="lineNum">    1897 </span>            :     }
<a name="1898"><span class="lineNum">    1898 </span>            : </a>
<span class="lineNum">    1899 </span>            :     /// @brief Returns underlying container by reference
<span class="lineNum">    1900 </span><span class="lineCov">      12438 :     virtual inline Container&amp; list(void) ELPP_FINAL {</span>
<span class="lineNum">    1901 </span><span class="lineCov">      12438 :         return m_list;</span>
<span class="lineNum">    1902 </span>            :     }
<a name="1903"><span class="lineNum">    1903 </span>            : </a>
<span class="lineNum">    1904 </span>            :     /// @brief Returns underlying container by constant reference.
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :     virtual inline const Container&amp; list(void) const ELPP_FINAL {</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :         return m_list;</span>
<span class="lineNum">    1907 </span>            :     }
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span>            :     /// @brief Unregisters all the pointers from current repository.
<span class="lineNum">    1910 </span>            :     virtual void unregisterAll(void) = 0;
<span class="lineNum">    1911 </span>            : 
<a name="1912"><span class="lineNum">    1912 </span>            : protected:</a>
<span class="lineNum">    1913 </span>            :     virtual void deepCopy(const AbstractRegistry&lt;T_Ptr, Container&gt;&amp;) = 0;
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :     void reinitDeepCopy(const AbstractRegistry&lt;T_Ptr, Container&gt;&amp; sr) {</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :         unregisterAll();</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :         deepCopy(sr);</span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span>            : private:
<span class="lineNum">    1920 </span>            :     Container m_list;
<span class="lineNum">    1921 </span>            : };
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            : /// @brief A pointer registry mechanism to manage memory and provide search functionalities. (non-predicate version)
<span class="lineNum">    1924 </span>            : ///
<span class="lineNum">    1925 </span>            : /// @detail NOTE: This is thread-unsafe implementation (although it contains lock function, it does not use these functions)
<span class="lineNum">    1926 </span>            : ///         of AbstractRegistry&lt;T_Ptr, Container&gt;. Any implementation of this class should be  
<span class="lineNum">    1927 </span>            : ///         explicitly (by using lock functions)
<span class="lineNum">    1928 </span>            : template &lt;typename T_Ptr, typename T_Key = const char*&gt;
<span class="lineNum">    1929 </span>            : class Registry : public AbstractRegistry&lt;T_Ptr, std::map&lt;T_Key, T_Ptr*&gt;&gt; {
<span class="lineNum">    1930 </span>            : public:
<span class="lineNum">    1931 </span>            :     typedef typename Registry&lt;T_Ptr, T_Key&gt;::iterator iterator;
<a name="1932"><span class="lineNum">    1932 </span>            :     typedef typename Registry&lt;T_Ptr, T_Key&gt;::const_iterator const_iterator;</a>
<span class="lineNum">    1933 </span>            : 
<span class="lineNum">    1934 </span><span class="lineCov">          2 :     Registry(void) {}</span>
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span>            :     /// @brief Copy constructor that is useful for base classes. Try to avoid this constructor, use move constructor.
<span class="lineNum">    1937 </span>            :     Registry(const Registry&amp; sr) : AbstractRegistry&lt;T_Ptr, std::vector&lt;T_Ptr*&gt;&gt;() {
<span class="lineNum">    1938 </span>            :         if (this == &amp;sr) {
<span class="lineNum">    1939 </span>            :             return;
<span class="lineNum">    1940 </span>            :         }
<span class="lineNum">    1941 </span>            :         this-&gt;reinitDeepCopy(sr);
<span class="lineNum">    1942 </span>            :     }
<span class="lineNum">    1943 </span>            : 
<span class="lineNum">    1944 </span>            :     /// @brief Assignment operator that unregisters all the existing registeries and deeply copies each of repo element
<span class="lineNum">    1945 </span>            :     /// @see unregisterAll()
<span class="lineNum">    1946 </span>            :     /// @see deepCopy(const AbstractRegistry&amp;)
<span class="lineNum">    1947 </span>            :     Registry&amp; operator=(const Registry&amp; sr) {
<span class="lineNum">    1948 </span>            :         if (this == &amp;sr) {
<span class="lineNum">    1949 </span>            :             return *this;
<span class="lineNum">    1950 </span>            :         }
<span class="lineNum">    1951 </span>            :         this-&gt;reinitDeepCopy(sr);
<span class="lineNum">    1952 </span>            :         return *this;
<a name="1953"><span class="lineNum">    1953 </span>            :     }</a>
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :     virtual ~Registry(void) {</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :         unregisterAll();</span>
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :     }</span>
<a name="1958"><span class="lineNum">    1958 </span>            : </a>
<span class="lineNum">    1959 </span>            : protected:
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :     virtual inline void unregisterAll(void) ELPP_FINAL {</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :         if (!this-&gt;empty()) {</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :             for (auto&amp;&amp; curr : this-&gt;list()) {</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :                 base::utils::safeDelete(curr.second);</span>
<span class="lineNum">    1964 </span>            :             }
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :             this-&gt;list().clear();</span>
<span class="lineNum">    1966 </span>            :         }
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :     }</span>
<a name="1968"><span class="lineNum">    1968 </span>            : </a>
<span class="lineNum">    1969 </span>            :     /// @brief Registers new registry to repository.
<span class="lineNum">    1970 </span><span class="lineCov">          4 :     virtual inline void registerNew(const T_Key&amp; uniqKey, T_Ptr* ptr) ELPP_FINAL {</span>
<span class="lineNum">    1971 </span><span class="lineCov">          4 :         unregister(uniqKey);</span>
<span class="lineNum">    1972 </span><span class="lineCov">          4 :         this-&gt;list().insert(std::make_pair(uniqKey, ptr));</span>
<span class="lineNum">    1973 </span><span class="lineCov">          4 :     }</span>
<a name="1974"><span class="lineNum">    1974 </span>            : </a>
<span class="lineNum">    1975 </span>            :     /// @brief Unregisters single entry mapped to specified unique key
<span class="lineNum">    1976 </span><span class="lineCov">          4 :     inline void unregister(const T_Key&amp; uniqKey) {</span>
<span class="lineNum">    1977 </span><span class="lineCov">          4 :         T_Ptr* existing = get(uniqKey);</span>
<span class="lineNum">    1978 </span><span class="lineCov">          4 :         if (existing != nullptr) {</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :             base::utils::safeDelete(existing);</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :             this-&gt;list().erase(uniqKey);</span>
<span class="lineNum">    1981 </span>            :         }
<span class="lineNum">    1982 </span><span class="lineCov">          4 :     }</span>
<a name="1983"><span class="lineNum">    1983 </span>            : </a>
<span class="lineNum">    1984 </span>            :     /// @brief Gets pointer from repository. If none found, nullptr is returned.
<span class="lineNum">    1985 </span><span class="lineCov">       1252 :     inline T_Ptr* get(const T_Key&amp; uniqKey) {</span>
<span class="lineNum">    1986 </span><span class="lineCov">       1252 :         iterator it = this-&gt;list().find(uniqKey);</span>
<span class="lineNum">    1987 </span><span class="lineCov">       2504 :         return it == this-&gt;list().end()</span>
<span class="lineNum">    1988 </span>            :                 ? nullptr
<span class="lineNum">    1989 </span><span class="lineCov">       2504 :                 : it-&gt;second;</span>
<span class="lineNum">    1990 </span>            :     }
<a name="1991"><span class="lineNum">    1991 </span>            : </a>
<span class="lineNum">    1992 </span>            : private:
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :     virtual inline void deepCopy(const AbstractRegistry&lt;T_Ptr, std::map&lt;T_Key, T_Ptr*&gt;&gt;&amp; sr) ELPP_FINAL {</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :         for (const_iterator it = sr.cbegin(); it != sr.cend(); ++it) {</span>
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :             registerNew(it-&gt;first, new T_Ptr(*it-&gt;second));</span>
<span class="lineNum">    1996 </span>            :         }
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1998 </span>            : };
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span>            : /// @brief A pointer registry mechanism to manage memory and provide search functionalities. (predicate version)
<span class="lineNum">    2001 </span>            : ///
<span class="lineNum">    2002 </span>            : /// @detail NOTE: This is thread-unsafe implementation of AbstractRegistry&lt;T_Ptr, Container&gt;. Any implementation of this class
<span class="lineNum">    2003 </span>            : /// should be made thread-safe explicitly
<span class="lineNum">    2004 </span>            : template &lt;typename T_Ptr, typename Pred&gt;
<span class="lineNum">    2005 </span>            : class RegistryWithPred : public AbstractRegistry&lt;T_Ptr, std::vector&lt;T_Ptr*&gt;&gt; {
<span class="lineNum">    2006 </span>            : public:
<span class="lineNum">    2007 </span>            :     typedef typename RegistryWithPred&lt;T_Ptr, Pred&gt;::iterator iterator;
<a name="2008"><span class="lineNum">    2008 </span>            :     typedef typename RegistryWithPred&lt;T_Ptr, Pred&gt;::const_iterator const_iterator;</a>
<span class="lineNum">    2009 </span>            : 
<span class="lineNum">    2010 </span><span class="lineCov">         12 :     RegistryWithPred(void) {</span>
<a name="2011"><span class="lineNum">    2011 </span><span class="lineCov">         12 :     }</span></a>
<span class="lineNum">    2012 </span>            : 
<span class="lineNum">    2013 </span><span class="lineCov">          4 :     virtual ~RegistryWithPred(void) {</span>
<span class="lineNum">    2014 </span><span class="lineCov">          4 :         unregisterAll();</span>
<span class="lineNum">    2015 </span><span class="lineCov">          8 :     }</span>
<span class="lineNum">    2016 </span>            : 
<span class="lineNum">    2017 </span>            :     /// @brief Copy constructor that is useful for base classes. Try to avoid this constructor, use move constructor.
<span class="lineNum">    2018 </span>            :     RegistryWithPred(const RegistryWithPred&amp; sr) : AbstractRegistry&lt;T_Ptr, std::vector&lt;T_Ptr*&gt;&gt;() {
<span class="lineNum">    2019 </span>            :         if (this == &amp;sr) {
<span class="lineNum">    2020 </span>            :             return;
<span class="lineNum">    2021 </span>            :         }
<span class="lineNum">    2022 </span>            :         this-&gt;reinitDeepCopy(sr);
<span class="lineNum">    2023 </span>            :     }
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span>            :     /// @brief Assignment operator that unregisters all the existing registeries and deeply copies each of repo element
<a name="2026"><span class="lineNum">    2026 </span>            :     /// @see unregisterAll()</a>
<span class="lineNum">    2027 </span>            :     /// @see deepCopy(const AbstractRegistry&amp;)
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :     RegistryWithPred&amp; operator=(const RegistryWithPred&amp; sr) {</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :         if (this == &amp;sr) {</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :             return *this;</span>
<span class="lineNum">    2031 </span>            :         }
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :         this-&gt;reinitDeepCopy(sr);</span>
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :         return *this;</span>
<span class="lineNum">    2034 </span>            :     }
<span class="lineNum">    2035 </span>            : 
<span class="lineNum">    2036 </span>            :     friend inline base::type::ostream_t&amp; operator&lt;&lt;(base::type::ostream_t&amp; os, const RegistryWithPred&amp; sr) {
<span class="lineNum">    2037 </span>            :         for (const_iterator it = sr.list().begin(); it != sr.list().end(); ++it) {
<span class="lineNum">    2038 </span>            :             os &lt;&lt; ELPP_LITERAL(&quot;    &quot;) &lt;&lt; **it &lt;&lt; ELPP_LITERAL(&quot;\n&quot;);
<span class="lineNum">    2039 </span>            :         }
<span class="lineNum">    2040 </span>            :         return os;
<span class="lineNum">    2041 </span>            :     }
<a name="2042"><span class="lineNum">    2042 </span>            : </a>
<span class="lineNum">    2043 </span>            : protected:
<span class="lineNum">    2044 </span><span class="lineCov">          4 :     virtual inline void unregisterAll(void) ELPP_FINAL {</span>
<span class="lineNum">    2045 </span><span class="lineCov">          4 :         if (!this-&gt;empty()) {</span>
<span class="lineNum">    2046 </span><span class="lineCov">        260 :             for (auto&amp;&amp; curr : this-&gt;list()) {</span>
<span class="lineNum">    2047 </span><span class="lineCov">        256 :                 base::utils::safeDelete(curr);</span>
<span class="lineNum">    2048 </span>            :             }
<span class="lineNum">    2049 </span><span class="lineCov">          4 :             this-&gt;list().clear();</span>
<span class="lineNum">    2050 </span>            :         }
<a name="2051"><span class="lineNum">    2051 </span><span class="lineCov">          4 :     }</span></a>
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :     virtual void unregister(T_Ptr*&amp; ptr) ELPP_FINAL {</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :         if (ptr) {</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :             iterator iter = this-&gt;begin();</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :             for (; iter != this-&gt;end(); ++iter) {</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :                 if (ptr == *iter) {</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2059 </span>            :                 }
<span class="lineNum">    2060 </span>            :             }
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :             if (iter != this-&gt;end() &amp;&amp; *iter != nullptr) {</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :                 this-&gt;list().erase(iter);</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :                 base::utils::safeDelete(*iter);</span>
<span class="lineNum">    2064 </span>            :             }
<span class="lineNum">    2065 </span>            :         }
<a name="2066"><span class="lineNum">    2066 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span><span class="lineCov">        688 :     virtual inline void registerNew(T_Ptr* ptr) ELPP_FINAL {</span>
<span class="lineNum">    2069 </span><span class="lineCov">        688 :         this-&gt;list().push_back(ptr);</span>
<span class="lineNum">    2070 </span><span class="lineCov">        688 :     }</span>
<span class="lineNum">    2071 </span>            : 
<span class="lineNum">    2072 </span>            :     /// @brief Gets pointer from repository with speicifed arguments. Arguments are passed to predicate
<a name="2073"><span class="lineNum">    2073 </span>            :     /// in order to validate pointer.</a>
<span class="lineNum">    2074 </span>            :     template &lt;typename T, typename T2&gt;
<span class="lineNum">    2075 </span><span class="lineCov">       3074 :     inline T_Ptr* get(const T&amp; arg1, const T2 arg2) {</span>
<span class="lineNum">    2076 </span><span class="lineCov">       3074 :         iterator iter = std::find_if(this-&gt;list().begin(), this-&gt;list().end(), Pred(arg1, arg2));</span>
<span class="lineNum">    2077 </span><span class="lineCov">       3074 :         if (iter != this-&gt;list().end() &amp;&amp; *iter != nullptr) {</span>
<span class="lineNum">    2078 </span><span class="lineCov">       2370 :             return *iter;</span>
<span class="lineNum">    2079 </span>            :         }
<span class="lineNum">    2080 </span><span class="lineCov">        704 :         return nullptr;</span>
<span class="lineNum">    2081 </span>            :     }
<a name="2082"><span class="lineNum">    2082 </span>            : </a>
<span class="lineNum">    2083 </span>            : private:
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :     virtual inline void deepCopy(const AbstractRegistry&lt;T_Ptr, std::vector&lt;T_Ptr*&gt;&gt;&amp; sr) {</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :         for (const_iterator it = sr.list().begin(); it != sr.list().end(); ++it) {</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :             registerNew(new T_Ptr(**it));</span>
<span class="lineNum">    2087 </span>            :         }
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2089 </span>            : };
<span class="lineNum">    2090 </span>            : 
<span class="lineNum">    2091 </span>            : }  // namespace utils
<span class="lineNum">    2092 </span>            : } // namespace base
<span class="lineNum">    2093 </span>            : /// @brief Base of Easylogging++ friendly class
<a name="2094"><span class="lineNum">    2094 </span>            : ///</a>
<span class="lineNum">    2095 </span>            : /// @detail After inheriting this class publicly, implement pure-virtual function `void log(std::ostream&amp;) const`
<a name="2096"><span class="lineNum">    2096 </span><span class="lineCov">       1028 : class Loggable {</span></a>
<span class="lineNum">    2097 </span>            : public:
<span class="lineNum">    2098 </span><span class="lineCov">        560 :     virtual ~Loggable(void) {}</span>
<a name="2099"><span class="lineNum">    2099 </span>            :     virtual void log(el::base::type::ostream_t&amp;) const = 0;</a>
<span class="lineNum">    2100 </span>            : private:
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :     friend inline el::base::type::ostream_t&amp; operator&lt;&lt;(el::base::type::ostream_t&amp; os, const Loggable&amp; loggable) {</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :         loggable.log(os);</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :         return os;</span>
<span class="lineNum">    2104 </span>            :     }
<span class="lineNum">    2105 </span>            : };
<span class="lineNum">    2106 </span>            : namespace base {
<span class="lineNum">    2107 </span>            : /// @brief Represents log format containing flags and date format. This is used internally to start initial log
<span class="lineNum">    2108 </span>            : class LogFormat : public Loggable {
<span class="lineNum">    2109 </span>            : public:
<span class="lineNum">    2110 </span>            :     LogFormat(void) :
<span class="lineNum">    2111 </span>            :         m_level(Level::Unknown),
<span class="lineNum">    2112 </span>            :         m_userFormat(base::type::string_t()),
<span class="lineNum">    2113 </span>            :         m_format(base::type::string_t()),
<span class="lineNum">    2114 </span>            :         m_dateTimeFormat(std::string()),
<span class="lineNum">    2115 </span>            :         m_flags(0x0) {
<a name="2116"><span class="lineNum">    2116 </span>            :     }</a>
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span><span class="lineCov">        112 :     LogFormat(Level level, const base::type::string_t&amp; format)</span>
<span class="lineNum">    2119 </span><span class="lineCov">        112 :             : m_level(level), m_userFormat(format) {</span>
<span class="lineNum">    2120 </span><span class="lineCov">        112 :         parseFromFormat(m_userFormat);</span>
<a name="2121"><span class="lineNum">    2121 </span><span class="lineCov">        112 :     }</span></a>
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span><span class="lineCov">        112 :     LogFormat(const LogFormat&amp; logFormat) {</span>
<span class="lineNum">    2124 </span><span class="lineCov">        112 :         m_level = logFormat.m_level;</span>
<span class="lineNum">    2125 </span><span class="lineCov">        112 :         m_userFormat = logFormat.m_userFormat;</span>
<span class="lineNum">    2126 </span><span class="lineCov">        112 :         m_format = logFormat.m_format;</span>
<span class="lineNum">    2127 </span><span class="lineCov">        112 :         m_dateTimeFormat = logFormat.m_dateTimeFormat;</span>
<span class="lineNum">    2128 </span><span class="lineCov">        112 :         m_flags = logFormat.m_flags;</span>
<a name="2129"><span class="lineNum">    2129 </span><span class="lineCov">        112 :     }</span></a>
<span class="lineNum">    2130 </span>            : 
<span class="lineNum">    2131 </span><span class="lineCov">        112 :     LogFormat(LogFormat&amp;&amp; logFormat) {</span>
<span class="lineNum">    2132 </span><span class="lineCov">        112 :         m_level = std::move(logFormat.m_level);</span>
<span class="lineNum">    2133 </span><span class="lineCov">        112 :         m_userFormat = std::move(logFormat.m_userFormat);</span>
<span class="lineNum">    2134 </span><span class="lineCov">        112 :         m_format = std::move(logFormat.m_format);</span>
<span class="lineNum">    2135 </span><span class="lineCov">        112 :         m_dateTimeFormat = std::move(logFormat.m_dateTimeFormat);</span>
<span class="lineNum">    2136 </span><span class="lineCov">        112 :         m_flags = std::move(logFormat.m_flags);</span>
<a name="2137"><span class="lineNum">    2137 </span><span class="lineCov">        112 :     }</span></a>
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :     LogFormat&amp; operator=(const LogFormat&amp; logFormat) {</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :         m_level = logFormat.m_level;</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :         m_userFormat = logFormat.m_userFormat;</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :         m_dateTimeFormat = logFormat.m_dateTimeFormat;</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :         m_flags = logFormat.m_flags;</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :         return *this;</span>
<a name="2145"><span class="lineNum">    2145 </span>            :     }</a>
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span><span class="lineCov">        304 :     virtual ~LogFormat(void) {</span>
<a name="2148"><span class="lineNum">    2148 </span><span class="lineCov">        304 :     }</span></a>
<span class="lineNum">    2149 </span>            : 
<span class="lineNum">    2150 </span><span class="lineCov">         98 :     inline bool operator==(const LogFormat&amp; other) {</span>
<span class="lineNum">    2151 </span><span class="lineCov">         98 :         return m_level == other.m_level &amp;&amp; m_userFormat == other.m_userFormat &amp;&amp; m_format == other.m_format &amp;&amp;</span>
<span class="lineNum">    2152 </span><span class="lineCov">         98 :                 m_dateTimeFormat == other.m_dateTimeFormat &amp;&amp; m_flags == other.m_flags;</span>
<span class="lineNum">    2153 </span>            :     }
<span class="lineNum">    2154 </span>            : 
<a name="2155"><span class="lineNum">    2155 </span>            :     /// @brief Updates format to be used while logging.</a>
<span class="lineNum">    2156 </span>            :     /// @param userFormat User provided format
<span class="lineNum">    2157 </span><span class="lineCov">        112 :     void parseFromFormat(const base::type::string_t&amp; userFormat) {</span>
<span class="lineNum">    2158 </span>            :         // We make copy because we will be changing the format
<span class="lineNum">    2159 </span>            :         // i.e, removing user provided date format from original format
<span class="lineNum">    2160 </span>            :         // and then storing it.
<a name="2161"><span class="lineNum">    2161 </span><span class="lineCov">        112 :         base::type::string_t formatCopy = userFormat;</span></a>
<span class="lineNum">    2162 </span><span class="lineCov">        112 :         m_flags = 0x0;</span>
<span class="lineNum">    2163 </span><span class="lineCov">       1568 :         auto conditionalAddFlag = [&amp;](const base::type::char_t* specifier, base::FormatFlags flag) {</span>
<span class="lineNum">    2164 </span><span class="lineCov">       1568 :             std::size_t foundAt = base::type::string_t::npos;</span>
<span class="lineNum">    2165 </span><span class="lineCov">       3534 :             while ((foundAt = formatCopy.find(specifier, foundAt + 1)) != base::type::string_t::npos){</span>
<span class="lineNum">    2166 </span><span class="lineCov">        398 :                 if (foundAt &gt; 0 &amp;&amp; formatCopy[foundAt - 1] == base::consts::kFormatSpecifierChar) {</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :                     if (hasFlag(flag)) {</span>
<span class="lineNum">    2168 </span>            :                         // If we already have flag we remove the escape chars so that '%%' is turned to '%'
<span class="lineNum">    2169 </span>            :                         // even after specifier resolution - this is because we only replaceFirst specifier
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :                         formatCopy.erase(foundAt &gt; 0 ? foundAt - 1 : 0, 1);</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :                         ++foundAt;</span>
<span class="lineNum">    2172 </span>            :                     }
<span class="lineNum">    2173 </span>            :                 } else {
<span class="lineNum">    2174 </span><span class="lineCov">        398 :                     if (!hasFlag(flag)) addFlag(flag);</span>
<span class="lineNum">    2175 </span>            :                 }
<span class="lineNum">    2176 </span>            :             }
<span class="lineNum">    2177 </span><span class="lineCov">       1680 :         };</span>
<span class="lineNum">    2178 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kAppNameFormatSpecifier, base::FormatFlags::AppName);</span>
<span class="lineNum">    2179 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kSeverityLevelFormatSpecifier, base::FormatFlags::Level);</span>
<span class="lineNum">    2180 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kSeverityLevelShortFormatSpecifier, base::FormatFlags::LevelShort);</span>
<span class="lineNum">    2181 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kLoggerIdFormatSpecifier, base::FormatFlags::LoggerId);</span>
<span class="lineNum">    2182 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kThreadIdFormatSpecifier, base::FormatFlags::ThreadId);</span>
<span class="lineNum">    2183 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kLogFileFormatSpecifier, base::FormatFlags::File);</span>
<span class="lineNum">    2184 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kLogFileBaseFormatSpecifier, base::FormatFlags::FileBase);</span>
<span class="lineNum">    2185 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kLogLineFormatSpecifier, base::FormatFlags::Line);</span>
<span class="lineNum">    2186 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kLogLocationFormatSpecifier, base::FormatFlags::Location);</span>
<span class="lineNum">    2187 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kLogFunctionFormatSpecifier, base::FormatFlags::Function);</span>
<span class="lineNum">    2188 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kCurrentUserFormatSpecifier, base::FormatFlags::User);</span>
<span class="lineNum">    2189 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kCurrentHostFormatSpecifier, base::FormatFlags::Host);</span>
<span class="lineNum">    2190 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kMessageFormatSpecifier, base::FormatFlags::LogMessage);</span>
<span class="lineNum">    2191 </span><span class="lineCov">        112 :         conditionalAddFlag(base::consts::kVerboseLevelFormatSpecifier, base::FormatFlags::VerboseLevel);</span>
<span class="lineNum">    2192 </span>            :         // For date/time we need to extract user's date format first
<span class="lineNum">    2193 </span><span class="lineCov">        112 :         std::size_t dateIndex = std::string::npos;</span>
<span class="lineNum">    2194 </span><span class="lineCov">        112 :         if ((dateIndex = formatCopy.find(base::consts::kDateTimeFormatSpecifier)) != std::string::npos) {</span>
<span class="lineNum">    2195 </span><span class="lineCov">        224 :             while (dateIndex &gt; 0 &amp;&amp; formatCopy[dateIndex - 1] == base::consts::kFormatSpecifierChar) {</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :                 dateIndex = formatCopy.find(base::consts::kDateTimeFormatSpecifier, dateIndex + 1);</span>
<span class="lineNum">    2197 </span>            :             }
<span class="lineNum">    2198 </span><span class="lineCov">        112 :             if (dateIndex != std::string::npos) {</span>
<span class="lineNum">    2199 </span><span class="lineCov">        112 :                 addFlag(base::FormatFlags::DateTime);</span>
<span class="lineNum">    2200 </span><span class="lineCov">        112 :                 updateDateFormat(dateIndex, formatCopy);</span>
<span class="lineNum">    2201 </span>            :             }
<span class="lineNum">    2202 </span>            :         }
<span class="lineNum">    2203 </span><span class="lineCov">        112 :         m_format = formatCopy;</span>
<span class="lineNum">    2204 </span><span class="lineCov">        112 :         updateFormatSpec();</span>
<span class="lineNum">    2205 </span><span class="lineCov">        112 :     }</span>
<span class="lineNum">    2206 </span>            : 
<span class="lineNum">    2207 </span>            :     inline Level level(void) const {
<span class="lineNum">    2208 </span>            :         return m_level;
<span class="lineNum">    2209 </span>            :     }
<span class="lineNum">    2210 </span>            : 
<span class="lineNum">    2211 </span>            :     inline const base::type::string_t&amp; userFormat(void) const {
<span class="lineNum">    2212 </span>            :         return m_userFormat;
<a name="2213"><span class="lineNum">    2213 </span>            :     }</a>
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span><span class="lineCov">       1244 :     inline const base::type::string_t&amp; format(void) const {</span>
<span class="lineNum">    2216 </span><span class="lineCov">       1244 :        return m_format;</span>
<a name="2217"><span class="lineNum">    2217 </span>            :     }</a>
<span class="lineNum">    2218 </span>            : 
<span class="lineNum">    2219 </span><span class="lineCov">       1244 :     inline const std::string&amp; dateTimeFormat(void) const {</span>
<span class="lineNum">    2220 </span><span class="lineCov">       1244 :        return m_dateTimeFormat;</span>
<span class="lineNum">    2221 </span>            :     }
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span>            :     inline base::type::EnumType flags(void) const {
<span class="lineNum">    2224 </span>            :        return m_flags;
<a name="2225"><span class="lineNum">    2225 </span>            :     }</a>
<span class="lineNum">    2226 </span>            : 
<span class="lineNum">    2227 </span><span class="lineCov">      11978 :     inline bool hasFlag(base::FormatFlags flag) const {</span>
<span class="lineNum">    2228 </span><span class="lineCov">      11978 :         return base::utils::hasFlag(flag, m_flags);</span>
<a name="2229"><span class="lineNum">    2229 </span>            :     }</a>
<span class="lineNum">    2230 </span>            : 
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :     virtual void log(el::base::type::ostream_t&amp; os) const {</span>
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :         os &lt;&lt; m_format;</span>
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2234 </span>            : 
<span class="lineNum">    2235 </span>            : protected:
<span class="lineNum">    2236 </span>            :     /// @brief Updates date time format if available in currFormat.
<a name="2237"><span class="lineNum">    2237 </span>            :     /// @param index Index where %datetime, %date or %time was found</a>
<span class="lineNum">    2238 </span>            :     /// @param [in,out] currFormat current format that is being used to format
<span class="lineNum">    2239 </span><span class="lineCov">        112 :     virtual void updateDateFormat(std::size_t index, base::type::string_t&amp; currFormat) ELPP_FINAL {</span>
<span class="lineNum">    2240 </span><span class="lineCov">        112 :         if (hasFlag(base::FormatFlags::DateTime)) {</span>
<span class="lineNum">    2241 </span><span class="lineCov">        112 :             index += ELPP_STRLEN(base::consts::kDateTimeFormatSpecifier);</span>
<span class="lineNum">    2242 </span>            :         }
<span class="lineNum">    2243 </span><span class="lineCov">        112 :         const base::type::char_t* ptr = currFormat.c_str() + index;</span>
<span class="lineNum">    2244 </span><span class="lineCov">        112 :         if ((currFormat.size() &gt; index) &amp;&amp; (ptr[0] == '{')) {</span>
<span class="lineNum">    2245 </span>            :             // User has provided format for date/time
<span class="lineNum">    2246 </span><span class="lineCov">         64 :             ++ptr;</span>
<span class="lineNum">    2247 </span><span class="lineCov">         64 :             int count = 1;  // Start by 1 in order to remove starting brace</span>
<span class="lineNum">    2248 </span><span class="lineCov">         64 :             std::stringstream ss;</span>
<span class="lineNum">    2249 </span><span class="lineCov">        576 :             for (; *ptr; ++ptr, ++count) {</span>
<span class="lineNum">    2250 </span><span class="lineCov">        576 :                 if (*ptr == '}') {</span>
<span class="lineNum">    2251 </span><span class="lineCov">         64 :                     ++count;  // In order to remove ending brace</span>
<span class="lineNum">    2252 </span><span class="lineCov">         64 :                     break;</span>
<span class="lineNum">    2253 </span>            :                 }
<span class="lineNum">    2254 </span><span class="lineCov">        512 :                 ss &lt;&lt; *ptr;</span>
<span class="lineNum">    2255 </span>            :             }
<span class="lineNum">    2256 </span><span class="lineCov">         64 :             currFormat.erase(index, count);</span>
<span class="lineNum">    2257 </span><span class="lineCov">         64 :             m_dateTimeFormat = ss.str();</span>
<span class="lineNum">    2258 </span>            :         } else {
<span class="lineNum">    2259 </span>            :             // No format provided, use default
<span class="lineNum">    2260 </span><span class="lineCov">         48 :             if (hasFlag(base::FormatFlags::DateTime)) {</span>
<span class="lineNum">    2261 </span><span class="lineCov">         48 :                 m_dateTimeFormat = std::string(base::consts::kDefaultDateTimeFormat);</span>
<span class="lineNum">    2262 </span>            :             }
<span class="lineNum">    2263 </span>            :         }
<span class="lineNum">    2264 </span><span class="lineCov">        112 :     }</span>
<a name="2265"><span class="lineNum">    2265 </span>            : </a>
<span class="lineNum">    2266 </span>            :     /// @brief Updates %level from format. This is so that we dont have to do it at log-writing-time. It uses m_format and m_level
<span class="lineNum">    2267 </span><span class="lineCov">        112 :     virtual void updateFormatSpec(void) ELPP_FINAL {</span>
<span class="lineNum">    2268 </span>            :         // Do not use switch over strongly typed enums because Intel C++ compilers dont support them yet.
<span class="lineNum">    2269 </span><span class="lineCov">        112 :         if (m_level == Level::Debug) {</span>
<span class="lineNum">    2270 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<span class="lineNum">    2271 </span><span class="lineCov">         14 :                     base::consts::kDebugLevelLogValue);</span>
<span class="lineNum">    2272 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<span class="lineNum">    2273 </span><span class="lineCov">         14 :                     base::consts::kDebugLevelShortLogValue);</span>
<span class="lineNum">    2274 </span><span class="lineCov">         98 :         } else if (m_level == Level::Info) {</span>
<span class="lineNum">    2275 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<span class="lineNum">    2276 </span><span class="lineCov">         14 :                     base::consts::kInfoLevelLogValue);</span>
<span class="lineNum">    2277 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<span class="lineNum">    2278 </span><span class="lineCov">         14 :                     base::consts::kInfoLevelShortLogValue);</span>
<span class="lineNum">    2279 </span><span class="lineCov">         84 :         } else if (m_level == Level::Warning) {</span>
<span class="lineNum">    2280 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<span class="lineNum">    2281 </span><span class="lineCov">         14 :                     base::consts::kWarningLevelLogValue);</span>
<span class="lineNum">    2282 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<span class="lineNum">    2283 </span><span class="lineCov">         14 :                     base::consts::kWarningLevelShortLogValue);</span>
<span class="lineNum">    2284 </span><span class="lineCov">         70 :         } else if (m_level == Level::Error) {</span>
<span class="lineNum">    2285 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<span class="lineNum">    2286 </span><span class="lineCov">         14 :                     base::consts::kErrorLevelLogValue);</span>
<span class="lineNum">    2287 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<span class="lineNum">    2288 </span><span class="lineCov">         14 :                     base::consts::kErrorLevelShortLogValue);</span>
<span class="lineNum">    2289 </span><span class="lineCov">         56 :         } else if (m_level == Level::Fatal) {</span>
<span class="lineNum">    2290 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<span class="lineNum">    2291 </span><span class="lineCov">         14 :                     base::consts::kFatalLevelLogValue);</span>
<span class="lineNum">    2292 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<span class="lineNum">    2293 </span><span class="lineCov">         14 :                     base::consts::kFatalLevelShortLogValue);</span>
<span class="lineNum">    2294 </span><span class="lineCov">         42 :         } else if (m_level == Level::Verbose) {</span>
<span class="lineNum">    2295 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<span class="lineNum">    2296 </span><span class="lineCov">         14 :                     base::consts::kVerboseLevelLogValue);</span>
<span class="lineNum">    2297 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<span class="lineNum">    2298 </span><span class="lineCov">         14 :                     base::consts::kVerboseLevelShortLogValue);</span>
<span class="lineNum">    2299 </span><span class="lineCov">         28 :         } else if (m_level == Level::Trace) {</span>
<span class="lineNum">    2300 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelFormatSpecifier,
<span class="lineNum">    2301 </span><span class="lineCov">         14 :                     base::consts::kTraceLevelLogValue);</span>
<span class="lineNum">    2302 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kSeverityLevelShortFormatSpecifier,
<span class="lineNum">    2303 </span><span class="lineCov">         14 :                     base::consts::kTraceLevelShortLogValue);</span>
<span class="lineNum">    2304 </span>            :         }
<span class="lineNum">    2305 </span><span class="lineCov">        112 :         if (hasFlag(base::FormatFlags::User)) {</span>
<span class="lineNum">    2306 </span><span class="lineCov">          4 :             std::string s = base::utils::s_currentUser;</span>
<span class="lineNum">    2307 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kCurrentUserFormatSpecifier,
<span class="lineNum">    2308 </span><span class="lineCov">          4 :                     base::utils::s_currentUser);</span>
<span class="lineNum">    2309 </span>            :         }
<span class="lineNum">    2310 </span><span class="lineCov">        112 :         if (hasFlag(base::FormatFlags::Host)) {</span>
<span class="lineNum">    2311 </span>            :             base::utils::Str::replaceFirstWithEscape(m_format, base::consts::kCurrentHostFormatSpecifier,
<span class="lineNum">    2312 </span><span class="lineCov">          4 :                     base::utils::s_currentHost);</span>
<span class="lineNum">    2313 </span>            :         }
<span class="lineNum">    2314 </span>            :         // Ignore Level::Global and Level::Unknown
<a name="2315"><span class="lineNum">    2315 </span><span class="lineCov">        112 :     }</span></a>
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span><span class="lineCov">        510 :     inline void addFlag(base::FormatFlags flag) {</span>
<span class="lineNum">    2318 </span><span class="lineCov">        510 :         base::utils::addFlag(flag, &amp;m_flags);</span>
<span class="lineNum">    2319 </span><span class="lineCov">        510 :     }</span>
<span class="lineNum">    2320 </span>            : 
<span class="lineNum">    2321 </span>            : private:
<span class="lineNum">    2322 </span>            :     Level m_level;
<span class="lineNum">    2323 </span>            :     base::type::string_t m_userFormat;
<span class="lineNum">    2324 </span>            :     base::type::string_t m_format;
<span class="lineNum">    2325 </span>            :     std::string m_dateTimeFormat;
<span class="lineNum">    2326 </span>            :     base::type::EnumType m_flags;
<span class="lineNum">    2327 </span>            :     friend class el::Logger;  // To resolve loggerId format specifier easily
<span class="lineNum">    2328 </span>            : };
<span class="lineNum">    2329 </span>            : }  // namespace base
<span class="lineNum">    2330 </span>            : /// @brief Resolving function for format specifier
<span class="lineNum">    2331 </span>            : typedef std::function&lt;const char*(void)&gt; FormatSpecifierValueResolver;
<span class="lineNum">    2332 </span>            : /// @brief User-provided custom format specifier
<a name="2333"><span class="lineNum">    2333 </span>            : /// @see el::Helpers::installCustomFormatSpecifier</a>
<span class="lineNum">    2334 </span>            : /// @see FormatSpecifierValueResolver
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 : class CustomFormatSpecifier {</span>
<span class="lineNum">    2336 </span>            : public:
<a name="2337"><span class="lineNum">    2337 </span>            :     CustomFormatSpecifier(const char* formatSpecifier, const FormatSpecifierValueResolver&amp; resolver) :</a>
<a name="2338"><span class="lineNum">    2338 </span>            :         m_formatSpecifier(formatSpecifier), m_resolver(resolver) {}</a>
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :     inline const char* formatSpecifier(void) const { return m_formatSpecifier; }</span>
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :     inline const FormatSpecifierValueResolver&amp; resolver(void) const { return m_resolver; }</span>
<span class="lineNum">    2341 </span>            :     inline bool operator==(const char* formatSpecifier) {
<span class="lineNum">    2342 </span>            :         return strcmp(m_formatSpecifier, formatSpecifier) == 0;
<span class="lineNum">    2343 </span>            :     }
<span class="lineNum">    2344 </span>            : 
<span class="lineNum">    2345 </span>            : private:
<span class="lineNum">    2346 </span>            :     const char* m_formatSpecifier;
<span class="lineNum">    2347 </span>            :     FormatSpecifierValueResolver m_resolver;
<span class="lineNum">    2348 </span>            : };
<span class="lineNum">    2349 </span>            : /// @brief Represents single configuration that has representing level, configuration type and a string based value.
<span class="lineNum">    2350 </span>            : ///
<span class="lineNum">    2351 </span>            : /// @detail String based value means any value either its boolean, integer or string itself, it will be embedded inside quotes
<span class="lineNum">    2352 </span>            : /// and will be parsed later.
<span class="lineNum">    2353 </span>            : ///
<span class="lineNum">    2354 </span>            : /// Consider some examples below:
<span class="lineNum">    2355 </span>            : ///   * el::Configuration confEnabledInfo(el::Level::Info, el::ConfigurationType::Enabled, &quot;true&quot;);
<span class="lineNum">    2356 </span>            : ///   * el::Configuration confMaxLogFileSizeInfo(el::Level::Info, el::ConfigurationType::MaxLogFileSize, &quot;2048&quot;);
<span class="lineNum">    2357 </span>            : ///   * el::Configuration confFilenameInfo(el::Level::Info, el::ConfigurationType::Filename, &quot;/var/log/my.log&quot;);
<a name="2358"><span class="lineNum">    2358 </span>            : class Configuration : public Loggable {</a>
<span class="lineNum">    2359 </span>            : public:
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :     Configuration(const Configuration&amp; c) :</span>
<span class="lineNum">    2361 </span>            :             m_level(c.m_level),
<span class="lineNum">    2362 </span>            :             m_configurationType(c.m_configurationType),
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :             m_value(c.m_value) {</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2365 </span>            : 
<span class="lineNum">    2366 </span>            :     Configuration&amp; operator=(const Configuration&amp; c) {
<span class="lineNum">    2367 </span>            :         m_level = c.m_level;
<span class="lineNum">    2368 </span>            :         m_configurationType = c.m_configurationType;
<span class="lineNum">    2369 </span>            :         m_value = c.m_value;
<span class="lineNum">    2370 </span>            :         return *this;
<a name="2371"><span class="lineNum">    2371 </span>            :     }</a>
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span><span class="lineCov">        512 :     virtual ~Configuration(void) {</span>
<span class="lineNum">    2374 </span><span class="lineCov">        512 :     }</span>
<a name="2375"><span class="lineNum">    2375 </span>            : </a>
<span class="lineNum">    2376 </span>            :     /// @brief Full constructor used to sets value of configuration
<span class="lineNum">    2377 </span><span class="lineCov">        688 :     Configuration(Level level, ConfigurationType configurationType, const std::string&amp; value) :</span>
<span class="lineNum">    2378 </span>            :         m_level(level),
<span class="lineNum">    2379 </span>            :         m_configurationType(configurationType),
<span class="lineNum">    2380 </span><span class="lineCov">        688 :         m_value(value) {</span>
<span class="lineNum">    2381 </span><span class="lineCov">        688 :     }</span>
<a name="2382"><span class="lineNum">    2382 </span>            : </a>
<span class="lineNum">    2383 </span>            :     /// @brief Gets level of current configuration
<span class="lineNum">    2384 </span><span class="lineCov">     106050 :     inline Level level(void) const {</span>
<span class="lineNum">    2385 </span><span class="lineCov">     106050 :         return m_level;</span>
<span class="lineNum">    2386 </span>            :     }
<a name="2387"><span class="lineNum">    2387 </span>            : </a>
<span class="lineNum">    2388 </span>            :     /// @brief Gets configuration type of current configuration
<span class="lineNum">    2389 </span><span class="lineCov">      20512 :     inline ConfigurationType configurationType(void) const {</span>
<span class="lineNum">    2390 </span><span class="lineCov">      20512 :         return m_configurationType;</span>
<span class="lineNum">    2391 </span>            :     }
<a name="2392"><span class="lineNum">    2392 </span>            : </a>
<span class="lineNum">    2393 </span>            :     /// @brief Gets string based configuration value
<span class="lineNum">    2394 </span><span class="lineCov">       1920 :     inline const std::string&amp; value(void) const {</span>
<span class="lineNum">    2395 </span><span class="lineCov">       1920 :         return m_value;</span>
<span class="lineNum">    2396 </span>            :     }
<span class="lineNum">    2397 </span>            : 
<span class="lineNum">    2398 </span>            :     /// @brief Set string based configuration value
<a name="2399"><span class="lineNum">    2399 </span>            :     /// @param value Value to set. Values have to be std::string; For boolean values use &quot;true&quot;, &quot;false&quot;, for any integral values</a>
<span class="lineNum">    2400 </span>            :     ///        use them in quotes. They will be parsed when configuring
<span class="lineNum">    2401 </span><span class="lineCov">       2324 :     inline void setValue(const std::string&amp; value) {</span>
<span class="lineNum">    2402 </span><span class="lineCov">       2324 :         m_value = value;</span>
<a name="2403"><span class="lineNum">    2403 </span><span class="lineCov">       2324 :     }</span></a>
<span class="lineNum">    2404 </span>            : 
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :     virtual inline void log(el::base::type::ostream_t&amp; os) const {</span>
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :         os &lt;&lt; LevelHelper::convertToString(m_level)</span>
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :             &lt;&lt; ELPP_LITERAL(&quot; &quot;) &lt;&lt; ConfigurationTypeHelper::convertToString(m_configurationType)</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :             &lt;&lt; ELPP_LITERAL(&quot; = &quot;) &lt;&lt; m_value.c_str();</span>
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2410 </span>            : 
<span class="lineNum">    2411 </span>            :     /// @brief Used to find configuration from configuration (pointers) repository. Avoid using it.
<a name="2412"><span class="lineNum">    2412 </span>            :     class Predicate {</a>
<span class="lineNum">    2413 </span>            :     public:
<span class="lineNum">    2414 </span><span class="lineCov">       3074 :         Predicate(Level level, ConfigurationType configurationType) :</span>
<span class="lineNum">    2415 </span>            :             m_level(level),
<span class="lineNum">    2416 </span><span class="lineCov">       3074 :             m_configurationType(configurationType) {</span>
<a name="2417"><span class="lineNum">    2417 </span><span class="lineCov">       3074 :         }</span></a>
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span><span class="lineCov">     104242 :         inline bool operator()(const Configuration* conf) const {</span>
<span class="lineNum">    2420 </span><span class="lineCov">     104242 :             return ((conf != nullptr) &amp;&amp; (conf-&gt;level() == m_level) &amp;&amp; (conf-&gt;configurationType() == m_configurationType));</span>
<span class="lineNum">    2421 </span>            :         }
<span class="lineNum">    2422 </span>            : 
<span class="lineNum">    2423 </span>            :     private:
<span class="lineNum">    2424 </span>            :         Level m_level;
<span class="lineNum">    2425 </span>            :         ConfigurationType m_configurationType;
<span class="lineNum">    2426 </span>            :     };
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span>            : private:
<span class="lineNum">    2429 </span>            :     Level m_level;
<span class="lineNum">    2430 </span>            :     ConfigurationType m_configurationType;
<span class="lineNum">    2431 </span>            :     std::string m_value;
<span class="lineNum">    2432 </span>            : };
<span class="lineNum">    2433 </span>            : 
<span class="lineNum">    2434 </span>            : /// @brief Thread-safe Configuration repository
<a name="2435"><span class="lineNum">    2435 </span>            : ///</a>
<span class="lineNum">    2436 </span>            : /// @detail This repository represents configurations for all the levels and configuration type mapped to a value.
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 : class Configurations : public base::utils::RegistryWithPred&lt;Configuration, Configuration::Predicate&gt; {</span>
<a name="2438"><span class="lineNum">    2438 </span>            : public:</a>
<span class="lineNum">    2439 </span>            :     /// @brief Default constructor with empty repository
<span class="lineNum">    2440 </span><span class="lineCov">          6 :     Configurations(void) :</span>
<span class="lineNum">    2441 </span>            :             m_configurationFile(std::string()),
<span class="lineNum">    2442 </span><span class="lineCov">          6 :             m_isFromFile(false) {</span>
<span class="lineNum">    2443 </span><span class="lineCov">          6 :     }</span>
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span>            :     /// @brief Constructor used to set configurations using configuration file.
<span class="lineNum">    2446 </span>            :     /// @param configurationFile Full path to configuration file
<span class="lineNum">    2447 </span>            :     /// @param useDefaultsForRemaining Lets you set the remaining configurations to default.
<span class="lineNum">    2448 </span>            :     /// @param base If provided, this configuration will be based off existing repository that this argument is pointing to.
<a name="2449"><span class="lineNum">    2449 </span>            :     /// @see parseFromFile(const std::string&amp;, Configurations* base)</a>
<span class="lineNum">    2450 </span>            :     /// @see setRemainingToDefault()
<span class="lineNum">    2451 </span><span class="lineCov">         12 :     Configurations(const std::string&amp; configurationFile, bool useDefaultsForRemaining = true, Configurations* base = nullptr) :</span>
<span class="lineNum">    2452 </span>            :             m_configurationFile(configurationFile),
<span class="lineNum">    2453 </span><span class="lineCov">         12 :             m_isFromFile(false) {</span>
<span class="lineNum">    2454 </span><span class="lineCov">         12 :         parseFromFile(configurationFile, base);</span>
<span class="lineNum">    2455 </span><span class="lineCov">         12 :         if (useDefaultsForRemaining) {</span>
<span class="lineNum">    2456 </span><span class="lineCov">         12 :             setRemainingToDefault();</span>
<span class="lineNum">    2457 </span>            :         }
<a name="2458"><span class="lineNum">    2458 </span><span class="lineCov">         12 :     }</span></a>
<span class="lineNum">    2459 </span>            : 
<span class="lineNum">    2460 </span><span class="lineCov">          4 :     virtual ~Configurations(void) {</span>
<span class="lineNum">    2461 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span>            :     /// @brief Parses configuration from file.
<span class="lineNum">    2464 </span>            :     /// @param configurationFile Full path to configuration file
<span class="lineNum">    2465 </span>            :     /// @param base Configurations to base new configuration repository off. This value is used when you want to use
<span class="lineNum">    2466 </span>            :     ///        existing Configurations to base all the values and then set rest of configuration via configuration file.
<a name="2467"><span class="lineNum">    2467 </span>            :     /// @return True if successfully parsed, false otherwise. You may define 'ELPP_DEBUG_ASSERT_FAILURE' to make sure you</a>
<span class="lineNum">    2468 </span>            :     ///         do not proceed without successful parse.
<span class="lineNum">    2469 </span><span class="lineCov">         12 :     inline bool parseFromFile(const std::string&amp; configurationFile, Configurations* base = nullptr) {</span>
<span class="lineNum">    2470 </span>            :         // We initial assertion with true because if we have assertion diabled, we want to pass this
<span class="lineNum">    2471 </span>            :         // check and if assertion is enabled we will have values re-assigned any way.
<span class="lineNum">    2472 </span><span class="lineCov">         12 :         bool assertionPassed = true;</span>
<span class="lineNum">    2473 </span><span class="lineCov">         12 :         ELPP_ASSERT((assertionPassed = base::utils::File::pathExists(configurationFile.c_str(), true)),</span>
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :                 &quot;Configuration file [&quot; &lt;&lt; configurationFile &lt;&lt; &quot;] does not exist!&quot;);</span>
<span class="lineNum">    2475 </span><span class="lineCov">         12 :         if (!assertionPassed) {</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2477 </span>            :         }
<span class="lineNum">    2478 </span><span class="lineCov">         12 :         bool success = Parser::parseFromFile(configurationFile, this, base);</span>
<span class="lineNum">    2479 </span><span class="lineCov">         12 :         m_isFromFile = success;</span>
<span class="lineNum">    2480 </span><span class="lineCov">         12 :         return success;</span>
<span class="lineNum">    2481 </span>            :     }
<span class="lineNum">    2482 </span>            : 
<span class="lineNum">    2483 </span>            :     /// @brief Parse configurations from configuration string.
<span class="lineNum">    2484 </span>            :     ///
<span class="lineNum">    2485 </span>            :     /// @detail This configuration string has same syntax as configuration file contents. Make sure all the necessary
<span class="lineNum">    2486 </span>            :     /// new line characters are provided.
<span class="lineNum">    2487 </span>            :     /// @param base Configurations to base new configuration repository off. This value is used when you want to use
<span class="lineNum">    2488 </span>            :     ///        existing Configurations to base all the values and then set rest of configuration via configuration text.
<span class="lineNum">    2489 </span>            :     /// @return True if successfully parsed, false otherwise. You may define 'ELPP_DEBUG_ASSERT_FAILURE' to make sure you
<span class="lineNum">    2490 </span>            :     ///         do not proceed without successful parse.
<span class="lineNum">    2491 </span>            :     inline bool parseFromText(const std::string&amp; configurationsString, Configurations* base = nullptr) {
<span class="lineNum">    2492 </span>            :         bool success = Parser::parseFromText(configurationsString, this, base);
<span class="lineNum">    2493 </span>            :         if (success) {
<span class="lineNum">    2494 </span>            :             m_isFromFile = false;
<span class="lineNum">    2495 </span>            :         }
<span class="lineNum">    2496 </span>            :         return success;
<span class="lineNum">    2497 </span>            :     }
<span class="lineNum">    2498 </span>            : 
<a name="2499"><span class="lineNum">    2499 </span>            :     /// @brief Sets configuration based-off an existing configurations.</a>
<span class="lineNum">    2500 </span>            :     /// @param base Pointer to existing configurations.
<span class="lineNum">    2501 </span><span class="lineCov">         16 :     inline void setFromBase(Configurations* base) {</span>
<span class="lineNum">    2502 </span><span class="lineCov">         16 :         if (base == nullptr || base == this) {</span>
<span class="lineNum">    2503 </span><span class="lineCov">         20 :             return;</span>
<span class="lineNum">    2504 </span>            :         }
<span class="lineNum">    2505 </span><span class="lineCov">         12 :         base::threading::ScopedLock scopedLock(base-&gt;lock());</span>
<span class="lineNum">    2506 </span><span class="lineCov">        812 :         for (Configuration*&amp; conf : base-&gt;list()) {</span>
<span class="lineNum">    2507 </span><span class="lineCov">        800 :             set(conf);</span>
<span class="lineNum">    2508 </span><span class="lineCov">         12 :         }</span>
<span class="lineNum">    2509 </span>            :     }
<span class="lineNum">    2510 </span>            : 
<span class="lineNum">    2511 </span>            :     /// @brief Determines whether or not specified configuration type exists in the repository.
<span class="lineNum">    2512 </span>            :     ///
<span class="lineNum">    2513 </span>            :     /// @detail Returns as soon as first level is found.
<span class="lineNum">    2514 </span>            :     /// @param configurationType Type of configuration to check existence for.
<span class="lineNum">    2515 </span>            :     bool hasConfiguration(ConfigurationType configurationType) {
<span class="lineNum">    2516 </span>            :         base::type::EnumType lIndex = LevelHelper::kMinValid;
<span class="lineNum">    2517 </span>            :         bool result = false;
<span class="lineNum">    2518 </span>            :         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](void) -&gt; bool {
<span class="lineNum">    2519 </span>            :             if (hasConfiguration(LevelHelper::castFromInt(lIndex), configurationType)) {
<span class="lineNum">    2520 </span>            :                 result = true;
<span class="lineNum">    2521 </span>            :             }
<span class="lineNum">    2522 </span>            :             return result;
<span class="lineNum">    2523 </span>            :         });
<span class="lineNum">    2524 </span>            :         return result;
<span class="lineNum">    2525 </span>            :     }
<span class="lineNum">    2526 </span>            : 
<span class="lineNum">    2527 </span>            :     /// @brief Determines whether or not specified configuration type exists for specified level
<a name="2528"><span class="lineNum">    2528 </span>            :     /// @param level Level to check</a>
<span class="lineNum">    2529 </span>            :     /// @param configurationType Type of configuration to check existence for.
<span class="lineNum">    2530 </span><span class="lineCov">         10 :     inline bool hasConfiguration(Level level, ConfigurationType configurationType) {</span>
<span class="lineNum">    2531 </span><span class="lineCov">         10 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    2532 </span>            : #if ELPP_COMPILER_INTEL
<span class="lineNum">    2533 </span>            :         // We cant specify template types here, Intel C++ throws compilation error
<span class="lineNum">    2534 </span>            :         // &quot;error: type name is not allowed&quot;
<span class="lineNum">    2535 </span>            :         return RegistryWithPred::get(level, configurationType) != nullptr;
<span class="lineNum">    2536 </span>            : #else
<span class="lineNum">    2537 </span><span class="lineCov">         10 :         return RegistryWithPred&lt;Configuration, Configuration::Predicate&gt;::get(level, configurationType) != nullptr;</span>
<span class="lineNum">    2538 </span>            : #endif  // ELPP_COMPILER_INTEL
<span class="lineNum">    2539 </span>            :     }
<span class="lineNum">    2540 </span>            : 
<span class="lineNum">    2541 </span>            :     /// @brief Sets value of configuration for specified level.
<span class="lineNum">    2542 </span>            :     ///
<span class="lineNum">    2543 </span>            :     /// @detail Any existing configuration for specified level will be replaced. Also note that configuration types
<span class="lineNum">    2544 </span>            :     /// ConfigurationType::MillisecondsWidth and ConfigurationType::PerformanceTracking will be ignored if not set for
<span class="lineNum">    2545 </span>            :     /// Level::Global because these configurations are not dependant on level.
<span class="lineNum">    2546 </span>            :     /// @param level Level to set configuration for (el::Level).
<span class="lineNum">    2547 </span>            :     /// @param configurationType Type of configuration (el::ConfigurationType)
<span class="lineNum">    2548 </span>            :     /// @param value A string based value. Regardless of what the data type of configuration is, it will always be string
<span class="lineNum">    2549 </span>            :     /// from users' point of view. This is then parsed later to be used internally.
<span class="lineNum">    2550 </span>            :     /// @see Configuration::setValue(const std::string&amp; value)
<a name="2551"><span class="lineNum">    2551 </span>            :     /// @see el::Level</a>
<span class="lineNum">    2552 </span>            :     /// @see el::ConfigurationType
<span class="lineNum">    2553 </span><span class="lineCov">       1008 :     inline void set(Level level, ConfigurationType configurationType, const std::string&amp; value) {</span>
<span class="lineNum">    2554 </span><span class="lineCov">       1008 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    2555 </span><span class="lineCov">       1008 :         unsafeSet(level, configurationType, value);  // This is not unsafe anymore as we have locked mutex</span>
<span class="lineNum">    2556 </span><span class="lineCov">       1008 :         if (level == Level::Global) {</span>
<span class="lineNum">    2557 </span><span class="lineCov">        134 :             unsafeSetGlobally(configurationType, value, false);  // Again this is not unsafe either</span>
<span class="lineNum">    2558 </span><span class="lineCov">       1008 :         }</span>
<span class="lineNum">    2559 </span><span class="lineCov">       1008 :     }</span>
<span class="lineNum">    2560 </span>            : 
<a name="2561"><span class="lineNum">    2561 </span>            :     /// @brief Sets single configuration based on other single configuration.</a>
<span class="lineNum">    2562 </span>            :     /// @see set(Level level, ConfigurationType configurationType, const std::string&amp; value)
<span class="lineNum">    2563 </span><span class="lineCov">        800 :     inline void set(Configuration* conf) {</span>
<span class="lineNum">    2564 </span><span class="lineCov">        800 :         if (conf == nullptr) {</span>
<span class="lineNum">    2565 </span><span class="lineCov">        800 :             return;</span>
<span class="lineNum">    2566 </span>            :         }
<span class="lineNum">    2567 </span><span class="lineCov">        800 :         set(conf-&gt;level(), conf-&gt;configurationType(), conf-&gt;value());</span>
<span class="lineNum">    2568 </span>            :     }
<span class="lineNum">    2569 </span>            : 
<span class="lineNum">    2570 </span>            :     inline Configuration* get(Level level, ConfigurationType configurationType) {
<span class="lineNum">    2571 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    2572 </span>            :         return RegistryWithPred&lt;Configuration, Configuration::Predicate&gt;::get(level, configurationType);
<span class="lineNum">    2573 </span>            :     }
<span class="lineNum">    2574 </span>            : 
<span class="lineNum">    2575 </span>            :     /// @brief Sets configuration for all levels.
<span class="lineNum">    2576 </span>            :     /// @param configurationType Type of configuration
<a name="2577"><span class="lineNum">    2577 </span>            :     /// @param value String based value</a>
<span class="lineNum">    2578 </span>            :     /// @see Configurations::set(Level level, ConfigurationType configurationType, const std::string&amp; value)
<span class="lineNum">    2579 </span><span class="lineCov">          2 :     inline void setGlobally(ConfigurationType configurationType, const std::string&amp; value) {</span>
<span class="lineNum">    2580 </span><span class="lineCov">          2 :         setGlobally(configurationType, value, false);</span>
<span class="lineNum">    2581 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    2582 </span>            : 
<span class="lineNum">    2583 </span>            :     /// @brief Clears repository so that all the configurations are unset
<span class="lineNum">    2584 </span>            :     inline void clear(void) {
<span class="lineNum">    2585 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    2586 </span>            :         unregisterAll();
<span class="lineNum">    2587 </span>            :     }
<span class="lineNum">    2588 </span>            : 
<span class="lineNum">    2589 </span>            :     /// @brief Gets configuration file used in parsing this configurations.
<span class="lineNum">    2590 </span>            :     ///
<span class="lineNum">    2591 </span>            :     /// @detail If this repository was set manually or by text this returns empty string.
<span class="lineNum">    2592 </span>            :     inline const std::string&amp; configurationFile(void) const {
<span class="lineNum">    2593 </span>            :         return m_configurationFile;
<span class="lineNum">    2594 </span>            :     }
<a name="2595"><span class="lineNum">    2595 </span>            : </a>
<span class="lineNum">    2596 </span>            :     /// @brief Sets configurations to &quot;factory based&quot; configurations.
<span class="lineNum">    2597 </span><span class="lineCov">          2 :     void setToDefault(void) {</span>
<span class="lineNum">    2598 </span><span class="lineCov">          2 :         setGlobally(ConfigurationType::Enabled, std::string(&quot;true&quot;), true);</span>
<span class="lineNum">    2599 </span>            : #if !defined(ELPP_NO_DEFAULT_LOG_FILE)
<span class="lineNum">    2600 </span><span class="lineCov">          2 :         setGlobally(ConfigurationType::Filename, std::string(base::consts::kDefaultLogFile), true);</span>
<span class="lineNum">    2601 </span>            : #else
<span class="lineNum">    2602 </span>            :         ELPP_UNUSED(base::consts::kDefaultLogFile);
<span class="lineNum">    2603 </span>            : #endif  // !defined(ELPP_NO_DEFAULT_LOG_FILE)
<span class="lineNum">    2604 </span><span class="lineCov">          2 :         setGlobally(ConfigurationType::ToFile, std::string(&quot;true&quot;), true);</span>
<span class="lineNum">    2605 </span><span class="lineCov">          2 :         setGlobally(ConfigurationType::ToStandardOutput, std::string(&quot;true&quot;), true);</span>
<span class="lineNum">    2606 </span><span class="lineCov">          2 :         setGlobally(ConfigurationType::MillisecondsWidth, std::string(&quot;3&quot;), true);</span>
<span class="lineNum">    2607 </span><span class="lineCov">          2 :         setGlobally(ConfigurationType::PerformanceTracking, std::string(&quot;true&quot;), true);</span>
<span class="lineNum">    2608 </span><span class="lineCov">          2 :         setGlobally(ConfigurationType::MaxLogFileSize, std::string(&quot;0&quot;), true);</span>
<span class="lineNum">    2609 </span><span class="lineCov">          2 :         setGlobally(ConfigurationType::LogFlushThreshold, std::string(&quot;0&quot;), true);</span>
<span class="lineNum">    2610 </span>            : 
<span class="lineNum">    2611 </span><span class="lineCov">          2 :         setGlobally(ConfigurationType::Format, std::string(&quot;%datetime %level [%logger] %msg&quot;), true);</span>
<span class="lineNum">    2612 </span><span class="lineCov">          2 :         set(Level::Debug, ConfigurationType::Format, std::string(&quot;%datetime %level [%logger] [%user@%host] [%func] [%loc] %msg&quot;));</span>
<span class="lineNum">    2613 </span>            :         // INFO and WARNING are set to default by Level::Global
<span class="lineNum">    2614 </span><span class="lineCov">          2 :         set(Level::Error, ConfigurationType::Format, std::string(&quot;%datetime %level [%logger] %msg&quot;));</span>
<span class="lineNum">    2615 </span><span class="lineCov">          2 :         set(Level::Fatal, ConfigurationType::Format, std::string(&quot;%datetime %level [%logger] %msg&quot;));</span>
<span class="lineNum">    2616 </span><span class="lineCov">          2 :         set(Level::Verbose, ConfigurationType::Format, std::string(&quot;%datetime %level-%vlevel [%logger] %msg&quot;));</span>
<span class="lineNum">    2617 </span><span class="lineCov">          2 :         set(Level::Trace, ConfigurationType::Format, std::string(&quot;%datetime %level [%logger] [%func] [%loc] %msg&quot;));</span>
<span class="lineNum">    2618 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    2619 </span>            : 
<span class="lineNum">    2620 </span>            :     /// @brief Lets you set the remaining configurations to default.
<span class="lineNum">    2621 </span>            :     ///
<span class="lineNum">    2622 </span>            :     /// @detail By remaining, it means that the level/type a configuration does not exist for.
<span class="lineNum">    2623 </span>            :     /// This function is useful when you want to minimize chances of failures, e.g, if you have a configuration file that sets
<span class="lineNum">    2624 </span>            :     /// configuration for all the configurations except for Enabled or not, we use this so that ENABLED is set to default i.e,
<a name="2625"><span class="lineNum">    2625 </span>            :     /// true. If you dont do this explicitley (either by calling this function or by using second param in Constructor</a>
<span class="lineNum">    2626 </span>            :     /// and try to access a value, an error is thrown
<span class="lineNum">    2627 </span><span class="lineCov">         12 :     void setRemainingToDefault(void) {</span>
<span class="lineNum">    2628 </span><span class="lineCov">         12 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    2629 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Global, ConfigurationType::Enabled, std::string(&quot;true&quot;));</span>
<span class="lineNum">    2630 </span>            : #if !defined(ELPP_NO_DEFAULT_LOG_FILE)
<span class="lineNum">    2631 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Global, ConfigurationType::Filename, std::string(base::consts::kDefaultLogFile));</span>
<span class="lineNum">    2632 </span>            : #endif  // !defined(ELPP_NO_DEFAULT_LOG_FILE)
<span class="lineNum">    2633 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Global, ConfigurationType::ToFile, std::string(&quot;true&quot;));</span>
<span class="lineNum">    2634 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Global, ConfigurationType::ToStandardOutput, std::string(&quot;true&quot;));</span>
<span class="lineNum">    2635 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Global, ConfigurationType::MillisecondsWidth, std::string(&quot;3&quot;));</span>
<span class="lineNum">    2636 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Global, ConfigurationType::PerformanceTracking, std::string(&quot;true&quot;));</span>
<span class="lineNum">    2637 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Global, ConfigurationType::MaxLogFileSize, std::string(&quot;0&quot;));</span>
<span class="lineNum">    2638 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Global, ConfigurationType::Format, std::string(&quot;%datetime %level [%logger] %msg&quot;));</span>
<span class="lineNum">    2639 </span>            :         unsafeSetIfNotExist(Level::Debug, ConfigurationType::Format, 
<span class="lineNum">    2640 </span><span class="lineCov">         12 :             std::string(&quot;%datetime %level [%logger] [%user@%host] [%func] [%loc] %msg&quot;));</span>
<span class="lineNum">    2641 </span>            :         // INFO and WARNING are set to default by Level::Global
<span class="lineNum">    2642 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Error, ConfigurationType::Format, std::string(&quot;%datetime %level [%logger] %msg&quot;));</span>
<span class="lineNum">    2643 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Fatal, ConfigurationType::Format, std::string(&quot;%datetime %level [%logger] %msg&quot;));</span>
<span class="lineNum">    2644 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Verbose, ConfigurationType::Format, std::string(&quot;%datetime %level-%vlevel [%logger] %msg&quot;));</span>
<span class="lineNum">    2645 </span><span class="lineCov">         12 :         unsafeSetIfNotExist(Level::Trace, ConfigurationType::Format, std::string(&quot;%datetime %level [%logger] [%func] [%loc] %msg&quot;));</span>
<span class="lineNum">    2646 </span><span class="lineCov">         12 :     }</span>
<span class="lineNum">    2647 </span>            : 
<span class="lineNum">    2648 </span>            :     /// @brief Parser used internally to parse configurations from file or text.
<span class="lineNum">    2649 </span>            :     ///
<span class="lineNum">    2650 </span>            :     /// @detail This class makes use of base::utils::Str.
<span class="lineNum">    2651 </span>            :     /// You should not need this unless you are working on some tool for Easylogging++
<span class="lineNum">    2652 </span>            :     class Parser : base::StaticClass {
<span class="lineNum">    2653 </span>            :     public:
<span class="lineNum">    2654 </span>            :         /// @brief Parses configuration from file.
<span class="lineNum">    2655 </span>            :         /// @param configurationFile Full path to configuration file
<span class="lineNum">    2656 </span>            :         /// @param sender Sender configurations pointer. Usually 'this' is used from calling class
<span class="lineNum">    2657 </span>            :         /// @param base Configurations to base new configuration repository off. This value is used when you want to use
<span class="lineNum">    2658 </span>            :         ///        existing Configurations to base all the values and then set rest of configuration via configuration file.
<a name="2659"><span class="lineNum">    2659 </span>            :         /// @return True if successfully parsed, false otherwise. You may define '_STOP_ON_FIRSTELPP_ASSERTION' to make sure you</a>
<span class="lineNum">    2660 </span>            :         ///         do not proceed without successful parse.
<span class="lineNum">    2661 </span><span class="lineCov">         12 :         static bool parseFromFile(const std::string&amp; configurationFile, Configurations* sender, Configurations* base = nullptr) {</span>
<span class="lineNum">    2662 </span><span class="lineCov">         12 :             sender-&gt;setFromBase(base);</span>
<span class="lineNum">    2663 </span><span class="lineCov">         12 :             std::ifstream fileStream_(configurationFile.c_str(), std::ifstream::in);</span>
<span class="lineNum">    2664 </span><span class="lineCov">         12 :             ELPP_ASSERT(fileStream_.is_open(), &quot;Unable to open configuration file [&quot; &lt;&lt; configurationFile &lt;&lt; &quot;] for parsing.&quot;);</span>
<span class="lineNum">    2665 </span><span class="lineCov">         12 :             bool parsedSuccessfully = false;</span>
<span class="lineNum">    2666 </span><span class="lineCov">         24 :             std::string line = std::string();</span>
<span class="lineNum">    2667 </span><span class="lineCov">         12 :             Level currLevel = Level::Unknown;</span>
<span class="lineNum">    2668 </span><span class="lineCov">         24 :             std::string currConfigStr = std::string();</span>
<span class="lineNum">    2669 </span><span class="lineCov">         24 :             std::string currLevelStr = std::string();</span>
<span class="lineNum">    2670 </span><span class="lineCov">        228 :             while (fileStream_.good()) {</span>
<span class="lineNum">    2671 </span><span class="lineCov">        204 :                 std::getline(fileStream_, line);</span>
<span class="lineNum">    2672 </span><span class="lineCov">        204 :                 parsedSuccessfully = parseLine(&amp;line, &amp;currConfigStr, &amp;currLevelStr, &amp;currLevel, sender);</span>
<span class="lineNum">    2673 </span><span class="lineCov">        204 :                 ELPP_ASSERT(parsedSuccessfully, &quot;Unable to parse configuration line: &quot; &lt;&lt; line);</span>
<span class="lineNum">    2674 </span>            :             }
<span class="lineNum">    2675 </span><span class="lineCov">         24 :             return parsedSuccessfully;</span>
<span class="lineNum">    2676 </span>            :         }
<span class="lineNum">    2677 </span>            : 
<span class="lineNum">    2678 </span>            :         /// @brief Parse configurations from configuration string.
<span class="lineNum">    2679 </span>            :         ///
<span class="lineNum">    2680 </span>            :         /// @detail This configuration string has same syntax as configuration file contents. Make sure all the necessary
<span class="lineNum">    2681 </span>            :         /// new line characters are provided. You may define '_STOP_ON_FIRSTELPP_ASSERTION' to make sure you
<span class="lineNum">    2682 </span>            :         /// do not proceed without successful parse (This is recommended)
<span class="lineNum">    2683 </span>            :         /// @param configurationsString
<span class="lineNum">    2684 </span>            :         /// @param sender Sender configurations pointer. Usually 'this' is used from calling class
<span class="lineNum">    2685 </span>            :         /// @param base Configurations to base new configuration repository off. This value is used when you want to use
<span class="lineNum">    2686 </span>            :         ///        existing Configurations to base all the values and then set rest of configuration via configuration text.
<span class="lineNum">    2687 </span>            :         /// @return True if successfully parsed, false otherwise.
<span class="lineNum">    2688 </span>            :         static bool parseFromText(const std::string&amp; configurationsString, Configurations* sender, Configurations* base = nullptr) {
<span class="lineNum">    2689 </span>            :             sender-&gt;setFromBase(base);
<span class="lineNum">    2690 </span>            :             bool parsedSuccessfully = false;
<span class="lineNum">    2691 </span>            :             std::stringstream ss(configurationsString);
<span class="lineNum">    2692 </span>            :             std::string line = std::string();
<span class="lineNum">    2693 </span>            :             Level currLevel = Level::Unknown;
<span class="lineNum">    2694 </span>            :             std::string currConfigStr = std::string();
<span class="lineNum">    2695 </span>            :             std::string currLevelStr = std::string();
<span class="lineNum">    2696 </span>            :             while (std::getline(ss, line)) {
<span class="lineNum">    2697 </span>            :                 parsedSuccessfully = parseLine(&amp;line, &amp;currConfigStr, &amp;currLevelStr, &amp;currLevel, sender);
<span class="lineNum">    2698 </span>            :                 ELPP_ASSERT(parsedSuccessfully, &quot;Unable to parse configuration line: &quot; &lt;&lt; line);
<span class="lineNum">    2699 </span>            :             }
<span class="lineNum">    2700 </span>            :             return parsedSuccessfully;
<span class="lineNum">    2701 </span>            :         }
<span class="lineNum">    2702 </span>            : 
<a name="2703"><span class="lineNum">    2703 </span>            :     private:</a>
<span class="lineNum">    2704 </span>            :         friend class el::Loggers;
<span class="lineNum">    2705 </span><span class="lineCov">        204 :         static void ignoreComments(std::string* line) {</span>
<span class="lineNum">    2706 </span><span class="lineCov">        204 :             std::size_t foundAt = 0;</span>
<span class="lineNum">    2707 </span><span class="lineCov">        204 :             std::size_t quotesStart = line-&gt;find(&quot;\&quot;&quot;);</span>
<span class="lineNum">    2708 </span><span class="lineCov">        204 :             std::size_t quotesEnd = std::string::npos;</span>
<span class="lineNum">    2709 </span><span class="lineCov">        204 :             if (quotesStart != std::string::npos) {</span>
<span class="lineNum">    2710 </span><span class="lineCov">         36 :                 quotesEnd = line-&gt;find(&quot;\&quot;&quot;, quotesStart + 1);</span>
<span class="lineNum">    2711 </span><span class="lineCov">         72 :                 while (quotesEnd != std::string::npos &amp;&amp; line-&gt;at(quotesEnd - 1) == '\\') {</span>
<span class="lineNum">    2712 </span>            :                     // Do not erase slash yet - we will erase it in parseLine(..) while loop
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :                     quotesEnd = line-&gt;find(&quot;\&quot;&quot;, quotesEnd + 2);</span>
<span class="lineNum">    2714 </span>            :                 }
<span class="lineNum">    2715 </span>            :             }
<span class="lineNum">    2716 </span><span class="lineCov">        204 :             if ((foundAt = line-&gt;find(base::consts::kConfigurationComment)) != std::string::npos) {</span>
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :                 if (foundAt &lt; quotesEnd) {</span>
<span class="lineNum">    2718 </span><span class="lineNoCov">          0 :                     foundAt = line-&gt;find(base::consts::kConfigurationComment, quotesEnd + 1);</span>
<span class="lineNum">    2719 </span>            :                 }
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :                 *line = line-&gt;substr(0, foundAt);</span>
<a name="2721"><span class="lineNum">    2721 </span>            :             }</a>
<span class="lineNum">    2722 </span><span class="lineCov">        204 :         }</span>
<span class="lineNum">    2723 </span><span class="lineCov">        192 :         static inline bool isLevel(const std::string&amp; line) {</span>
<span class="lineNum">    2724 </span><span class="lineCov">        192 :             return base::utils::Str::startsWith(line, std::string(base::consts::kConfigurationLevel));</span>
<a name="2725"><span class="lineNum">    2725 </span>            :         }</a>
<span class="lineNum">    2726 </span>            : 
<span class="lineNum">    2727 </span><span class="lineCov">        204 :         static inline bool isComment(const std::string&amp; line) {</span>
<span class="lineNum">    2728 </span><span class="lineCov">        204 :             return base::utils::Str::startsWith(line, std::string(base::consts::kConfigurationComment));</span>
<a name="2729"><span class="lineNum">    2729 </span>            :         }</a>
<span class="lineNum">    2730 </span>            : 
<span class="lineNum">    2731 </span><span class="lineCov">        120 :         static inline bool isConfig(const std::string&amp; line) {</span>
<span class="lineNum">    2732 </span><span class="lineCov">        120 :             std::size_t assignment = line.find('=');</span>
<span class="lineNum">    2733 </span><span class="lineCov">        240 :             return line != &quot;&quot; &amp;&amp;</span>
<span class="lineNum">    2734 </span><span class="lineCov">        120 :                     (line[0] &gt;= 65 || line[0] &lt;= 90 || line[0] &gt;= 97 || line[0] &lt;= 122) &amp;&amp;</span>
<span class="lineNum">    2735 </span><span class="lineCov">        240 :                     (assignment != std::string::npos) &amp;&amp;</span>
<span class="lineNum">    2736 </span><span class="lineCov">        240 :                     (line.size() &gt; assignment);</span>
<a name="2737"><span class="lineNum">    2737 </span>            :         }</a>
<span class="lineNum">    2738 </span>            : 
<span class="lineNum">    2739 </span><span class="lineCov">        204 :         static bool parseLine(std::string* line, std::string* currConfigStr, std::string* currLevelStr, Level* currLevel, Configurations* conf) {</span>
<span class="lineNum">    2740 </span><span class="lineCov">        204 :             ConfigurationType currConfig = ConfigurationType::Unknown;</span>
<span class="lineNum">    2741 </span><span class="lineCov">        204 :             std::string currValue = std::string();</span>
<span class="lineNum">    2742 </span><span class="lineCov">        204 :             *line = base::utils::Str::trim(*line);</span>
<span class="lineNum">    2743 </span><span class="lineCov">        204 :             if (isComment(*line)) return true;</span>
<span class="lineNum">    2744 </span><span class="lineCov">        204 :             ignoreComments(line);</span>
<span class="lineNum">    2745 </span><span class="lineCov">        204 :             *line = base::utils::Str::trim(*line);</span>
<span class="lineNum">    2746 </span><span class="lineCov">        204 :             if (line-&gt;empty()) {</span>
<span class="lineNum">    2747 </span>            :                 // Comment ignored
<span class="lineNum">    2748 </span><span class="lineCov">         12 :                 return true;</span>
<span class="lineNum">    2749 </span>            :             }
<span class="lineNum">    2750 </span><span class="lineCov">        192 :             if (isLevel(*line)) {</span>
<span class="lineNum">    2751 </span><span class="lineCov">         72 :                 if (line-&gt;size() &lt;= 2) {</span>
<span class="lineNum">    2752 </span><span class="lineNoCov">          0 :                     return true;</span>
<span class="lineNum">    2753 </span>            :                 }
<span class="lineNum">    2754 </span><span class="lineCov">         72 :                 *currLevelStr = line-&gt;substr(1, line-&gt;size() - 2);</span>
<span class="lineNum">    2755 </span><span class="lineCov">         72 :                 *currLevelStr = base::utils::Str::toUpper(*currLevelStr);</span>
<span class="lineNum">    2756 </span><span class="lineCov">         72 :                 *currLevelStr = base::utils::Str::trim(*currLevelStr);</span>
<span class="lineNum">    2757 </span><span class="lineCov">         72 :                 *currLevel = LevelHelper::convertFromString(currLevelStr-&gt;c_str());</span>
<span class="lineNum">    2758 </span><span class="lineCov">         72 :                 return true;</span>
<span class="lineNum">    2759 </span>            :             }
<span class="lineNum">    2760 </span><span class="lineCov">        120 :             if (isConfig(*line)) {</span>
<span class="lineNum">    2761 </span><span class="lineCov">        120 :                 std::size_t assignment = line-&gt;find('=');</span>
<span class="lineNum">    2762 </span><span class="lineCov">        120 :                 *currConfigStr = line-&gt;substr(0, assignment);</span>
<span class="lineNum">    2763 </span><span class="lineCov">        120 :                 *currConfigStr = base::utils::Str::toUpper(*currConfigStr);</span>
<span class="lineNum">    2764 </span><span class="lineCov">        120 :                 *currConfigStr = base::utils::Str::trim(*currConfigStr);</span>
<span class="lineNum">    2765 </span><span class="lineCov">        120 :                 currConfig = ConfigurationTypeHelper::convertFromString(currConfigStr-&gt;c_str());</span>
<span class="lineNum">    2766 </span><span class="lineCov">        120 :                 currValue = line-&gt;substr(assignment + 1);</span>
<span class="lineNum">    2767 </span><span class="lineCov">        120 :                 currValue = base::utils::Str::trim(currValue);</span>
<span class="lineNum">    2768 </span><span class="lineCov">        120 :                 std::size_t quotesStart = currValue.find(&quot;\&quot;&quot;, 0);</span>
<span class="lineNum">    2769 </span><span class="lineCov">        120 :                 std::size_t quotesEnd = std::string::npos;</span>
<span class="lineNum">    2770 </span><span class="lineCov">        120 :                 if (quotesStart != std::string::npos) {</span>
<span class="lineNum">    2771 </span><span class="lineCov">         36 :                     quotesEnd = currValue.find(&quot;\&quot;&quot;, quotesStart + 1);</span>
<span class="lineNum">    2772 </span><span class="lineCov">         72 :                     while (quotesEnd != std::string::npos &amp;&amp; currValue.at(quotesEnd - 1) == '\\') {</span>
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :                         currValue = currValue.erase(quotesEnd - 1, 1);</span>
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :                         quotesEnd = currValue.find(&quot;\&quot;&quot;, quotesEnd + 2);</span>
<span class="lineNum">    2775 </span>            :                     }
<span class="lineNum">    2776 </span>            :                 }
<span class="lineNum">    2777 </span><span class="lineCov">        120 :                 if (quotesStart != std::string::npos &amp;&amp; quotesEnd != std::string::npos) {</span>
<span class="lineNum">    2778 </span>            :                     // Quote provided - check and strip if valid
<span class="lineNum">    2779 </span><span class="lineCov">         36 :                     ELPP_ASSERT((quotesStart &lt; quotesEnd), &quot;Configuration error - No ending quote found in [&quot; </span>
<span class="lineNum">    2780 </span><span class="lineNoCov">          0 :                         &lt;&lt; currConfigStr &lt;&lt; &quot;]&quot;);</span>
<span class="lineNum">    2781 </span><span class="lineCov">         36 :                     ELPP_ASSERT((quotesStart + 1 != quotesEnd), &quot;Empty configuration value for [&quot; &lt;&lt; currConfigStr &lt;&lt; &quot;]&quot;);</span>
<span class="lineNum">    2782 </span><span class="lineCov">         36 :                     if ((quotesStart != quotesEnd) &amp;&amp; (quotesStart + 1 != quotesEnd)) {</span>
<span class="lineNum">    2783 </span>            :                         // Explicit check in case if assertion is disabled
<span class="lineNum">    2784 </span><span class="lineCov">         36 :                         currValue = currValue.substr(quotesStart + 1, quotesEnd - 1);</span>
<span class="lineNum">    2785 </span>            :                     }
<span class="lineNum">    2786 </span>            :                 }
<span class="lineNum">    2787 </span>            :             }
<span class="lineNum">    2788 </span><span class="lineCov">        120 :             ELPP_ASSERT(*currLevel != Level::Unknown, &quot;Unrecognized severity level [&quot; &lt;&lt; *currLevelStr &lt;&lt; &quot;]&quot;);</span>
<span class="lineNum">    2789 </span><span class="lineCov">        120 :             ELPP_ASSERT(currConfig != ConfigurationType::Unknown, &quot;Unrecognized configuration [&quot; &lt;&lt; *currConfigStr &lt;&lt; &quot;]&quot;);</span>
<span class="lineNum">    2790 </span><span class="lineCov">        120 :             if (*currLevel == Level::Unknown || currConfig == ConfigurationType::Unknown) {</span>
<span class="lineNum">    2791 </span><span class="lineNoCov">          0 :                 return false;  // unrecognizable level or config</span>
<span class="lineNum">    2792 </span>            :             }
<span class="lineNum">    2793 </span><span class="lineCov">        120 :             conf-&gt;set(*currLevel, currConfig, currValue);</span>
<span class="lineNum">    2794 </span><span class="lineCov">        120 :             return true;</span>
<span class="lineNum">    2795 </span>            :         }
<span class="lineNum">    2796 </span>            :     };
<span class="lineNum">    2797 </span>            : 
<span class="lineNum">    2798 </span>            : private:
<span class="lineNum">    2799 </span>            :     std::string m_configurationFile;
<span class="lineNum">    2800 </span>            :     bool m_isFromFile;
<span class="lineNum">    2801 </span>            :     friend class el::Loggers;
<a name="2802"><span class="lineNum">    2802 </span>            : </a>
<span class="lineNum">    2803 </span>            :     /// @brief Unsafely sets configuration if does not already exist
<span class="lineNum">    2804 </span><span class="lineCov">        156 :     void unsafeSetIfNotExist(Level level, ConfigurationType configurationType, const std::string&amp; value) {</span>
<span class="lineNum">    2805 </span><span class="lineCov">        156 :         Configuration* conf = RegistryWithPred&lt;Configuration, Configuration::Predicate&gt;::get(level, configurationType);</span>
<span class="lineNum">    2806 </span><span class="lineCov">        156 :         if (conf == nullptr) {</span>
<span class="lineNum">    2807 </span><span class="lineCov">         48 :             unsafeSet(level, configurationType, value);</span>
<span class="lineNum">    2808 </span>            :         }
<span class="lineNum">    2809 </span><span class="lineCov">        156 :     }</span>
<a name="2810"><span class="lineNum">    2810 </span>            : </a>
<span class="lineNum">    2811 </span>            :     /// @brief Thread unsafe set
<span class="lineNum">    2812 </span><span class="lineCov">       3012 :     void unsafeSet(Level level, ConfigurationType configurationType, const std::string&amp; value) {</span>
<span class="lineNum">    2813 </span><span class="lineCov">       3012 :         Configuration* conf = RegistryWithPred&lt;Configuration, Configuration::Predicate&gt;::get(level, configurationType);</span>
<span class="lineNum">    2814 </span><span class="lineCov">       3012 :         if (conf == nullptr) {</span>
<span class="lineNum">    2815 </span><span class="lineCov">        688 :             registerNew(new Configuration(level, configurationType, value));</span>
<span class="lineNum">    2816 </span>            :         } else {
<span class="lineNum">    2817 </span><span class="lineCov">       2324 :             conf-&gt;setValue(value);</span>
<span class="lineNum">    2818 </span>            :         }
<span class="lineNum">    2819 </span><span class="lineCov">       3012 :         if (level == Level::Global) {</span>
<span class="lineNum">    2820 </span><span class="lineCov">        150 :             unsafeSetGlobally(configurationType, value, false);</span>
<span class="lineNum">    2821 </span>            :         }
<span class="lineNum">    2822 </span><span class="lineCov">       3012 :     }</span>
<span class="lineNum">    2823 </span>            : 
<a name="2824"><span class="lineNum">    2824 </span>            :     /// @brief Sets configurations for all levels including Level::Global if includeGlobalLevel is true</a>
<span class="lineNum">    2825 </span>            :     /// @see Configurations::setGlobally(ConfigurationType configurationType, const std::string&amp; value)
<span class="lineNum">    2826 </span><span class="lineCov">         20 :     void setGlobally(ConfigurationType configurationType, const std::string&amp; value, bool includeGlobalLevel) {</span>
<span class="lineNum">    2827 </span><span class="lineCov">         20 :         if (includeGlobalLevel) {</span>
<span class="lineNum">    2828 </span><span class="lineCov">         18 :             set(Level::Global, configurationType, value);</span>
<a name="2829"><span class="lineNum">    2829 </span>            :         }</a>
<span class="lineNum">    2830 </span><span class="lineCov">         20 :         base::type::EnumType lIndex = LevelHelper::kMinValid;</span>
<span class="lineNum">    2831 </span><span class="lineCov">        140 :         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](void) -&gt; bool {</span>
<span class="lineNum">    2832 </span><span class="lineCov">        140 :             set(LevelHelper::castFromInt(lIndex), configurationType, value);</span>
<span class="lineNum">    2833 </span><span class="lineCov">        140 :             return false;  // Do not break lambda function yet as we need to set all levels regardless</span>
<span class="lineNum">    2834 </span><span class="lineCov">         20 :         });</span>
<span class="lineNum">    2835 </span><span class="lineCov">         20 :     }</span>
<span class="lineNum">    2836 </span>            : 
<a name="2837"><span class="lineNum">    2837 </span>            :     /// @brief Sets configurations (Unsafely) for all levels including Level::Global if includeGlobalLevel is true</a>
<span class="lineNum">    2838 </span>            :     /// @see Configurations::setGlobally(ConfigurationType configurationType, const std::string&amp; value)
<span class="lineNum">    2839 </span><span class="lineCov">        284 :     void unsafeSetGlobally(ConfigurationType configurationType, const std::string&amp; value, bool includeGlobalLevel) {</span>
<span class="lineNum">    2840 </span><span class="lineCov">        284 :         if (includeGlobalLevel) {</span>
<span class="lineNum">    2841 </span><span class="lineNoCov">          0 :             unsafeSet(Level::Global, configurationType, value);</span>
<a name="2842"><span class="lineNum">    2842 </span>            :         }</a>
<span class="lineNum">    2843 </span><span class="lineCov">        284 :         base::type::EnumType lIndex = LevelHelper::kMinValid;</span>
<span class="lineNum">    2844 </span><span class="lineCov">       1988 :         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](void) -&gt; bool  {</span>
<span class="lineNum">    2845 </span><span class="lineCov">       1988 :             unsafeSet(LevelHelper::castFromInt(lIndex), configurationType, value);</span>
<span class="lineNum">    2846 </span><span class="lineCov">       1988 :             return false;  // Do not break lambda function yet as we need to set all levels regardless</span>
<span class="lineNum">    2847 </span><span class="lineCov">        284 :         });</span>
<span class="lineNum">    2848 </span><span class="lineCov">        284 :     }</span>
<span class="lineNum">    2849 </span>            : };
<span class="lineNum">    2850 </span>            : 
<span class="lineNum">    2851 </span>            : namespace base {
<span class="lineNum">    2852 </span>            : typedef std::shared_ptr&lt;base::type::fstream_t&gt; FileStreamPtr;
<span class="lineNum">    2853 </span>            : typedef std::map&lt;std::string, FileStreamPtr&gt; LogStreamsReferenceMap;
<span class="lineNum">    2854 </span>            : /// @brief Configurations with data types.
<span class="lineNum">    2855 </span>            : ///
<span class="lineNum">    2856 </span>            : /// @detail el::Configurations have string based values. This is whats used internally in order to read correct configurations.
<span class="lineNum">    2857 </span>            : /// This is to perform faster while writing logs using correct configurations.
<span class="lineNum">    2858 </span>            : ///
<span class="lineNum">    2859 </span>            : /// This is thread safe and final class containing non-virtual destructor (means nothing should inherit this class)
<span class="lineNum">    2860 </span>            : class TypedConfigurations : public base::threading::ThreadSafe {
<span class="lineNum">    2861 </span>            : public:
<span class="lineNum">    2862 </span>            :     /// @brief Constructor to initialize (construct) the object off el::Configurations
<a name="2863"><span class="lineNum">    2863 </span>            :     /// @param configurations Configurations pointer/reference to base this typed configurations off.</a>
<span class="lineNum">    2864 </span>            :     /// @param logStreamsReference Use ELPP-&gt;registeredLoggers()-&gt;logStreamsReference()
<span class="lineNum">    2865 </span><span class="lineCov">         14 :     TypedConfigurations(Configurations* configurations, base::LogStreamsReferenceMap* logStreamsReference) {</span>
<span class="lineNum">    2866 </span><span class="lineCov">         14 :         m_configurations = configurations;</span>
<span class="lineNum">    2867 </span><span class="lineCov">         14 :         m_logStreamsReference = logStreamsReference;</span>
<span class="lineNum">    2868 </span><span class="lineCov">         14 :         build(m_configurations);</span>
<span class="lineNum">    2869 </span><span class="lineCov">         14 :     }</span>
<span class="lineNum">    2870 </span>            : 
<span class="lineNum">    2871 </span>            :     TypedConfigurations(const TypedConfigurations&amp; other) {
<span class="lineNum">    2872 </span>            :         this-&gt;m_configurations = other.m_configurations;
<span class="lineNum">    2873 </span>            :         this-&gt;m_logStreamsReference = other.m_logStreamsReference;
<span class="lineNum">    2874 </span>            :         build(m_configurations);
<a name="2875"><span class="lineNum">    2875 </span>            :     }</a>
<span class="lineNum">    2876 </span>            : 
<span class="lineNum">    2877 </span><span class="lineCov">         20 :     virtual ~TypedConfigurations(void) {</span>
<a name="2878"><span class="lineNum">    2878 </span><span class="lineCov">         20 :     }</span></a>
<span class="lineNum">    2879 </span>            : 
<span class="lineNum">    2880 </span><span class="lineCov">         10 :     const Configurations* configurations(void) const {</span>
<span class="lineNum">    2881 </span><span class="lineCov">         10 :         return m_configurations;</span>
<a name="2882"><span class="lineNum">    2882 </span>            :     }</a>
<span class="lineNum">    2883 </span>            : 
<span class="lineNum">    2884 </span><span class="lineCov">       1244 :     inline bool enabled(Level level) {</span>
<span class="lineNum">    2885 </span><span class="lineCov">       1244 :         return getConfigByVal&lt;bool&gt;(level, &amp;m_enabledMap, &quot;enabled&quot;);</span>
<a name="2886"><span class="lineNum">    2886 </span>            :     }</a>
<span class="lineNum">    2887 </span>            : 
<span class="lineNum">    2888 </span><span class="lineCov">       1314 :     inline bool toFile(Level level) {</span>
<span class="lineNum">    2889 </span><span class="lineCov">       1314 :         return getConfigByVal&lt;bool&gt;(level, &amp;m_toFileMap, &quot;toFile&quot;);</span>
<span class="lineNum">    2890 </span>            :     }
<span class="lineNum">    2891 </span>            : 
<span class="lineNum">    2892 </span>            :     inline const std::string&amp; filename(Level level) {
<span class="lineNum">    2893 </span>            :         return getConfigByRef&lt;std::string&gt;(level, &amp;m_filenameMap, &quot;filename&quot;);
<a name="2894"><span class="lineNum">    2894 </span>            :     }</a>
<span class="lineNum">    2895 </span>            : 
<span class="lineNum">    2896 </span><span class="lineCov">       1244 :     inline bool toStandardOutput(Level level) {</span>
<span class="lineNum">    2897 </span><span class="lineCov">       1244 :         return getConfigByVal&lt;bool&gt;(level, &amp;m_toStandardOutputMap, &quot;toStandardOutput&quot;);</span>
<a name="2898"><span class="lineNum">    2898 </span>            :     }</a>
<span class="lineNum">    2899 </span>            : 
<span class="lineNum">    2900 </span><span class="lineCov">       1342 :     inline const base::LogFormat&amp; logFormat(Level level) {</span>
<span class="lineNum">    2901 </span><span class="lineCov">       1342 :         return getConfigByRef&lt;base::LogFormat&gt;(level, &amp;m_logFormatMap, &quot;logFormat&quot;);</span>
<a name="2902"><span class="lineNum">    2902 </span>            :     }</a>
<span class="lineNum">    2903 </span>            : 
<span class="lineNum">    2904 </span><span class="lineCov">       1244 :     inline const base::MillisecondsWidth&amp; millisecondsWidth(Level level = Level::Global) {</span>
<span class="lineNum">    2905 </span><span class="lineCov">       1244 :         return getConfigByRef&lt;base::MillisecondsWidth&gt;(level, &amp;m_millisecondsWidthMap, &quot;millisecondsWidth&quot;);</span>
<span class="lineNum">    2906 </span>            :     }
<span class="lineNum">    2907 </span>            : 
<span class="lineNum">    2908 </span>            :     inline bool performanceTracking(Level level = Level::Global) {
<span class="lineNum">    2909 </span>            :         return getConfigByVal&lt;bool&gt;(level, &amp;m_performanceTrackingMap, &quot;performanceTracking&quot;);
<a name="2910"><span class="lineNum">    2910 </span>            :     }</a>
<span class="lineNum">    2911 </span>            : 
<span class="lineNum">    2912 </span><span class="lineCov">       1314 :     inline base::type::fstream_t* fileStream(Level level) {</span>
<span class="lineNum">    2913 </span><span class="lineCov">       1314 :         return getConfigByRef&lt;base::FileStreamPtr&gt;(level, &amp;m_fileStreamMap, &quot;fileStream&quot;).get();</span>
<span class="lineNum">    2914 </span>            :     }
<span class="lineNum">    2915 </span>            : 
<span class="lineNum">    2916 </span>            :     inline std::size_t maxLogFileSize(Level level) {
<span class="lineNum">    2917 </span>            :         return getConfigByVal&lt;std::size_t&gt;(level, &amp;m_maxLogFileSizeMap, &quot;maxLogFileSize&quot;);
<a name="2918"><span class="lineNum">    2918 </span>            :     }</a>
<span class="lineNum">    2919 </span>            : 
<span class="lineNum">    2920 </span><span class="lineCov">       1244 :     inline std::size_t logFlushThreshold(Level level) {</span>
<span class="lineNum">    2921 </span><span class="lineCov">       1244 :         return getConfigByVal&lt;std::size_t&gt;(level, &amp;m_logFlushThresholdMap, &quot;logFlushThreshold&quot;);</span>
<span class="lineNum">    2922 </span>            :     }
<span class="lineNum">    2923 </span>            : 
<span class="lineNum">    2924 </span>            : private:
<span class="lineNum">    2925 </span>            :     Configurations* m_configurations;
<span class="lineNum">    2926 </span>            :     std::map&lt;Level, bool&gt; m_enabledMap;
<span class="lineNum">    2927 </span>            :     std::map&lt;Level, bool&gt; m_toFileMap;
<span class="lineNum">    2928 </span>            :     std::map&lt;Level, std::string&gt; m_filenameMap;
<span class="lineNum">    2929 </span>            :     std::map&lt;Level, bool&gt; m_toStandardOutputMap;
<span class="lineNum">    2930 </span>            :     std::map&lt;Level, base::LogFormat&gt; m_logFormatMap;
<span class="lineNum">    2931 </span>            :     std::map&lt;Level, base::MillisecondsWidth&gt; m_millisecondsWidthMap;
<span class="lineNum">    2932 </span>            :     std::map&lt;Level, bool&gt; m_performanceTrackingMap;
<span class="lineNum">    2933 </span>            :     std::map&lt;Level, base::FileStreamPtr&gt; m_fileStreamMap;
<span class="lineNum">    2934 </span>            :     std::map&lt;Level, std::size_t&gt; m_maxLogFileSizeMap;
<span class="lineNum">    2935 </span>            :     std::map&lt;Level, std::size_t&gt; m_logFlushThresholdMap;
<span class="lineNum">    2936 </span>            :     base::LogStreamsReferenceMap* m_logStreamsReference;
<span class="lineNum">    2937 </span>            : 
<span class="lineNum">    2938 </span>            :     friend class el::Helpers;
<span class="lineNum">    2939 </span>            :     friend class el::base::MessageBuilder;
<span class="lineNum">    2940 </span>            :     friend class el::base::Writer;
<span class="lineNum">    2941 </span>            :     friend class el::base::DefaultLogDispatchCallback;
<span class="lineNum">    2942 </span>            :     friend class el::base::LogDispatcher;
<a name="2943"><span class="lineNum">    2943 </span>            : </a>
<span class="lineNum">    2944 </span>            :     template &lt;typename Conf_T&gt;
<span class="lineNum">    2945 </span><span class="lineCov">       5046 :     inline Conf_T getConfigByVal(Level level, const std::map&lt;Level, Conf_T&gt;* confMap, const char* confName) {</span>
<span class="lineNum">    2946 </span><span class="lineCov">       5046 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    2947 </span><span class="lineCov">       5046 :         return unsafeGetConfigByVal(level, confMap, confName);  // This is not unsafe anymore - mutex locked in scope</span>
<span class="lineNum">    2948 </span>            :     }
<a name="2949"><span class="lineNum">    2949 </span>            : </a>
<span class="lineNum">    2950 </span>            :     template &lt;typename Conf_T&gt;
<span class="lineNum">    2951 </span><span class="lineCov">       3900 :     inline Conf_T&amp; getConfigByRef(Level level, std::map&lt;Level, Conf_T&gt;* confMap, const char* confName) {</span>
<span class="lineNum">    2952 </span><span class="lineCov">       3900 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    2953 </span><span class="lineCov">       3900 :         return unsafeGetConfigByRef(level, confMap, confName);  // This is not unsafe anymore - mutex locked in scope</span>
<span class="lineNum">    2954 </span>            :     }
<a name="2955"><span class="lineNum">    2955 </span>            : </a>
<span class="lineNum">    2956 </span>            :     template &lt;typename Conf_T&gt;
<span class="lineNum">    2957 </span><span class="lineCov">       5158 :     inline Conf_T unsafeGetConfigByVal(Level level, const std::map&lt;Level, Conf_T&gt;* confMap, const char* confName) {</span>
<span class="lineNum">    2958 </span>            :         ELPP_UNUSED(confName);
<span class="lineNum">    2959 </span><span class="lineCov">       5158 :         typename std::map&lt;Level, Conf_T&gt;::const_iterator it = confMap-&gt;find(level);</span>
<span class="lineNum">    2960 </span><span class="lineCov">       5158 :         if (it == confMap-&gt;end()) {</span>
<span class="lineNum">    2961 </span>            :             try {
<span class="lineNum">    2962 </span><span class="lineCov">       3900 :                 return confMap-&gt;at(Level::Global);</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :             } catch (...) {</span>
<span class="lineNum">    2964 </span>            :                 ELPP_INTERNAL_ERROR(&quot;Unable to get configuration [&quot; &lt;&lt; confName &lt;&lt; &quot;] for level [&quot; 
<span class="lineNum">    2965 </span>            :                     &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; &quot;]&quot;
<span class="lineNum">    2966 </span>            :                         &lt;&lt; std::endl &lt;&lt; &quot;Please ensure you have properly configured logger.&quot;, false);
<span class="lineNum">    2967 </span><span class="lineNoCov">          0 :                 return Conf_T();</span>
<span class="lineNum">    2968 </span>            :             }
<span class="lineNum">    2969 </span>            :         }
<span class="lineNum">    2970 </span><span class="lineCov">       1258 :         return it-&gt;second;</span>
<span class="lineNum">    2971 </span>            :     }
<a name="2972"><span class="lineNum">    2972 </span>            : </a>
<span class="lineNum">    2973 </span>            :     template &lt;typename Conf_T&gt;
<span class="lineNum">    2974 </span><span class="lineCov">       4012 :     inline Conf_T&amp; unsafeGetConfigByRef(Level level, std::map&lt;Level, Conf_T&gt;* confMap, const char* confName) {</span>
<span class="lineNum">    2975 </span>            :         ELPP_UNUSED(confName);
<span class="lineNum">    2976 </span><span class="lineCov">       4012 :         typename std::map&lt;Level, Conf_T&gt;::iterator it = confMap-&gt;find(level);</span>
<span class="lineNum">    2977 </span><span class="lineCov">       4012 :         if (it == confMap-&gt;end()) {</span>
<span class="lineNum">    2978 </span>            :             try {
<span class="lineNum">    2979 </span><span class="lineCov">       1244 :                 return confMap-&gt;at(Level::Global);</span>
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :             } catch (...) {</span>
<span class="lineNum">    2981 </span>            :                 ELPP_INTERNAL_ERROR(&quot;Unable to get configuration [&quot; &lt;&lt; confName &lt;&lt; &quot;] for level [&quot; 
<span class="lineNum">    2982 </span>            :                     &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; &quot;]&quot;
<span class="lineNum">    2983 </span>            :                         &lt;&lt; std::endl &lt;&lt; &quot;Please ensure you have properly configured logger.&quot;, false);
<span class="lineNum">    2984 </span>            :             }
<span class="lineNum">    2985 </span>            :         }
<span class="lineNum">    2986 </span><span class="lineCov">       2768 :         return it-&gt;second;</span>
<span class="lineNum">    2987 </span>            :     }
<a name="2988"><span class="lineNum">    2988 </span>            : </a>
<span class="lineNum">    2989 </span>            :     template &lt;typename Conf_T&gt;
<span class="lineNum">    2990 </span><span class="lineCov">        896 :     void setValue(Level level, const Conf_T&amp; value, std::map&lt;Level, Conf_T&gt;* confMap, bool includeGlobalLevel = true) {</span>
<span class="lineNum">    2991 </span>            :         // If map is empty and we are allowed to add into generic level (Level::Global), do it!
<span class="lineNum">    2992 </span><span class="lineCov">        896 :         if (confMap-&gt;empty() &amp;&amp; includeGlobalLevel) {</span>
<span class="lineNum">    2993 </span><span class="lineCov">        112 :             confMap-&gt;insert(std::make_pair(Level::Global, value));</span>
<span class="lineNum">    2994 </span><span class="lineCov">        870 :             return;</span>
<span class="lineNum">    2995 </span>            :         }
<span class="lineNum">    2996 </span>            :         // If same value exist in generic level already, dont add it to explicit level
<span class="lineNum">    2997 </span><span class="lineCov">        784 :         typename std::map&lt;Level, Conf_T&gt;::iterator it = confMap-&gt;find(Level::Global);</span>
<span class="lineNum">    2998 </span><span class="lineCov">        784 :         if (it != confMap-&gt;end() &amp;&amp; it-&gt;second == value) {</span>
<span class="lineNum">    2999 </span><span class="lineCov">        646 :             return;</span>
<span class="lineNum">    3000 </span>            :         }
<span class="lineNum">    3001 </span>            :         // Now make sure we dont double up values if we really need to add it to explicit level
<span class="lineNum">    3002 </span><span class="lineCov">        138 :         it = confMap-&gt;find(level);</span>
<span class="lineNum">    3003 </span><span class="lineCov">        138 :         if (it == confMap-&gt;end()) {</span>
<span class="lineNum">    3004 </span>            :             // Value not found for level, add new
<span class="lineNum">    3005 </span><span class="lineCov">        138 :             confMap-&gt;insert(std::make_pair(level, value));</span>
<span class="lineNum">    3006 </span>            :         } else {
<span class="lineNum">    3007 </span>            :             // Value found, just update value
<span class="lineNum">    3008 </span><span class="lineNoCov">          0 :             confMap-&gt;at(level) = value;</span>
<span class="lineNum">    3009 </span>            :         }
<a name="3010"><span class="lineNum">    3010 </span>            :     }</a>
<span class="lineNum">    3011 </span>            : 
<a name="3012"><span class="lineNum">    3012 </span><span class="lineCov">         14 :     void build(Configurations* configurations) {</span></a>
<span class="lineNum">    3013 </span><span class="lineCov">         14 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    3014 </span><span class="lineCov">        448 :         auto getBool = [] (std::string boolStr) -&gt; bool {  // Pass by value for trimming</span>
<span class="lineNum">    3015 </span><span class="lineCov">        448 :             base::utils::Str::trim(boolStr);</span>
<span class="lineNum">    3016 </span><span class="lineCov">        448 :             return (boolStr == &quot;TRUE&quot; || boolStr == &quot;true&quot; || boolStr == &quot;1&quot;);</span>
<span class="lineNum">    3017 </span><span class="lineNoCov">          0 :         };</span>
<span class="lineNum">    3018 </span><span class="lineCov">         28 :         std::vector&lt;Configuration*&gt; withFileSizeLimit;</span>
<span class="lineNum">    3019 </span><span class="lineCov">       1022 :         for (Configurations::const_iterator it = configurations-&gt;begin(); it != configurations-&gt;end(); ++it) {</span>
<span class="lineNum">    3020 </span><span class="lineCov">       1008 :             Configuration* conf = *it;</span>
<span class="lineNum">    3021 </span>            :             // We cannot use switch on strong enums because Intel C++ dont support them yet
<span class="lineNum">    3022 </span><span class="lineCov">       1008 :             if (conf-&gt;configurationType() == ConfigurationType::Enabled) {</span>
<span class="lineNum">    3023 </span><span class="lineCov">        112 :                 setValue(conf-&gt;level(), getBool(conf-&gt;value()), &amp;m_enabledMap);</span>
<span class="lineNum">    3024 </span><span class="lineCov">        896 :             } else if (conf-&gt;configurationType() == ConfigurationType::ToFile) {</span>
<span class="lineNum">    3025 </span><span class="lineCov">        112 :                 setValue(conf-&gt;level(), getBool(conf-&gt;value()), &amp;m_toFileMap);</span>
<span class="lineNum">    3026 </span><span class="lineCov">        784 :             } else if (conf-&gt;configurationType() == ConfigurationType::ToStandardOutput) {</span>
<span class="lineNum">    3027 </span><span class="lineCov">        112 :                 setValue(conf-&gt;level(), getBool(conf-&gt;value()), &amp;m_toStandardOutputMap);</span>
<span class="lineNum">    3028 </span><span class="lineCov">        672 :             } else if (conf-&gt;configurationType() == ConfigurationType::Filename) {</span>
<span class="lineNum">    3029 </span>            :             // We do not yet configure filename but we will configure in another
<span class="lineNum">    3030 </span>            :             // loop. This is because if file cannot be created, we will force ToFile
<span class="lineNum">    3031 </span>            :             // to be false. Because configuring logger is not necessarily performance
<span class="lineNum">    3032 </span>            :             // sensative operation, we can live with another loop; (by the way this loop
<span class="lineNum">    3033 </span>            :             // is not very heavy either)
<span class="lineNum">    3034 </span><span class="lineCov">        560 :             } else if (conf-&gt;configurationType() == ConfigurationType::Format) {</span>
<span class="lineNum">    3035 </span>            :                 setValue(conf-&gt;level(), base::LogFormat(conf-&gt;level(), 
<span class="lineNum">    3036 </span><span class="lineCov">        112 :                     base::type::string_t(conf-&gt;value().begin(), conf-&gt;value().end())), &amp;m_logFormatMap);</span>
<span class="lineNum">    3037 </span><span class="lineCov">        448 :             } else if (conf-&gt;configurationType() == ConfigurationType::MillisecondsWidth) {</span>
<span class="lineNum">    3038 </span>            :                 setValue(Level::Global, 
<span class="lineNum">    3039 </span><span class="lineCov">        112 :                     base::MillisecondsWidth(static_cast&lt;int&gt;(getULong(conf-&gt;value()))), &amp;m_millisecondsWidthMap);</span>
<span class="lineNum">    3040 </span><span class="lineCov">        336 :             } else if (conf-&gt;configurationType() == ConfigurationType::PerformanceTracking) {</span>
<span class="lineNum">    3041 </span><span class="lineCov">        112 :                 setValue(Level::Global, getBool(conf-&gt;value()), &amp;m_performanceTrackingMap);</span>
<span class="lineNum">    3042 </span><span class="lineCov">        224 :             } else if (conf-&gt;configurationType() == ConfigurationType::MaxLogFileSize) {</span>
<span class="lineNum">    3043 </span><span class="lineCov">        112 :                 setValue(conf-&gt;level(), static_cast&lt;std::size_t&gt;(getULong(conf-&gt;value())), &amp;m_maxLogFileSizeMap);</span>
<span class="lineNum">    3044 </span>            : #if !defined(ELPP_NO_DEFAULT_LOG_FILE)
<span class="lineNum">    3045 </span><span class="lineCov">        112 :                 withFileSizeLimit.push_back(conf);</span>
<span class="lineNum">    3046 </span>            : #endif  // !defined(ELPP_NO_DEFAULT_LOG_FILE)
<span class="lineNum">    3047 </span><span class="lineCov">        112 :             } else if (conf-&gt;configurationType() == ConfigurationType::LogFlushThreshold) {</span>
<span class="lineNum">    3048 </span><span class="lineCov">        112 :                 setValue(conf-&gt;level(), static_cast&lt;std::size_t&gt;(getULong(conf-&gt;value())), &amp;m_logFlushThresholdMap);</span>
<span class="lineNum">    3049 </span>            :             }
<span class="lineNum">    3050 </span>            :         }
<span class="lineNum">    3051 </span>            :         // As mentioned early, we will now set filename configuration in separate loop to deal with non-existent files
<span class="lineNum">    3052 </span><span class="lineCov">       1022 :         for (Configurations::const_iterator it = configurations-&gt;begin(); it != configurations-&gt;end(); ++it) {</span>
<span class="lineNum">    3053 </span><span class="lineCov">       1008 :             Configuration* conf = *it;</span>
<span class="lineNum">    3054 </span><span class="lineCov">       1008 :             if (conf-&gt;configurationType() == ConfigurationType::Filename) {</span>
<span class="lineNum">    3055 </span><span class="lineCov">        112 :                 insertFile(conf-&gt;level(), conf-&gt;value());</span>
<span class="lineNum">    3056 </span>            :             }
<span class="lineNum">    3057 </span>            :         }
<span class="lineNum">    3058 </span><span class="lineCov">        378 :         for (std::vector&lt;Configuration*&gt;::iterator conf = withFileSizeLimit.begin();</span>
<span class="lineNum">    3059 </span><span class="lineCov">        252 :                 conf != withFileSizeLimit.end(); ++conf) {</span>
<span class="lineNum">    3060 </span>            :                 // This is not unsafe as mutex is locked in currect scope
<span class="lineNum">    3061 </span><span class="lineCov">        112 :                 unsafeValidateFileRolling((*conf)-&gt;level(), base::defaultPreRollOutCallback);</span>
<span class="lineNum">    3062 </span><span class="lineCov">         14 :         }</span>
<a name="3063"><span class="lineNum">    3063 </span><span class="lineCov">         14 :     }</span></a>
<span class="lineNum">    3064 </span>            : 
<span class="lineNum">    3065 </span><span class="lineCov">        336 :     unsigned long getULong(std::string confVal) {</span>
<span class="lineNum">    3066 </span><span class="lineCov">        336 :         bool valid = true;</span>
<a name="3067"><span class="lineNum">    3067 </span><span class="lineCov">        336 :         base::utils::Str::trim(confVal);</span></a>
<span class="lineNum">    3068 </span><span class="lineCov">       1344 :         valid = !confVal.empty() &amp;&amp; std::find_if(confVal.begin(), confVal.end(),</span>
<span class="lineNum">    3069 </span><span class="lineCov">       1680 :                 [](char c) { return !base::utils::Str::isDigit(c); }) == confVal.end();</span>
<span class="lineNum">    3070 </span><span class="lineCov">        336 :         if (!valid) {</span>
<span class="lineNum">    3071 </span><span class="lineNoCov">          0 :             valid = false;</span>
<span class="lineNum">    3072 </span><span class="lineNoCov">          0 :             ELPP_ASSERT(valid, &quot;Configuration value not a valid integer [&quot; &lt;&lt; confVal &lt;&lt; &quot;]&quot;);</span>
<span class="lineNum">    3073 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    3074 </span>            :         }
<span class="lineNum">    3075 </span><span class="lineCov">        336 :         return atol(confVal.c_str());</span>
<a name="3076"><span class="lineNum">    3076 </span>            :     }</a>
<span class="lineNum">    3077 </span>            : 
<span class="lineNum">    3078 </span><span class="lineCov">        112 :     std::string resolveFilename(const std::string&amp; filename) {</span>
<span class="lineNum">    3079 </span><span class="lineCov">        112 :         std::string resultingFilename = filename;</span>
<span class="lineNum">    3080 </span><span class="lineCov">        112 :         std::size_t dateIndex = std::string::npos;</span>
<span class="lineNum">    3081 </span><span class="lineCov">        224 :         std::string dateTimeFormatSpecifierStr = std::string(base::consts::kDateTimeFormatSpecifierForFilename);</span>
<span class="lineNum">    3082 </span><span class="lineCov">        112 :         if ((dateIndex = resultingFilename.find(dateTimeFormatSpecifierStr.c_str())) != std::string::npos) {</span>
<span class="lineNum">    3083 </span><span class="lineCov">        128 :             while (dateIndex &gt; 0 &amp;&amp; resultingFilename[dateIndex - 1] == base::consts::kFormatSpecifierChar) {</span>
<span class="lineNum">    3084 </span><span class="lineNoCov">          0 :                 dateIndex = resultingFilename.find(dateTimeFormatSpecifierStr.c_str(), dateIndex + 1);</span>
<span class="lineNum">    3085 </span>            :             }
<span class="lineNum">    3086 </span><span class="lineCov">         64 :             if (dateIndex != std::string::npos) {</span>
<span class="lineNum">    3087 </span><span class="lineCov">         64 :                 const char* ptr = resultingFilename.c_str() + dateIndex;</span>
<span class="lineNum">    3088 </span>            :                 // Goto end of specifier
<span class="lineNum">    3089 </span><span class="lineCov">         64 :                 ptr += dateTimeFormatSpecifierStr.size();</span>
<span class="lineNum">    3090 </span><span class="lineCov">         64 :                 std::string fmt;</span>
<span class="lineNum">    3091 </span><span class="lineCov">         64 :                 if ((resultingFilename.size() &gt; dateIndex) &amp;&amp; (ptr[0] == '{')) {</span>
<span class="lineNum">    3092 </span>            :                     // User has provided format for date/time
<span class="lineNum">    3093 </span><span class="lineCov">         64 :                     ++ptr;</span>
<span class="lineNum">    3094 </span><span class="lineCov">         64 :                     int count = 1;  // Start by 1 in order to remove starting brace</span>
<span class="lineNum">    3095 </span><span class="lineCov">         64 :                     std::stringstream ss;</span>
<span class="lineNum">    3096 </span><span class="lineCov">        448 :                     for (; *ptr; ++ptr, ++count) {</span>
<span class="lineNum">    3097 </span><span class="lineCov">        448 :                         if (*ptr == '}') {</span>
<span class="lineNum">    3098 </span><span class="lineCov">         64 :                             ++count;  // In order to remove ending brace</span>
<span class="lineNum">    3099 </span><span class="lineCov">         64 :                             break;</span>
<span class="lineNum">    3100 </span>            :                         }
<span class="lineNum">    3101 </span><span class="lineCov">        384 :                         ss &lt;&lt; *ptr;</span>
<span class="lineNum">    3102 </span>            :                     }
<span class="lineNum">    3103 </span><span class="lineCov">         64 :                     resultingFilename.erase(dateIndex + dateTimeFormatSpecifierStr.size(), count);</span>
<span class="lineNum">    3104 </span><span class="lineCov">         64 :                     fmt = ss.str();</span>
<span class="lineNum">    3105 </span>            :                 } else {
<span class="lineNum">    3106 </span><span class="lineNoCov">          0 :                     fmt = std::string(base::consts::kDefaultDateTimeFormatInFilename);</span>
<span class="lineNum">    3107 </span>            :                 }
<span class="lineNum">    3108 </span><span class="lineCov">         64 :                 base::MillisecondsWidth msWidth(3);</span>
<span class="lineNum">    3109 </span><span class="lineCov">        128 :                 std::string now = base::utils::DateTime::getDateTime(fmt.c_str(), &amp;msWidth);</span>
<span class="lineNum">    3110 </span><span class="lineCov">         64 :                 base::utils::Str::replaceAll(now, '/', '-'); // Replace path element since we are dealing with filename</span>
<span class="lineNum">    3111 </span><span class="lineCov">        128 :                 base::utils::Str::replaceAll(resultingFilename, dateTimeFormatSpecifierStr, now);</span>
<span class="lineNum">    3112 </span>            :             }
<span class="lineNum">    3113 </span>            :         }
<span class="lineNum">    3114 </span><span class="lineCov">        224 :         return resultingFilename;</span>
<a name="3115"><span class="lineNum">    3115 </span>            :     }</a>
<span class="lineNum">    3116 </span>            : 
<span class="lineNum">    3117 </span><span class="lineCov">        112 :     void insertFile(Level level, const std::string&amp; fullFilename) {</span>
<span class="lineNum">    3118 </span><span class="lineCov">        112 :         std::string resolvedFilename = resolveFilename(fullFilename);</span>
<span class="lineNum">    3119 </span><span class="lineCov">        112 :         if (resolvedFilename.empty()) {</span>
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :             std::cerr &lt;&lt; &quot;Could not load empty file for logging, please re-check your configurations for level [&quot;</span>
<span class="lineNum">    3121 </span><span class="lineNoCov">          0 :                     &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; &quot;]&quot;;</span>
<span class="lineNum">    3122 </span>            :         }
<span class="lineNum">    3123 </span><span class="lineCov">        224 :         std::string filePath = base::utils::File::extractPathFromFilename(resolvedFilename, base::consts::kFilePathSeperator);</span>
<span class="lineNum">    3124 </span><span class="lineCov">        112 :         if (filePath.size() &lt; resolvedFilename.size()) {</span>
<a name="3125"><span class="lineNum">    3125 </span><span class="lineCov">        112 :             base::utils::File::createPath(filePath);</span></a>
<span class="lineNum">    3126 </span>            :         }
<span class="lineNum">    3127 </span><span class="lineCov">        112 :         auto create = [&amp;](Level level) {</span>
<span class="lineNum">    3128 </span><span class="lineCov">        112 :             base::LogStreamsReferenceMap::iterator filestreamIter = m_logStreamsReference-&gt;find(resolvedFilename);</span>
<span class="lineNum">    3129 </span><span class="lineCov">        112 :             base::type::fstream_t* fs = nullptr;</span>
<span class="lineNum">    3130 </span><span class="lineCov">        112 :             if (filestreamIter == m_logStreamsReference-&gt;end()) {</span>
<span class="lineNum">    3131 </span>            :                 // We need a completely new stream, nothing to share with
<span class="lineNum">    3132 </span><span class="lineCov">          4 :                 fs = base::utils::File::newFileStream(resolvedFilename);</span>
<span class="lineNum">    3133 </span><span class="lineCov">          4 :                 m_filenameMap.insert(std::make_pair(level, resolvedFilename));</span>
<span class="lineNum">    3134 </span><span class="lineCov">          4 :                 m_fileStreamMap.insert(std::make_pair(level, base::FileStreamPtr(fs)));</span>
<span class="lineNum">    3135 </span><span class="lineCov">          4 :                 m_logStreamsReference-&gt;insert(std::make_pair(resolvedFilename, base::FileStreamPtr(m_fileStreamMap.at(level))));</span>
<span class="lineNum">    3136 </span>            :             } else {
<span class="lineNum">    3137 </span>            :                 // Woops! we have an existing one, share it!
<span class="lineNum">    3138 </span><span class="lineCov">        108 :                 m_filenameMap.insert(std::make_pair(level, filestreamIter-&gt;first));</span>
<span class="lineNum">    3139 </span><span class="lineCov">        108 :                 m_fileStreamMap.insert(std::make_pair(level, base::FileStreamPtr(filestreamIter-&gt;second)));</span>
<span class="lineNum">    3140 </span><span class="lineCov">        108 :                 fs = filestreamIter-&gt;second.get();</span>
<span class="lineNum">    3141 </span>            :             }
<span class="lineNum">    3142 </span><span class="lineCov">        112 :             if (fs == nullptr) {</span>
<span class="lineNum">    3143 </span>            :                 // We display bad file error from newFileStream()
<span class="lineNum">    3144 </span>            :                 ELPP_INTERNAL_ERROR(&quot;Setting [TO_FILE] of [&quot; 
<span class="lineNum">    3145 </span>            :                     &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; &quot;] to FALSE&quot;, false);
<span class="lineNum">    3146 </span><span class="lineNoCov">          0 :                 setValue(level, false, &amp;m_toFileMap);</span>
<span class="lineNum">    3147 </span>            :             }
<span class="lineNum">    3148 </span><span class="lineCov">        224 :         };</span>
<span class="lineNum">    3149 </span>            :         // If we dont have file conf for any level, create it for Level::Global first
<span class="lineNum">    3150 </span>            :         // otherwise create for specified level
<span class="lineNum">    3151 </span><span class="lineCov">        224 :         create(m_filenameMap.empty() &amp;&amp; m_fileStreamMap.empty() ? Level::Global : level);</span>
<a name="3152"><span class="lineNum">    3152 </span><span class="lineCov">        112 :     }</span></a>
<span class="lineNum">    3153 </span>            : 
<span class="lineNum">    3154 </span><span class="lineCov">        112 :     bool unsafeValidateFileRolling(Level level, const PreRollOutCallback&amp; PreRollOutCallback) {</span>
<span class="lineNum">    3155 </span><span class="lineCov">        112 :         base::type::fstream_t* fs = unsafeGetConfigByRef(level, &amp;m_fileStreamMap, &quot;fileStream&quot;).get();</span>
<span class="lineNum">    3156 </span><span class="lineCov">        112 :         if (fs == nullptr) {</span>
<span class="lineNum">    3157 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    3158 </span>            :         }
<span class="lineNum">    3159 </span><span class="lineCov">        112 :         std::size_t maxLogFileSize = unsafeGetConfigByVal(level, &amp;m_maxLogFileSizeMap, &quot;maxLogFileSize&quot;);</span>
<span class="lineNum">    3160 </span><span class="lineCov">        112 :         std::size_t currFileSize = base::utils::File::getSizeOfFile(fs);</span>
<span class="lineNum">    3161 </span><span class="lineCov">        112 :         if (maxLogFileSize != 0 &amp;&amp; currFileSize &gt;= maxLogFileSize) {</span>
<span class="lineNum">    3162 </span><span class="lineNoCov">          0 :             std::string fname = unsafeGetConfigByRef(level, &amp;m_filenameMap, &quot;filename&quot;);</span>
<span class="lineNum">    3163 </span>            :             ELPP_INTERNAL_INFO(1, &quot;Truncating log file [&quot; &lt;&lt; fname &lt;&lt; &quot;] as a result of configurations for level [&quot;
<span class="lineNum">    3164 </span>            :                     &lt;&lt; LevelHelper::convertToString(level) &lt;&lt; &quot;]&quot;);
<span class="lineNum">    3165 </span><span class="lineNoCov">          0 :             fs-&gt;close();</span>
<span class="lineNum">    3166 </span><span class="lineNoCov">          0 :             PreRollOutCallback(fname.c_str(), currFileSize);</span>
<span class="lineNum">    3167 </span><span class="lineNoCov">          0 :             fs-&gt;open(fname, std::fstream::out | std::fstream::trunc);</span>
<span class="lineNum">    3168 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    3169 </span>            :         }
<span class="lineNum">    3170 </span><span class="lineCov">        112 :         return false;</span>
<a name="3171"><span class="lineNum">    3171 </span>            :     }</a>
<span class="lineNum">    3172 </span>            : 
<span class="lineNum">    3173 </span><span class="lineNoCov">          0 :     bool validateFileRolling(Level level, const PreRollOutCallback&amp; PreRollOutCallback) {</span>
<span class="lineNum">    3174 </span><span class="lineNoCov">          0 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    3175 </span><span class="lineNoCov">          0 :         return unsafeValidateFileRolling(level, PreRollOutCallback);</span>
<span class="lineNum">    3176 </span>            :     }
<span class="lineNum">    3177 </span>            : };
<span class="lineNum">    3178 </span>            : /// @brief Class that keeps record of current line hit for occasional logging
<span class="lineNum">    3179 </span>            : class HitCounter {
<span class="lineNum">    3180 </span>            : public:
<span class="lineNum">    3181 </span>            :     HitCounter(void) :
<span class="lineNum">    3182 </span>            :         m_filename(&quot;&quot;),
<span class="lineNum">    3183 </span>            :         m_lineNumber(0),
<span class="lineNum">    3184 </span>            :         m_hitCounts(0) {
<span class="lineNum">    3185 </span>            :     }
<span class="lineNum">    3186 </span>            : 
<span class="lineNum">    3187 </span>            :     HitCounter(const char* filename, unsigned long int lineNumber) :
<span class="lineNum">    3188 </span>            :         m_filename(filename),
<span class="lineNum">    3189 </span>            :         m_lineNumber(lineNumber),
<span class="lineNum">    3190 </span>            :         m_hitCounts(0) {
<a name="3191"><span class="lineNum">    3191 </span>            :     }</a>
<span class="lineNum">    3192 </span>            : 
<span class="lineNum">    3193 </span><span class="lineNoCov">          0 :     HitCounter(const HitCounter&amp; hitCounter) :</span>
<span class="lineNum">    3194 </span>            :         m_filename(hitCounter.m_filename),
<span class="lineNum">    3195 </span>            :         m_lineNumber(hitCounter.m_lineNumber),
<span class="lineNum">    3196 </span><span class="lineNoCov">          0 :         m_hitCounts(hitCounter.m_hitCounts) {</span>
<span class="lineNum">    3197 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3198 </span>            : 
<span class="lineNum">    3199 </span>            :     HitCounter&amp; operator=(const HitCounter&amp; hitCounter) {
<span class="lineNum">    3200 </span>            :         m_filename = hitCounter.m_filename;
<span class="lineNum">    3201 </span>            :         m_lineNumber = hitCounter.m_lineNumber;
<span class="lineNum">    3202 </span>            :         m_hitCounts = hitCounter.m_hitCounts;
<span class="lineNum">    3203 </span>            :         return *this;
<a name="3204"><span class="lineNum">    3204 </span>            :     }</a>
<span class="lineNum">    3205 </span>            : 
<span class="lineNum">    3206 </span><span class="lineNoCov">          0 :     virtual ~HitCounter(void) {</span>
<span class="lineNum">    3207 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3208 </span>            : 
<span class="lineNum">    3209 </span>            :     /// @brief Resets location of current hit counter
<span class="lineNum">    3210 </span>            :     inline void resetLocation(const char* filename, unsigned long int lineNumber) {
<span class="lineNum">    3211 </span>            :         m_filename = filename;
<span class="lineNum">    3212 </span>            :         m_lineNumber = lineNumber;
<span class="lineNum">    3213 </span>            :     }
<span class="lineNum">    3214 </span>            : 
<span class="lineNum">    3215 </span>            :     /// @brief Validates hit counts and resets it if necessary
<span class="lineNum">    3216 </span>            :     inline void validateHitCounts(std::size_t n) {
<span class="lineNum">    3217 </span>            :         if (m_hitCounts &gt;= base::consts::kMaxLogPerCounter) {
<span class="lineNum">    3218 </span>            :             m_hitCounts = (n &gt;= 1 ? base::consts::kMaxLogPerCounter % n : 0);
<span class="lineNum">    3219 </span>            :         }
<span class="lineNum">    3220 </span>            :         ++m_hitCounts;
<span class="lineNum">    3221 </span>            :     }
<span class="lineNum">    3222 </span>            : 
<span class="lineNum">    3223 </span>            :     inline const char* filename(void) const {
<span class="lineNum">    3224 </span>            :         return m_filename;
<span class="lineNum">    3225 </span>            :     }
<span class="lineNum">    3226 </span>            : 
<span class="lineNum">    3227 </span>            :     inline unsigned long int lineNumber(void) const {
<span class="lineNum">    3228 </span>            :         return m_lineNumber;
<span class="lineNum">    3229 </span>            :     }
<span class="lineNum">    3230 </span>            : 
<span class="lineNum">    3231 </span>            :     inline std::size_t hitCounts(void) const {
<span class="lineNum">    3232 </span>            :         return m_hitCounts;
<span class="lineNum">    3233 </span>            :     }
<span class="lineNum">    3234 </span>            : 
<span class="lineNum">    3235 </span>            :     inline void increment(void) {
<span class="lineNum">    3236 </span>            :         ++m_hitCounts;
<span class="lineNum">    3237 </span>            :     }
<span class="lineNum">    3238 </span>            : 
<span class="lineNum">    3239 </span>            :     class Predicate {
<span class="lineNum">    3240 </span>            :     public:
<span class="lineNum">    3241 </span>            :         Predicate(const char* filename, unsigned long int lineNumber)
<span class="lineNum">    3242 </span>            :             : m_filename(filename),
<span class="lineNum">    3243 </span>            :               m_lineNumber(lineNumber) {
<span class="lineNum">    3244 </span>            :         }
<span class="lineNum">    3245 </span>            :         inline bool operator()(const HitCounter* counter) {
<span class="lineNum">    3246 </span>            :             return ((counter != nullptr) &amp;&amp;
<span class="lineNum">    3247 </span>            :                     (strcmp(counter-&gt;m_filename, m_filename) == 0) &amp;&amp;
<span class="lineNum">    3248 </span>            :                     (counter-&gt;m_lineNumber == m_lineNumber));
<span class="lineNum">    3249 </span>            :         }
<span class="lineNum">    3250 </span>            : 
<span class="lineNum">    3251 </span>            :     private:
<span class="lineNum">    3252 </span>            :         const char* m_filename;
<span class="lineNum">    3253 </span>            :         unsigned long int m_lineNumber;
<span class="lineNum">    3254 </span>            :     };
<span class="lineNum">    3255 </span>            : 
<span class="lineNum">    3256 </span>            : private:
<span class="lineNum">    3257 </span>            :     const char* m_filename;
<span class="lineNum">    3258 </span>            :     unsigned long int m_lineNumber;
<span class="lineNum">    3259 </span>            :     std::size_t m_hitCounts;
<a name="3260"><span class="lineNum">    3260 </span>            : };</a>
<span class="lineNum">    3261 </span>            : /// @brief Repository for hit counters used across the application
<span class="lineNum">    3262 </span><span class="lineCov">          2 : class RegisteredHitCounters : public base::utils::RegistryWithPred&lt;base::HitCounter, base::HitCounter::Predicate&gt; {</span>
<span class="lineNum">    3263 </span>            : public:
<span class="lineNum">    3264 </span>            :     /// @brief Validates counter for every N, i.e, registers new if does not exist otherwise updates original one
<span class="lineNum">    3265 </span>            :     /// @return True if validation resulted in triggering hit. Meaning logs should be written everytime true is returned
<span class="lineNum">    3266 </span>            :     bool validateEveryN(const char* filename, unsigned long int lineNumber, std::size_t n) {
<span class="lineNum">    3267 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3268 </span>            :         base::HitCounter* counter = get(filename, lineNumber);
<span class="lineNum">    3269 </span>            :         if (counter == nullptr) {
<span class="lineNum">    3270 </span>            :             registerNew(counter = new base::HitCounter(filename, lineNumber));
<span class="lineNum">    3271 </span>            :         }
<span class="lineNum">    3272 </span>            :         counter-&gt;validateHitCounts(n);
<span class="lineNum">    3273 </span>            :         bool result = (n &gt;= 1 &amp;&amp; counter-&gt;hitCounts() != 0 &amp;&amp; counter-&gt;hitCounts() % n == 0);
<span class="lineNum">    3274 </span>            :         return result;
<span class="lineNum">    3275 </span>            :     }
<span class="lineNum">    3276 </span>            : 
<span class="lineNum">    3277 </span>            :     /// @brief Validates counter for hits &gt;= N, i.e, registers new if does not exist otherwise updates original one
<span class="lineNum">    3278 </span>            :     /// @return True if validation resulted in triggering hit. Meaning logs should be written everytime true is returned
<span class="lineNum">    3279 </span>            :     bool validateAfterN(const char* filename, unsigned long int lineNumber, std::size_t n) {
<span class="lineNum">    3280 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3281 </span>            :         base::HitCounter* counter = get(filename, lineNumber);
<span class="lineNum">    3282 </span>            :         if (counter == nullptr) {
<span class="lineNum">    3283 </span>            :             registerNew(counter = new base::HitCounter(filename, lineNumber));
<span class="lineNum">    3284 </span>            :         }
<span class="lineNum">    3285 </span>            :         // Do not use validateHitCounts here since we do not want to reset counter here
<span class="lineNum">    3286 </span>            :         // Note the &gt;= instead of &gt; because we are incrementing
<span class="lineNum">    3287 </span>            :         // after this check
<span class="lineNum">    3288 </span>            :         if (counter-&gt;hitCounts() &gt;= n)
<span class="lineNum">    3289 </span>            :             return true;
<span class="lineNum">    3290 </span>            :         counter-&gt;increment();
<span class="lineNum">    3291 </span>            :         return false;
<span class="lineNum">    3292 </span>            :     }
<span class="lineNum">    3293 </span>            : 
<span class="lineNum">    3294 </span>            :     /// @brief Validates counter for hits are &lt;= n, i.e, registers new if does not exist otherwise updates original one
<span class="lineNum">    3295 </span>            :     /// @return True if validation resulted in triggering hit. Meaning logs should be written everytime true is returned
<span class="lineNum">    3296 </span>            :     bool validateNTimes(const char* filename, unsigned long int lineNumber, std::size_t n) {
<span class="lineNum">    3297 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3298 </span>            :         base::HitCounter* counter = get(filename, lineNumber);
<span class="lineNum">    3299 </span>            :         if (counter == nullptr) {
<span class="lineNum">    3300 </span>            :             registerNew(counter = new base::HitCounter(filename, lineNumber));
<span class="lineNum">    3301 </span>            :         }
<span class="lineNum">    3302 </span>            :         counter-&gt;increment();
<span class="lineNum">    3303 </span>            :         // Do not use validateHitCounts here since we do not want to reset counter here
<span class="lineNum">    3304 </span>            :         if (counter-&gt;hitCounts() &lt;= n)
<span class="lineNum">    3305 </span>            :             return true;
<span class="lineNum">    3306 </span>            :         return false;
<span class="lineNum">    3307 </span>            :     }
<span class="lineNum">    3308 </span>            : 
<span class="lineNum">    3309 </span>            :     /// @brief Gets hit counter registered at specified position
<span class="lineNum">    3310 </span>            :     inline const base::HitCounter* getCounter(const char* filename, unsigned long int lineNumber) {
<span class="lineNum">    3311 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3312 </span>            :         return get(filename, lineNumber);
<span class="lineNum">    3313 </span>            :     }
<span class="lineNum">    3314 </span>            : };
<span class="lineNum">    3315 </span>            : /// @brief Action to be taken for dispatching
<span class="lineNum">    3316 </span>            : enum class DispatchAction : base::type::EnumType {
<span class="lineNum">    3317 </span>            :     None = 1, NormalLog = 2, SysLog = 4
<span class="lineNum">    3318 </span>            : };
<a name="3319"><span class="lineNum">    3319 </span>            : }  // namespace base</a>
<span class="lineNum">    3320 </span>            : template &lt;typename T&gt;
<a name="3321"><span class="lineNum">    3321 </span><span class="lineNoCov">          0 : class Callback : protected base::threading::ThreadSafe {</span></a>
<a name="3322"><span class="lineNum">    3322 </span>            : public:</a>
<span class="lineNum">    3323 </span><span class="lineCov">          4 :     Callback(void) : m_enabled(true) {}</span>
<span class="lineNum">    3324 </span><span class="lineCov">       1244 :     inline bool enabled(void) const { return m_enabled; }</span>
<span class="lineNum">    3325 </span>            :     inline void setEnabled(bool enabled) {
<span class="lineNum">    3326 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3327 </span>            :         m_enabled = enabled;
<span class="lineNum">    3328 </span>            :     }
<span class="lineNum">    3329 </span>            : protected:
<span class="lineNum">    3330 </span>            :     virtual void handle(const T* handlePtr) = 0;
<span class="lineNum">    3331 </span>            : private:
<span class="lineNum">    3332 </span>            :     bool m_enabled;
<span class="lineNum">    3333 </span>            : };
<a name="3334"><span class="lineNum">    3334 </span>            : class LogDispatchData {</a>
<a name="3335"><span class="lineNum">    3335 </span>            : public:</a>
<a name="3336"><span class="lineNum">    3336 </span><span class="lineCov">       1244 :     LogDispatchData() : m_logMessage(nullptr), m_dispatchAction(base::DispatchAction::None) {}</span></a>
<span class="lineNum">    3337 </span><span class="lineCov">      17416 :     inline const LogMessage* logMessage(void) const { return m_logMessage; }</span>
<span class="lineNum">    3338 </span><span class="lineCov">       2488 :     inline base::DispatchAction dispatchAction(void) const { return m_dispatchAction; }</span>
<span class="lineNum">    3339 </span>            : private:
<span class="lineNum">    3340 </span>            :     LogMessage* m_logMessage;
<span class="lineNum">    3341 </span>            :     base::DispatchAction m_dispatchAction;
<a name="3342"><span class="lineNum">    3342 </span>            :     friend class base::LogDispatcher;</a>
<a name="3343"><span class="lineNum">    3343 </span>            : </a>
<span class="lineNum">    3344 </span><span class="lineCov">       1244 :     inline void setLogMessage(LogMessage* logMessage) { m_logMessage = logMessage; }</span>
<a name="3345"><span class="lineNum">    3345 </span><span class="lineCov">       1244 :     inline void setDispatchAction(base::DispatchAction dispatchAction) { m_dispatchAction = dispatchAction; }</span></a>
<span class="lineNum">    3346 </span>            : };
<span class="lineNum">    3347 </span><span class="lineCov">          2 : class LogDispatchCallback : public Callback&lt;LogDispatchData&gt; {</span>
<span class="lineNum">    3348 </span>            : private:
<a name="3349"><span class="lineNum">    3349 </span>            :     friend class base::LogDispatcher;</a>
<span class="lineNum">    3350 </span>            : };
<span class="lineNum">    3351 </span><span class="lineCov">          2 : class PerformanceTrackingCallback : public Callback&lt;PerformanceTrackingData&gt; {</span>
<span class="lineNum">    3352 </span>            : private:
<a name="3353"><span class="lineNum">    3353 </span>            :     friend class base::PerformanceTracker;</a>
<span class="lineNum">    3354 </span>            : };
<a name="3355"><span class="lineNum">    3355 </span><span class="lineCov">          2 : class LogBuilder : base::NoCopy {</span></a>
<span class="lineNum">    3356 </span>            : public:
<a name="3357"><span class="lineNum">    3357 </span><span class="lineNoCov">          0 :     virtual ~LogBuilder(void) { ELPP_INTERNAL_INFO(3, &quot;Destroying log builder...&quot;)}</span></a>
<span class="lineNum">    3358 </span>            :     virtual base::type::string_t build(const LogMessage* logMessage, bool appendNewLine) const = 0;
<span class="lineNum">    3359 </span><span class="lineCov">       1244 :     void convertToColoredOutput(base::type::string_t* logLine, Level level) {</span>
<span class="lineNum">    3360 </span><span class="lineCov">       2488 :         if (!base::utils::s_termSupportsColor) return;</span>
<span class="lineNum">    3361 </span><span class="lineCov">       1244 :         const base::type::char_t* resetColor = ELPP_LITERAL(&quot;\x1b[0m&quot;);</span>
<span class="lineNum">    3362 </span><span class="lineCov">       1244 :         if (level == Level::Error || level == Level::Fatal)</span>
<span class="lineNum">    3363 </span><span class="lineNoCov">          0 :             *logLine = ELPP_LITERAL(&quot;\x1b[31m&quot;) + *logLine + resetColor;</span>
<span class="lineNum">    3364 </span><span class="lineCov">       1244 :         else if (level == Level::Warning)</span>
<span class="lineNum">    3365 </span><span class="lineCov">          4 :             *logLine = ELPP_LITERAL(&quot;\x1b[33m&quot;) + *logLine + resetColor;</span>
<span class="lineNum">    3366 </span>            :     }
<span class="lineNum">    3367 </span>            : private:
<span class="lineNum">    3368 </span>            :     friend class el::base::DefaultLogDispatchCallback;
<span class="lineNum">    3369 </span>            : };
<span class="lineNum">    3370 </span>            : typedef std::shared_ptr&lt;LogBuilder&gt; LogBuilderPtr;
<span class="lineNum">    3371 </span>            : /// @brief Represents a logger holding ID and configurations we need to write logs
<span class="lineNum">    3372 </span>            : ///
<span class="lineNum">    3373 </span>            : /// @detail This class does not write logs itself instead its used by writer to read configuations from.
<span class="lineNum">    3374 </span>            : class Logger : public base::threading::ThreadSafe, public Loggable {
<span class="lineNum">    3375 </span>            : public:
<span class="lineNum">    3376 </span>            :     Logger(const std::string&amp; id, base::LogStreamsReferenceMap* logStreamsReference) :
<span class="lineNum">    3377 </span>            :             m_id(id),
<span class="lineNum">    3378 </span>            :             m_typedConfigurations(nullptr),
<span class="lineNum">    3379 </span>            :             m_parentApplicationName(std::string()),
<span class="lineNum">    3380 </span>            :             m_isConfigured(false),
<span class="lineNum">    3381 </span>            :             m_logStreamsReference(logStreamsReference) {
<span class="lineNum">    3382 </span>            :         initUnflushedCount();
<a name="3383"><span class="lineNum">    3383 </span>            :     }</a>
<span class="lineNum">    3384 </span>            : 
<span class="lineNum">    3385 </span><span class="lineCov">          4 :     Logger(const std::string&amp; id, const Configurations&amp; configurations, base::LogStreamsReferenceMap* logStreamsReference) :</span>
<span class="lineNum">    3386 </span>            :             m_id(id),
<span class="lineNum">    3387 </span>            :             m_typedConfigurations(nullptr),
<span class="lineNum">    3388 </span>            :             m_parentApplicationName(std::string()),
<span class="lineNum">    3389 </span>            :             m_isConfigured(false),
<span class="lineNum">    3390 </span><span class="lineCov">          4 :             m_logStreamsReference(logStreamsReference) {</span>
<span class="lineNum">    3391 </span><span class="lineCov">          4 :         initUnflushedCount();</span>
<span class="lineNum">    3392 </span><span class="lineCov">          4 :         configure(configurations);</span>
<a name="3393"><span class="lineNum">    3393 </span><span class="lineCov">          4 :     }</span></a>
<span class="lineNum">    3394 </span>            : 
<span class="lineNum">    3395 </span><span class="lineNoCov">          0 :     Logger(const Logger&amp; logger) {</span>
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :         base::utils::safeDelete(m_typedConfigurations);</span>
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :         m_id = logger.m_id;</span>
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 :         m_typedConfigurations = logger.m_typedConfigurations;</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :         m_parentApplicationName = logger.m_parentApplicationName;</span>
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :         m_isConfigured = logger.m_isConfigured;</span>
<span class="lineNum">    3401 </span><span class="lineNoCov">          0 :         m_configurations = logger.m_configurations;</span>
<span class="lineNum">    3402 </span><span class="lineNoCov">          0 :         m_unflushedCount = logger.m_unflushedCount;</span>
<span class="lineNum">    3403 </span><span class="lineNoCov">          0 :         m_logStreamsReference = logger.m_logStreamsReference;</span>
<span class="lineNum">    3404 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3405 </span>            : 
<span class="lineNum">    3406 </span>            :     Logger&amp; operator=(const Logger&amp; logger) {
<span class="lineNum">    3407 </span>            :         base::utils::safeDelete(m_typedConfigurations);
<span class="lineNum">    3408 </span>            :         m_id = logger.m_id;
<span class="lineNum">    3409 </span>            :         m_typedConfigurations = logger.m_typedConfigurations;
<span class="lineNum">    3410 </span>            :         m_parentApplicationName = logger.m_parentApplicationName;
<span class="lineNum">    3411 </span>            :         m_isConfigured = logger.m_isConfigured;
<span class="lineNum">    3412 </span>            :         m_configurations = logger.m_configurations;
<span class="lineNum">    3413 </span>            :         m_unflushedCount = logger.m_unflushedCount;
<span class="lineNum">    3414 </span>            :         m_logStreamsReference = logger.m_logStreamsReference;
<span class="lineNum">    3415 </span>            :         return *this;
<a name="3416"><span class="lineNum">    3416 </span>            :     }</a>
<span class="lineNum">    3417 </span>            : 
<span class="lineNum">    3418 </span><span class="lineNoCov">          0 :     virtual ~Logger(void) {</span>
<span class="lineNum">    3419 </span><span class="lineNoCov">          0 :         base::utils::safeDelete(m_typedConfigurations);</span>
<a name="3420"><span class="lineNum">    3420 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    3421 </span>            : 
<span class="lineNum">    3422 </span><span class="lineNoCov">          0 :     virtual inline void log(el::base::type::ostream_t&amp; os) const {</span>
<span class="lineNum">    3423 </span><span class="lineNoCov">          0 :         os &lt;&lt; m_id.c_str();</span>
<span class="lineNum">    3424 </span><span class="lineNoCov">          0 :     }</span>
<a name="3425"><span class="lineNum">    3425 </span>            : </a>
<span class="lineNum">    3426 </span>            :     /// @brief Configures the logger using specified configurations.
<span class="lineNum">    3427 </span><span class="lineCov">         14 :     void configure(const Configurations&amp; configurations) {</span>
<span class="lineNum">    3428 </span><span class="lineCov">         14 :         m_isConfigured = false;  // we set it to false in case if we fail</span>
<span class="lineNum">    3429 </span><span class="lineCov">         14 :         initUnflushedCount();</span>
<span class="lineNum">    3430 </span><span class="lineCov">         14 :         if (m_typedConfigurations != nullptr) {</span>
<span class="lineNum">    3431 </span><span class="lineCov">         10 :             Configurations* c = const_cast&lt;Configurations*&gt;(m_typedConfigurations-&gt;configurations());</span>
<span class="lineNum">    3432 </span><span class="lineCov">         10 :             if (c-&gt;hasConfiguration(Level::Global, ConfigurationType::Filename)) {</span>
<span class="lineNum">    3433 </span>            :                 // This check is definitely needed for cases like ELPP_NO_DEFAULT_LOG_FILE
<span class="lineNum">    3434 </span><span class="lineCov">         10 :                 flush();</span>
<span class="lineNum">    3435 </span>            :             }
<span class="lineNum">    3436 </span>            :         }
<span class="lineNum">    3437 </span><span class="lineCov">         14 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    3438 </span><span class="lineCov">         14 :         if (m_configurations != configurations) {</span>
<span class="lineNum">    3439 </span><span class="lineCov">         12 :             m_configurations.setFromBase(const_cast&lt;Configurations*&gt;(&amp;configurations));</span>
<span class="lineNum">    3440 </span>            :         }
<span class="lineNum">    3441 </span><span class="lineCov">         14 :         base::utils::safeDelete(m_typedConfigurations);</span>
<span class="lineNum">    3442 </span><span class="lineCov">         14 :         m_typedConfigurations = new base::TypedConfigurations(&amp;m_configurations, m_logStreamsReference);</span>
<span class="lineNum">    3443 </span><span class="lineCov">         14 :         resolveLoggerFormatSpec();</span>
<span class="lineNum">    3444 </span><span class="lineCov">         14 :         m_isConfigured = true;</span>
<span class="lineNum">    3445 </span><span class="lineCov">         14 :     }</span>
<a name="3446"><span class="lineNum">    3446 </span>            : </a>
<span class="lineNum">    3447 </span>            :     /// @brief Reconfigures logger using existing configurations
<span class="lineNum">    3448 </span><span class="lineCov">          2 :     inline void reconfigure(void) {</span>
<span class="lineNum">    3449 </span>            :         ELPP_INTERNAL_INFO(1, &quot;Reconfiguring logger [&quot; &lt;&lt; m_id &lt;&lt; &quot;]&quot;);
<span class="lineNum">    3450 </span><span class="lineCov">          2 :         configure(m_configurations);</span>
<span class="lineNum">    3451 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    3452 </span>            : 
<span class="lineNum">    3453 </span>            :     inline const std::string&amp; id(void) const {
<span class="lineNum">    3454 </span>            :         return m_id;
<a name="3455"><span class="lineNum">    3455 </span>            :     }</a>
<span class="lineNum">    3456 </span>            : 
<span class="lineNum">    3457 </span><span class="lineNoCov">          0 :     inline const std::string&amp; parentApplicationName(void) const {</span>
<span class="lineNum">    3458 </span><span class="lineNoCov">          0 :         return m_parentApplicationName;</span>
<span class="lineNum">    3459 </span>            :     }
<span class="lineNum">    3460 </span>            : 
<span class="lineNum">    3461 </span>            :     inline void setParentApplicationName(const std::string&amp; parentApplicationName) {
<span class="lineNum">    3462 </span>            :         m_parentApplicationName = parentApplicationName;
<a name="3463"><span class="lineNum">    3463 </span>            :     }</a>
<span class="lineNum">    3464 </span>            : 
<span class="lineNum">    3465 </span><span class="lineCov">          2 :     inline Configurations* configurations(void) {</span>
<span class="lineNum">    3466 </span><span class="lineCov">          2 :         return &amp;m_configurations;</span>
<a name="3467"><span class="lineNum">    3467 </span>            :     }</a>
<span class="lineNum">    3468 </span>            : 
<span class="lineNum">    3469 </span><span class="lineCov">       1244 :     inline base::TypedConfigurations* typedConfigurations(void) {</span>
<span class="lineNum">    3470 </span><span class="lineCov">       1244 :         return m_typedConfigurations;</span>
<a name="3471"><span class="lineNum">    3471 </span>            :     }</a>
<span class="lineNum">    3472 </span>            : 
<span class="lineNum">    3473 </span><span class="lineCov">          4 :     static inline bool isValidId(const std::string&amp; id) {</span>
<span class="lineNum">    3474 </span><span class="lineCov">         40 :         for (std::string::const_iterator it = id.begin(); it != id.end(); ++it) {</span>
<span class="lineNum">    3475 </span><span class="lineCov">         36 :             if (!base::utils::Str::contains(base::consts::kValidLoggerIdSymbols, *it)) {</span>
<span class="lineNum">    3476 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    3477 </span>            :             }
<span class="lineNum">    3478 </span>            :         }
<span class="lineNum">    3479 </span><span class="lineCov">          4 :         return true;</span>
<a name="3480"><span class="lineNum">    3480 </span>            :     }</a>
<span class="lineNum">    3481 </span>            :     /// @brief Flushes logger to sync all log files for all levels
<span class="lineNum">    3482 </span><span class="lineCov">         10 :     inline void flush(void) {</span>
<span class="lineNum">    3483 </span>            :         ELPP_INTERNAL_INFO(3, &quot;Flushing logger [&quot; &lt;&lt; m_id &lt;&lt; &quot;] all levels&quot;);
<a name="3484"><span class="lineNum">    3484 </span><span class="lineCov">         10 :         base::threading::ScopedLock scopedLock(lock());</span></a>
<span class="lineNum">    3485 </span><span class="lineCov">         10 :         base::type::EnumType lIndex = LevelHelper::kMinValid;</span>
<span class="lineNum">    3486 </span><span class="lineCov">         70 :         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](void) -&gt; bool {</span>
<span class="lineNum">    3487 </span><span class="lineCov">         70 :             flush(LevelHelper::castFromInt(lIndex), nullptr);</span>
<span class="lineNum">    3488 </span><span class="lineCov">         70 :             return false;</span>
<span class="lineNum">    3489 </span><span class="lineCov">         10 :         });</span>
<a name="3490"><span class="lineNum">    3490 </span><span class="lineCov">         10 :     }</span></a>
<span class="lineNum">    3491 </span>            : 
<span class="lineNum">    3492 </span><span class="lineCov">       1314 :     inline void flush(Level level, base::type::fstream_t* fs) {</span>
<span class="lineNum">    3493 </span><span class="lineCov">       1314 :         if (fs == nullptr &amp;&amp; m_typedConfigurations-&gt;toFile(level)) {</span>
<span class="lineNum">    3494 </span><span class="lineCov">         70 :             fs = m_typedConfigurations-&gt;fileStream(level);</span>
<span class="lineNum">    3495 </span>            :         }
<span class="lineNum">    3496 </span><span class="lineCov">       1314 :         if (fs != nullptr) {</span>
<span class="lineNum">    3497 </span><span class="lineCov">       1314 :             fs-&gt;flush();</span>
<span class="lineNum">    3498 </span><span class="lineCov">       1314 :             m_unflushedCount.find(level)-&gt;second = 0;</span>
<span class="lineNum">    3499 </span>            :         }
<a name="3500"><span class="lineNum">    3500 </span><span class="lineCov">       1314 :     }</span></a>
<span class="lineNum">    3501 </span>            : 
<span class="lineNum">    3502 </span><span class="lineCov">       1244 :     inline bool isFlushNeeded(Level level) {</span>
<span class="lineNum">    3503 </span><span class="lineCov">       1244 :         return ++m_unflushedCount.find(level)-&gt;second &gt;= m_typedConfigurations-&gt;logFlushThreshold(level);</span>
<a name="3504"><span class="lineNum">    3504 </span>            :     }</a>
<span class="lineNum">    3505 </span>            : 
<span class="lineNum">    3506 </span><span class="lineCov">       2488 :     inline LogBuilder* logBuilder(void) const {</span>
<span class="lineNum">    3507 </span><span class="lineCov">       2488 :         return m_logBuilder.get();</span>
<span class="lineNum">    3508 </span>            :     }
<span class="lineNum">    3509 </span>            : 
<span class="lineNum">    3510 </span>            :     inline void setLogBuilder(const LogBuilderPtr&amp; logBuilder) {
<span class="lineNum">    3511 </span>            :         m_logBuilder = logBuilder;
<a name="3512"><span class="lineNum">    3512 </span>            :     }</a>
<span class="lineNum">    3513 </span>            : 
<span class="lineNum">    3514 </span><span class="lineCov">       1244 :     inline bool enabled(Level level) const {</span>
<span class="lineNum">    3515 </span><span class="lineCov">       1244 :         return m_typedConfigurations-&gt;enabled(level);</span>
<span class="lineNum">    3516 </span>            :     }
<span class="lineNum">    3517 </span>            :     
<span class="lineNum">    3518 </span>            : #if ELPP_VARIADIC_TEMPLATES_SUPPORTED
<span class="lineNum">    3519 </span>            : #   define LOGGER_LEVEL_WRITERS_SIGNATURES(FUNCTION_NAME)\
<span class="lineNum">    3520 </span>            :     template &lt;typename T, typename... Args&gt;\
<span class="lineNum">    3521 </span>            :     inline void FUNCTION_NAME(const char*, const T&amp;, const Args&amp;...);\
<span class="lineNum">    3522 </span>            :     template &lt;typename T&gt;\
<span class="lineNum">    3523 </span>            :     inline void FUNCTION_NAME(const T&amp;);
<span class="lineNum">    3524 </span>            : 
<span class="lineNum">    3525 </span>            :     template &lt;typename T, typename... Args&gt; 
<span class="lineNum">    3526 </span>            :     inline void verbose(int, const char*, const T&amp;, const Args&amp;...);
<span class="lineNum">    3527 </span>            : 
<span class="lineNum">    3528 </span>            :     template &lt;typename T&gt; 
<span class="lineNum">    3529 </span>            :     inline void verbose(int, const T&amp;);
<span class="lineNum">    3530 </span>            : 
<span class="lineNum">    3531 </span>            :     LOGGER_LEVEL_WRITERS_SIGNATURES(info)
<span class="lineNum">    3532 </span>            :     LOGGER_LEVEL_WRITERS_SIGNATURES(debug)
<span class="lineNum">    3533 </span>            :     LOGGER_LEVEL_WRITERS_SIGNATURES(warn)
<span class="lineNum">    3534 </span>            :     LOGGER_LEVEL_WRITERS_SIGNATURES(error)
<span class="lineNum">    3535 </span>            :     LOGGER_LEVEL_WRITERS_SIGNATURES(fatal)
<span class="lineNum">    3536 </span>            :     LOGGER_LEVEL_WRITERS_SIGNATURES(trace)
<span class="lineNum">    3537 </span>            : #   undef LOGGER_LEVEL_WRITERS_SIGNATURES
<span class="lineNum">    3538 </span>            : #endif // ELPP_VARIADIC_TEMPLATES_SUPPORTED
<span class="lineNum">    3539 </span>            : private:
<span class="lineNum">    3540 </span>            :     std::string m_id;
<span class="lineNum">    3541 </span>            :     base::TypedConfigurations* m_typedConfigurations;
<span class="lineNum">    3542 </span>            :     base::type::stringstream_t m_stream;
<span class="lineNum">    3543 </span>            :     std::string m_parentApplicationName;
<span class="lineNum">    3544 </span>            :     bool m_isConfigured;
<span class="lineNum">    3545 </span>            :     Configurations m_configurations;
<span class="lineNum">    3546 </span>            :     std::map&lt;Level, unsigned int&gt; m_unflushedCount;
<span class="lineNum">    3547 </span>            :     base::LogStreamsReferenceMap* m_logStreamsReference;
<span class="lineNum">    3548 </span>            :     LogBuilderPtr m_logBuilder;
<span class="lineNum">    3549 </span>            : 
<span class="lineNum">    3550 </span>            :     friend class el::LogMessage;
<span class="lineNum">    3551 </span>            :     friend class el::Loggers;
<span class="lineNum">    3552 </span>            :     friend class el::Helpers;
<span class="lineNum">    3553 </span>            :     friend class el::base::RegisteredLoggers;
<span class="lineNum">    3554 </span>            :     friend class el::base::DefaultLogDispatchCallback;
<span class="lineNum">    3555 </span>            :     friend class el::base::MessageBuilder;
<span class="lineNum">    3556 </span>            :     friend class el::base::Writer;
<span class="lineNum">    3557 </span>            :     friend class el::base::PErrorWriter;
<span class="lineNum">    3558 </span>            :     friend class el::base::Storage;
<span class="lineNum">    3559 </span>            :     friend class el::base::PerformanceTracker;
<span class="lineNum">    3560 </span>            :     friend class el::base::LogDispatcher;
<span class="lineNum">    3561 </span>            : 
<span class="lineNum">    3562 </span>            :     Logger(void);
<span class="lineNum">    3563 </span>            : 
<span class="lineNum">    3564 </span>            : #if ELPP_VARIADIC_TEMPLATES_SUPPORTED
<span class="lineNum">    3565 </span>            :     template &lt;typename T, typename... Args&gt;
<span class="lineNum">    3566 </span>            :     void log_(Level, int, const char*, const T&amp;, const Args&amp;...);
<span class="lineNum">    3567 </span>            : 
<span class="lineNum">    3568 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    3569 </span>            :     inline void log_(Level, int, const T&amp;);
<span class="lineNum">    3570 </span>            : 
<span class="lineNum">    3571 </span>            :     template &lt;typename T, typename... Args&gt;
<span class="lineNum">    3572 </span>            :     void log(Level, const char*, const T&amp;, const Args&amp;...);
<span class="lineNum">    3573 </span>            : 
<span class="lineNum">    3574 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    3575 </span>            :     inline void log(Level, const T&amp;);
<a name="3576"><span class="lineNum">    3576 </span>            : #endif // ELPP_VARIADIC_TEMPLATES_SUPPORTED</a>
<span class="lineNum">    3577 </span>            : 
<span class="lineNum">    3578 </span><span class="lineCov">         18 :     void initUnflushedCount(void) {</span>
<a name="3579"><span class="lineNum">    3579 </span><span class="lineCov">         18 :         m_unflushedCount.clear();</span></a>
<span class="lineNum">    3580 </span><span class="lineCov">         18 :         base::type::EnumType lIndex = LevelHelper::kMinValid;</span>
<span class="lineNum">    3581 </span><span class="lineCov">        126 :         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](void) -&gt; bool {</span>
<span class="lineNum">    3582 </span><span class="lineCov">        126 :             m_unflushedCount.insert(std::make_pair(LevelHelper::castFromInt(lIndex), 0));</span>
<span class="lineNum">    3583 </span><span class="lineCov">        126 :             return false;</span>
<span class="lineNum">    3584 </span><span class="lineCov">         18 :         });</span>
<a name="3585"><span class="lineNum">    3585 </span><span class="lineCov">         18 :     }</span></a>
<span class="lineNum">    3586 </span>            : 
<span class="lineNum">    3587 </span><span class="lineCov">       5195 :     inline base::type::stringstream_t&amp; stream(void) {</span>
<span class="lineNum">    3588 </span><span class="lineCov">       5195 :         return m_stream;</span>
<a name="3589"><span class="lineNum">    3589 </span>            :     }</a>
<span class="lineNum">    3590 </span>            : 
<a name="3591"><span class="lineNum">    3591 </span><span class="lineCov">         14 :     void resolveLoggerFormatSpec(void) const {</span></a>
<span class="lineNum">    3592 </span><span class="lineCov">         14 :         base::type::EnumType lIndex = LevelHelper::kMinValid;</span>
<span class="lineNum">    3593 </span><span class="lineCov">         98 :         LevelHelper::forEachLevel(&amp;lIndex, [&amp;](void) -&gt; bool {</span>
<span class="lineNum">    3594 </span>            :             base::LogFormat* logFormat = 
<span class="lineNum">    3595 </span><span class="lineCov">         98 :                 const_cast&lt;base::LogFormat*&gt;(&amp;m_typedConfigurations-&gt;logFormat(LevelHelper::castFromInt(lIndex)));</span>
<span class="lineNum">    3596 </span><span class="lineCov">         98 :             base::utils::Str::replaceFirstWithEscape(logFormat-&gt;m_format, base::consts::kLoggerIdFormatSpecifier, m_id);</span>
<span class="lineNum">    3597 </span><span class="lineCov">         98 :             return false;</span>
<span class="lineNum">    3598 </span><span class="lineCov">         14 :         });</span>
<span class="lineNum">    3599 </span><span class="lineCov">         14 :     }</span>
<span class="lineNum">    3600 </span>            : };
<span class="lineNum">    3601 </span>            : namespace base {
<span class="lineNum">    3602 </span>            : /// @brief Loggers repository
<a name="3603"><span class="lineNum">    3603 </span>            : class RegisteredLoggers : public base::utils::Registry&lt;Logger, std::string&gt; {</a>
<span class="lineNum">    3604 </span>            : public:
<span class="lineNum">    3605 </span><span class="lineCov">          2 :     explicit RegisteredLoggers(const LogBuilderPtr&amp; defaultLogBuilder) :</span>
<span class="lineNum">    3606 </span><span class="lineCov">          2 :         m_defaultLogBuilder(defaultLogBuilder) {</span>
<span class="lineNum">    3607 </span><span class="lineCov">          2 :         m_defaultConfigurations.setToDefault();</span>
<a name="3608"><span class="lineNum">    3608 </span><span class="lineCov">          2 :     }</span></a>
<span class="lineNum">    3609 </span>            : 
<span class="lineNum">    3610 </span><span class="lineNoCov">          0 :     virtual ~RegisteredLoggers(void) {</span>
<span class="lineNum">    3611 </span><span class="lineNoCov">          0 :         flushAll();</span>
<span class="lineNum">    3612 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3613 </span>            : 
<span class="lineNum">    3614 </span>            :     inline void setDefaultConfigurations(const Configurations&amp; configurations) {
<span class="lineNum">    3615 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3616 </span>            :         m_defaultConfigurations.setFromBase(const_cast&lt;Configurations*&gt;(&amp;configurations));
<span class="lineNum">    3617 </span>            :     }
<span class="lineNum">    3618 </span>            : 
<span class="lineNum">    3619 </span>            :     inline Configurations* defaultConfigurations(void) {
<span class="lineNum">    3620 </span>            :         return &amp;m_defaultConfigurations;
<a name="3621"><span class="lineNum">    3621 </span>            :     }</a>
<span class="lineNum">    3622 </span>            : 
<span class="lineNum">    3623 </span><span class="lineCov">       1248 :     Logger* get(const std::string&amp; id, bool forceCreation = true) {</span>
<span class="lineNum">    3624 </span><span class="lineCov">       1248 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    3625 </span><span class="lineCov">       1248 :         Logger* logger_ = base::utils::Registry&lt;Logger, std::string&gt;::get(id);</span>
<span class="lineNum">    3626 </span><span class="lineCov">       1248 :         if (logger_ == nullptr &amp;&amp; forceCreation) {</span>
<span class="lineNum">    3627 </span><span class="lineCov">          4 :             bool validId = Logger::isValidId(id);</span>
<span class="lineNum">    3628 </span><span class="lineCov">          4 :             if (!validId) {</span>
<span class="lineNum">    3629 </span><span class="lineNoCov">          0 :                 ELPP_ASSERT(validId, &quot;Invalid logger ID [&quot; &lt;&lt; id &lt;&lt; &quot;]. Not registering this logger.&quot;);</span>
<span class="lineNum">    3630 </span><span class="lineNoCov">          0 :                 return nullptr;</span>
<span class="lineNum">    3631 </span>            :             }
<span class="lineNum">    3632 </span><span class="lineCov">          4 :             logger_ = new Logger(id, m_defaultConfigurations, &amp;m_logStreamsReference);</span>
<span class="lineNum">    3633 </span><span class="lineCov">          4 :             logger_-&gt;m_logBuilder = m_defaultLogBuilder;</span>
<span class="lineNum">    3634 </span><span class="lineCov">          4 :             registerNew(id, logger_);</span>
<span class="lineNum">    3635 </span>            :         }
<span class="lineNum">    3636 </span><span class="lineCov">       1248 :         return logger_;</span>
<span class="lineNum">    3637 </span>            :     }
<span class="lineNum">    3638 </span>            : 
<span class="lineNum">    3639 </span>            :     bool remove(const std::string&amp; id) {
<span class="lineNum">    3640 </span>            :         if (id == &quot;default&quot;) {
<span class="lineNum">    3641 </span>            :             return false;
<span class="lineNum">    3642 </span>            :         }
<span class="lineNum">    3643 </span>            :         Logger* logger = base::utils::Registry&lt;Logger, std::string&gt;::get(id);
<span class="lineNum">    3644 </span>            :         if (logger != nullptr) {
<span class="lineNum">    3645 </span>            :             unregister(logger);
<span class="lineNum">    3646 </span>            :         }
<span class="lineNum">    3647 </span>            :         return true;
<a name="3648"><span class="lineNum">    3648 </span>            :     }</a>
<span class="lineNum">    3649 </span>            : 
<span class="lineNum">    3650 </span><span class="lineNoCov">          0 :     inline bool has(const std::string&amp; id) {</span>
<span class="lineNum">    3651 </span><span class="lineNoCov">          0 :         return get(id, false) != nullptr;</span>
<span class="lineNum">    3652 </span>            :     }
<span class="lineNum">    3653 </span>            : 
<span class="lineNum">    3654 </span>            :     inline void unregister(Logger*&amp; logger) {
<span class="lineNum">    3655 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3656 </span>            :         base::utils::Registry&lt;Logger, std::string&gt;::unregister(logger-&gt;id());
<span class="lineNum">    3657 </span>            :     }
<span class="lineNum">    3658 </span>            : 
<span class="lineNum">    3659 </span>            :     inline base::LogStreamsReferenceMap* logStreamsReference(void) {
<span class="lineNum">    3660 </span>            :         return &amp;m_logStreamsReference;
<a name="3661"><span class="lineNum">    3661 </span>            :     }</a>
<span class="lineNum">    3662 </span>            : 
<span class="lineNum">    3663 </span><span class="lineNoCov">          0 :     inline void flushAll(void) {</span>
<span class="lineNum">    3664 </span>            :         ELPP_INTERNAL_INFO(1, &quot;Flushing all log files&quot;);
<span class="lineNum">    3665 </span><span class="lineNoCov">          0 :         base::threading::ScopedLock scopedLock(lock());</span>
<span class="lineNum">    3666 </span><span class="lineNoCov">          0 :         for (base::LogStreamsReferenceMap::iterator it = m_logStreamsReference.begin();</span>
<span class="lineNum">    3667 </span><span class="lineNoCov">          0 :                 it != m_logStreamsReference.end(); ++it) {</span>
<span class="lineNum">    3668 </span><span class="lineNoCov">          0 :             if (it-&gt;second.get() == nullptr) continue;</span>
<span class="lineNum">    3669 </span><span class="lineNoCov">          0 :             it-&gt;second-&gt;flush();</span>
<span class="lineNum">    3670 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    3671 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3672 </span>            : 
<span class="lineNum">    3673 </span>            : private:
<span class="lineNum">    3674 </span>            :     LogBuilderPtr m_defaultLogBuilder;
<span class="lineNum">    3675 </span>            :     Configurations m_defaultConfigurations;
<span class="lineNum">    3676 </span>            :     base::LogStreamsReferenceMap m_logStreamsReference;
<span class="lineNum">    3677 </span>            :     friend class el::base::Storage;
<a name="3678"><span class="lineNum">    3678 </span>            : };</a>
<span class="lineNum">    3679 </span>            : /// @brief Represents registries for verbose logging
<a name="3680"><span class="lineNum">    3680 </span><span class="lineNoCov">          0 : class VRegistry : base::NoCopy, public base::threading::ThreadSafe {</span></a>
<span class="lineNum">    3681 </span>            : public:
<span class="lineNum">    3682 </span><span class="lineCov">          2 :     explicit VRegistry(base::type::VerboseLevel level, base::type::EnumType* pFlags) : m_level(level), m_pFlags(pFlags) {</span>
<span class="lineNum">    3683 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    3684 </span>            : 
<span class="lineNum">    3685 </span>            :     /// @brief Sets verbose level. Accepted range is 0-9
<span class="lineNum">    3686 </span>            :     inline void setLevel(base::type::VerboseLevel level) {
<span class="lineNum">    3687 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3688 </span>            :         if (level &lt; 0)
<span class="lineNum">    3689 </span>            :             m_level = 0;
<span class="lineNum">    3690 </span>            :         else if (level &gt; 9)
<span class="lineNum">    3691 </span>            :             m_level = base::consts::kMaxVerboseLevel;
<span class="lineNum">    3692 </span>            :         else
<span class="lineNum">    3693 </span>            :             m_level = level;
<span class="lineNum">    3694 </span>            :     }
<span class="lineNum">    3695 </span>            : 
<span class="lineNum">    3696 </span>            :     inline base::type::VerboseLevel level(void) const {
<span class="lineNum">    3697 </span>            :         return m_level;
<span class="lineNum">    3698 </span>            :     }
<span class="lineNum">    3699 </span>            : 
<span class="lineNum">    3700 </span>            :     inline void clearModules(void) {
<span class="lineNum">    3701 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3702 </span>            :         m_modules.clear();
<span class="lineNum">    3703 </span>            :     }
<span class="lineNum">    3704 </span>            : 
<span class="lineNum">    3705 </span>            :     void setModules(const char* modules) {
<span class="lineNum">    3706 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3707 </span>            :         auto addSuffix = [](std::stringstream&amp; ss, const char* sfx, const char* prev) {
<span class="lineNum">    3708 </span>            :             if (prev != nullptr &amp;&amp; base::utils::Str::endsWith(ss.str(), std::string(prev))) {
<span class="lineNum">    3709 </span>            :                 std::string chr(ss.str().substr(0, ss.str().size() - strlen(prev)));
<span class="lineNum">    3710 </span>            :                 ss.str(std::string(&quot;&quot;));
<span class="lineNum">    3711 </span>            :                 ss &lt;&lt; chr;
<span class="lineNum">    3712 </span>            :             }
<span class="lineNum">    3713 </span>            :             if (base::utils::Str::endsWith(ss.str(), std::string(sfx))) {
<span class="lineNum">    3714 </span>            :                 std::string chr(ss.str().substr(0, ss.str().size() - strlen(sfx)));
<span class="lineNum">    3715 </span>            :                 ss.str(std::string(&quot;&quot;));
<span class="lineNum">    3716 </span>            :                 ss &lt;&lt; chr;
<span class="lineNum">    3717 </span>            :             }
<span class="lineNum">    3718 </span>            :             ss &lt;&lt; sfx;
<span class="lineNum">    3719 </span>            :         };
<span class="lineNum">    3720 </span>            :         auto insert = [&amp;](std::stringstream&amp; ss, base::type::VerboseLevel level) {
<span class="lineNum">    3721 </span>            :             if (!base::utils::hasFlag(LoggingFlag::DisableVModulesExtensions, *m_pFlags)) {
<span class="lineNum">    3722 </span>            :                 addSuffix(ss, &quot;.h&quot;, nullptr);
<span class="lineNum">    3723 </span>            :                 m_modules.insert(std::make_pair(ss.str(), level));
<span class="lineNum">    3724 </span>            :                 addSuffix(ss, &quot;.c&quot;, &quot;.h&quot;);
<span class="lineNum">    3725 </span>            :                 m_modules.insert(std::make_pair(ss.str(), level));
<span class="lineNum">    3726 </span>            :                 addSuffix(ss, &quot;.cpp&quot;, &quot;.c&quot;);
<span class="lineNum">    3727 </span>            :                 m_modules.insert(std::make_pair(ss.str(), level));
<span class="lineNum">    3728 </span>            :                 addSuffix(ss, &quot;.cc&quot;, &quot;.cpp&quot;);
<span class="lineNum">    3729 </span>            :                 m_modules.insert(std::make_pair(ss.str(), level));
<span class="lineNum">    3730 </span>            :                 addSuffix(ss, &quot;.cxx&quot;, &quot;.cc&quot;);
<span class="lineNum">    3731 </span>            :                 m_modules.insert(std::make_pair(ss.str(), level));
<span class="lineNum">    3732 </span>            :                 addSuffix(ss, &quot;.-inl.h&quot;, &quot;.cxx&quot;);
<span class="lineNum">    3733 </span>            :                 m_modules.insert(std::make_pair(ss.str(), level));
<span class="lineNum">    3734 </span>            :                 addSuffix(ss, &quot;.hxx&quot;, &quot;.-inl.h&quot;);
<span class="lineNum">    3735 </span>            :                 m_modules.insert(std::make_pair(ss.str(), level));
<span class="lineNum">    3736 </span>            :                 addSuffix(ss, &quot;.hpp&quot;, &quot;.hxx&quot;);
<span class="lineNum">    3737 </span>            :                 m_modules.insert(std::make_pair(ss.str(), level));
<span class="lineNum">    3738 </span>            :                 addSuffix(ss, &quot;.hh&quot;, &quot;.hpp&quot;);
<span class="lineNum">    3739 </span>            :             }
<span class="lineNum">    3740 </span>            :             m_modules.insert(std::make_pair(ss.str(), level));
<span class="lineNum">    3741 </span>            :         };
<span class="lineNum">    3742 </span>            :         bool isMod = true;
<span class="lineNum">    3743 </span>            :         bool isLevel = false;
<span class="lineNum">    3744 </span>            :         std::stringstream ss;
<span class="lineNum">    3745 </span>            :         int level = -1;
<span class="lineNum">    3746 </span>            :         for (; *modules; ++modules) {
<span class="lineNum">    3747 </span>            :             switch (*modules) {
<span class="lineNum">    3748 </span>            :             case '=':
<span class="lineNum">    3749 </span>            :                 isLevel = true;
<span class="lineNum">    3750 </span>            :                 isMod = false;
<span class="lineNum">    3751 </span>            :                 break;
<span class="lineNum">    3752 </span>            :             case ',':
<span class="lineNum">    3753 </span>            :                 isLevel = false;
<span class="lineNum">    3754 </span>            :                 isMod = true;
<span class="lineNum">    3755 </span>            :                 if (!ss.str().empty() &amp;&amp; level != -1) {
<span class="lineNum">    3756 </span>            :                     insert(ss, level);
<span class="lineNum">    3757 </span>            :                     ss.str(std::string(&quot;&quot;));
<span class="lineNum">    3758 </span>            :                     level = -1;
<span class="lineNum">    3759 </span>            :                 }
<span class="lineNum">    3760 </span>            :                 break;
<span class="lineNum">    3761 </span>            :             default:
<span class="lineNum">    3762 </span>            :                 if (isMod) {
<span class="lineNum">    3763 </span>            :                     ss &lt;&lt; *modules;
<span class="lineNum">    3764 </span>            :                 } else if (isLevel) {
<span class="lineNum">    3765 </span>            :                     if (isdigit(*modules)) {
<span class="lineNum">    3766 </span>            :                         level = static_cast&lt;base::type::VerboseLevel&gt;(*modules) - 48;
<span class="lineNum">    3767 </span>            :                     }
<span class="lineNum">    3768 </span>            :                 }
<span class="lineNum">    3769 </span>            :                 break;
<span class="lineNum">    3770 </span>            :             }
<span class="lineNum">    3771 </span>            :         }
<span class="lineNum">    3772 </span>            :         if (!ss.str().empty() &amp;&amp; level != -1) {
<span class="lineNum">    3773 </span>            :             insert(ss, level);
<span class="lineNum">    3774 </span>            :         }
<span class="lineNum">    3775 </span>            :     }
<span class="lineNum">    3776 </span>            : 
<span class="lineNum">    3777 </span>            :     bool allowed(base::type::VerboseLevel vlevel, const char* file) {
<span class="lineNum">    3778 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3779 </span>            :         if (m_modules.empty() || file == nullptr) {
<span class="lineNum">    3780 </span>            :             return vlevel &lt;= m_level;
<span class="lineNum">    3781 </span>            :         } else {
<span class="lineNum">    3782 </span>            :             std::map&lt;std::string, base::type::VerboseLevel&gt;::iterator it = m_modules.begin();
<span class="lineNum">    3783 </span>            :             for (; it != m_modules.end(); ++it) {
<span class="lineNum">    3784 </span>            :                 if (base::utils::Str::wildCardMatch(file, it-&gt;first.c_str())) {
<span class="lineNum">    3785 </span>            :                     return vlevel &lt;= it-&gt;second;
<span class="lineNum">    3786 </span>            :                 }
<span class="lineNum">    3787 </span>            :             }
<span class="lineNum">    3788 </span>            :             if (base::utils::hasFlag(LoggingFlag::AllowVerboseIfModuleNotSpecified, *m_pFlags)) {
<span class="lineNum">    3789 </span>            :                 return true;
<span class="lineNum">    3790 </span>            :             }
<span class="lineNum">    3791 </span>            :             return false;
<span class="lineNum">    3792 </span>            :         }
<span class="lineNum">    3793 </span>            :     }
<span class="lineNum">    3794 </span>            : 
<span class="lineNum">    3795 </span>            :     inline const std::map&lt;std::string, base::type::VerboseLevel&gt;&amp; modules(void) const {
<span class="lineNum">    3796 </span>            :         return m_modules;
<span class="lineNum">    3797 </span>            :     }
<span class="lineNum">    3798 </span>            : 
<span class="lineNum">    3799 </span>            :     void setFromArgs(const base::utils::CommandLineArgs* commandLineArgs) {
<span class="lineNum">    3800 </span>            :         if (commandLineArgs-&gt;hasParam(&quot;-v&quot;) || commandLineArgs-&gt;hasParam(&quot;--verbose&quot;) ||
<span class="lineNum">    3801 </span>            :             commandLineArgs-&gt;hasParam(&quot;-V&quot;) || commandLineArgs-&gt;hasParam(&quot;--VERBOSE&quot;)) {
<span class="lineNum">    3802 </span>            :             setLevel(base::consts::kMaxVerboseLevel);
<span class="lineNum">    3803 </span>            :         } else if (commandLineArgs-&gt;hasParamWithValue(&quot;--v&quot;)) {
<span class="lineNum">    3804 </span>            :             setLevel(atoi(commandLineArgs-&gt;getParamValue(&quot;--v&quot;)));
<span class="lineNum">    3805 </span>            :         } else if (commandLineArgs-&gt;hasParamWithValue(&quot;--V&quot;)) {
<span class="lineNum">    3806 </span>            :             setLevel(atoi(commandLineArgs-&gt;getParamValue(&quot;--V&quot;)));
<span class="lineNum">    3807 </span>            :         } else if ((commandLineArgs-&gt;hasParamWithValue(&quot;-vmodule&quot;)) &amp;&amp; vModulesEnabled()) {
<span class="lineNum">    3808 </span>            :             setModules(commandLineArgs-&gt;getParamValue(&quot;-vmodule&quot;));
<span class="lineNum">    3809 </span>            :         } else if (commandLineArgs-&gt;hasParamWithValue(&quot;-VMODULE&quot;) &amp;&amp; vModulesEnabled()) {
<span class="lineNum">    3810 </span>            :             setModules(commandLineArgs-&gt;getParamValue(&quot;-VMODULE&quot;));
<span class="lineNum">    3811 </span>            :         }
<span class="lineNum">    3812 </span>            :     }
<span class="lineNum">    3813 </span>            :     
<span class="lineNum">    3814 </span>            :     /// @brief Whether or not vModules enabled
<span class="lineNum">    3815 </span>            :     inline bool vModulesEnabled(void) {
<span class="lineNum">    3816 </span>            :         return !base::utils::hasFlag(LoggingFlag::DisableVModules, *m_pFlags);
<span class="lineNum">    3817 </span>            :     }
<span class="lineNum">    3818 </span>            : 
<span class="lineNum">    3819 </span>            : private:
<span class="lineNum">    3820 </span>            :     base::type::VerboseLevel m_level;
<span class="lineNum">    3821 </span>            :     base::type::EnumType* m_pFlags;
<span class="lineNum">    3822 </span>            :     std::map&lt;std::string, base::type::VerboseLevel&gt; m_modules;
<a name="3823"><span class="lineNum">    3823 </span>            : };</a>
<span class="lineNum">    3824 </span>            : }  // namespace base
<a name="3825"><span class="lineNum">    3825 </span><span class="lineCov">       3732 : class LogMessage {</span></a>
<span class="lineNum">    3826 </span>            : public:
<span class="lineNum">    3827 </span><span class="lineCov">       1244 :     LogMessage(Level level, const std::string&amp; file, unsigned long int line, const std::string&amp; func,</span>
<span class="lineNum">    3828 </span>            :                           base::type::VerboseLevel verboseLevel, Logger* logger) :
<span class="lineNum">    3829 </span>            :                   m_level(level), m_file(file), m_line(line), m_func(func),
<a name="3830"><span class="lineNum">    3830 </span><span class="lineCov">       1244 :                   m_verboseLevel(verboseLevel), m_logger(logger), m_message(std::move(logger-&gt;stream().str())) {</span></a>
<a name="3831"><span class="lineNum">    3831 </span><span class="lineCov">       1244 :     }</span></a>
<a name="3832"><span class="lineNum">    3832 </span><span class="lineCov">      11196 :     inline Level level(void) const { return m_level; }</span></a>
<a name="3833"><span class="lineNum">    3833 </span><span class="lineCov">       1049 :     inline const std::string&amp; file(void) const { return m_file; }</span></a>
<a name="3834"><span class="lineNum">    3834 </span><span class="lineCov">       1049 :     inline unsigned long int line(void) const { return m_line; } // NOLINT</span></a>
<a name="3835"><span class="lineNum">    3835 </span><span class="lineNoCov">          0 :     inline const std::string&amp; func(void) const { return m_func; }</span></a>
<a name="3836"><span class="lineNum">    3836 </span><span class="lineNoCov">          0 :     inline base::type::VerboseLevel verboseLevel(void) const { return m_verboseLevel; }</span></a>
<span class="lineNum">    3837 </span><span class="lineCov">      11196 :     inline Logger* logger(void) const { return m_logger; }</span>
<span class="lineNum">    3838 </span><span class="lineCov">       1244 :     inline const base::type::string_t&amp; message(void) const { return m_message; }</span>
<span class="lineNum">    3839 </span>            : private:
<span class="lineNum">    3840 </span>            :     Level m_level;
<span class="lineNum">    3841 </span>            :     std::string m_file;
<span class="lineNum">    3842 </span>            :     unsigned long int m_line;
<span class="lineNum">    3843 </span>            :     std::string m_func;
<span class="lineNum">    3844 </span>            :     base::type::VerboseLevel m_verboseLevel;
<span class="lineNum">    3845 </span>            :     Logger* m_logger;
<span class="lineNum">    3846 </span>            :     base::type::string_t m_message;
<span class="lineNum">    3847 </span>            : };
<span class="lineNum">    3848 </span>            : namespace base {
<span class="lineNum">    3849 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    3850 </span>            : class AsyncLogItem {
<span class="lineNum">    3851 </span>            : public:
<span class="lineNum">    3852 </span>            :     explicit AsyncLogItem(const LogMessage&amp; logMessage, const LogDispatchData&amp; data, const base::type::string_t&amp; logLine)
<span class="lineNum">    3853 </span>            :         : m_logMessage(logMessage), m_dispatchData(data), m_logLine(logLine) {}
<span class="lineNum">    3854 </span>            :     virtual ~AsyncLogItem() {}
<span class="lineNum">    3855 </span>            :     inline LogMessage* logMessage(void) { return &amp;m_logMessage; }
<span class="lineNum">    3856 </span>            :     inline LogDispatchData* data(void) { return &amp;m_dispatchData; }
<span class="lineNum">    3857 </span>            :     inline base::type::string_t logLine(void) { return m_logLine; }
<span class="lineNum">    3858 </span>            : private:
<span class="lineNum">    3859 </span>            :     LogMessage m_logMessage;
<span class="lineNum">    3860 </span>            :     LogDispatchData m_dispatchData;
<span class="lineNum">    3861 </span>            :     base::type::string_t m_logLine;
<span class="lineNum">    3862 </span>            : };
<span class="lineNum">    3863 </span>            : class AsyncLogQueue : public base::threading::ThreadSafe {
<span class="lineNum">    3864 </span>            : public:
<span class="lineNum">    3865 </span>            :     virtual ~AsyncLogQueue() {
<span class="lineNum">    3866 </span>            :         ELPP_INTERNAL_INFO(6, &quot;~AsyncLogQueue&quot;);
<span class="lineNum">    3867 </span>            :     }
<span class="lineNum">    3868 </span>            :     
<span class="lineNum">    3869 </span>            :     inline AsyncLogItem next(void) {
<span class="lineNum">    3870 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3871 </span>            :         AsyncLogItem result = m_queue.front();
<span class="lineNum">    3872 </span>            :         m_queue.pop();
<span class="lineNum">    3873 </span>            :         return result;
<span class="lineNum">    3874 </span>            :     }
<span class="lineNum">    3875 </span>            :     
<span class="lineNum">    3876 </span>            :     inline void push(const AsyncLogItem&amp; item) {
<span class="lineNum">    3877 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3878 </span>            :         m_queue.push(item);
<span class="lineNum">    3879 </span>            :     }
<span class="lineNum">    3880 </span>            :     inline void pop(void) {
<span class="lineNum">    3881 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3882 </span>            :         m_queue.pop();
<span class="lineNum">    3883 </span>            :     }
<span class="lineNum">    3884 </span>            :     inline AsyncLogItem front(void) {
<span class="lineNum">    3885 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3886 </span>            :         return m_queue.front();
<span class="lineNum">    3887 </span>            :     }
<span class="lineNum">    3888 </span>            :     inline bool empty(void) {
<span class="lineNum">    3889 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    3890 </span>            :         return m_queue.empty();
<span class="lineNum">    3891 </span>            :     }
<span class="lineNum">    3892 </span>            : private:
<span class="lineNum">    3893 </span>            :     std::queue&lt;AsyncLogItem&gt; m_queue;
<span class="lineNum">    3894 </span>            : };
<span class="lineNum">    3895 </span>            : class IWorker {
<span class="lineNum">    3896 </span>            : public:
<span class="lineNum">    3897 </span>            :     virtual ~IWorker() {}
<span class="lineNum">    3898 </span>            :     virtual void start() = 0;
<span class="lineNum">    3899 </span>            : };
<span class="lineNum">    3900 </span>            : #endif // ELPP_ASYNC_LOGGING
<span class="lineNum">    3901 </span>            : /// @brief Easylogging++ management storage
<span class="lineNum">    3902 </span>            : class Storage : base::NoCopy, public base::threading::ThreadSafe {
<span class="lineNum">    3903 </span>            : public:
<span class="lineNum">    3904 </span>            : #if ELPP_ASYNC_LOGGING
<a name="3905"><span class="lineNum">    3905 </span>            :     Storage(const LogBuilderPtr&amp; defaultLogBuilder, base::IWorker* asyncDispatchWorker) :</a>
<span class="lineNum">    3906 </span>            : #else
<span class="lineNum">    3907 </span><span class="lineCov">          2 :     explicit Storage(const LogBuilderPtr&amp; defaultLogBuilder) :</span>
<span class="lineNum">    3908 </span>            : #endif  // ELPP_ASYNC_LOGGING
<span class="lineNum">    3909 </span><span class="lineNoCov">          0 :         m_registeredHitCounters(new base::RegisteredHitCounters()),</span>
<span class="lineNum">    3910 </span><span class="lineCov">          2 :         m_registeredLoggers(new base::RegisteredLoggers(defaultLogBuilder)),</span>
<span class="lineNum">    3911 </span>            :         m_flags(0x0),
<span class="lineNum">    3912 </span><span class="lineCov">          2 :         m_vRegistry(new base::VRegistry(0, &amp;m_flags)),</span>
<span class="lineNum">    3913 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    3914 </span>            :         m_asyncLogQueue(new base::AsyncLogQueue()),
<span class="lineNum">    3915 </span>            :         m_asyncDispatchWorker(asyncDispatchWorker),
<span class="lineNum">    3916 </span>            : #endif  // ELPP_ASYNC_LOGGING
<span class="lineNum">    3917 </span><span class="lineCov">          6 :         m_preRollOutCallback(base::defaultPreRollOutCallback) {</span>
<span class="lineNum">    3918 </span>            :         // Register default logger
<span class="lineNum">    3919 </span><span class="lineCov">          2 :         m_registeredLoggers-&gt;get(std::string(base::consts::kDefaultLoggerId));</span>
<span class="lineNum">    3920 </span>            :         // Register performance logger and reconfigure format
<span class="lineNum">    3921 </span><span class="lineCov">          2 :         Logger* performanceLogger = m_registeredLoggers-&gt;get(std::string(base::consts::kPerformanceLoggerId));</span>
<span class="lineNum">    3922 </span><span class="lineCov">          2 :         performanceLogger-&gt;configurations()-&gt;setGlobally(ConfigurationType::Format, std::string(&quot;%datetime %level %msg&quot;));</span>
<span class="lineNum">    3923 </span><span class="lineCov">          2 :         performanceLogger-&gt;reconfigure();</span>
<span class="lineNum">    3924 </span>            : #if defined(ELPP_SYSLOG)
<span class="lineNum">    3925 </span>            :         // Register syslog logger and reconfigure format
<span class="lineNum">    3926 </span>            :         Logger* sysLogLogger = m_registeredLoggers-&gt;get(std::string(base::consts::kSysLogLoggerId));
<span class="lineNum">    3927 </span>            :         sysLogLogger-&gt;configurations()-&gt;setGlobally(ConfigurationType::Format, std::string(&quot;%level: %msg&quot;));
<span class="lineNum">    3928 </span>            :         sysLogLogger-&gt;reconfigure();
<span class="lineNum">    3929 </span>            : #else
<span class="lineNum">    3930 </span>            :         ELPP_UNUSED(base::consts::kSysLogLoggerId);
<span class="lineNum">    3931 </span>            : #endif //  defined(ELPP_SYSLOG)
<span class="lineNum">    3932 </span><span class="lineCov">          2 :         addFlag(LoggingFlag::AllowVerboseIfModuleNotSpecified);</span>
<span class="lineNum">    3933 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    3934 </span>            :         installLogDispatchCallback&lt;base::AsyncLogDispatchCallback&gt;(std::string(&quot;AsyncLogDispatchCallback&quot;));
<span class="lineNum">    3935 </span>            : #else
<span class="lineNum">    3936 </span><span class="lineCov">          2 :         installLogDispatchCallback&lt;base::DefaultLogDispatchCallback&gt;(std::string(&quot;DefaultLogDispatchCallback&quot;));</span>
<span class="lineNum">    3937 </span>            : #endif  // ELPP_ASYNC_LOGGING
<span class="lineNum">    3938 </span><span class="lineCov">          2 :             installPerformanceTrackingCallback&lt;base::DefaultPerformanceTrackingCallback&gt;(std::string(&quot;DefaultPerformanceTrackingCallback&quot;));</span>
<span class="lineNum">    3939 </span>            :             ELPP_INTERNAL_INFO(1, &quot;Easylogging++ has been initialized&quot;);
<span class="lineNum">    3940 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    3941 </span>            :         m_asyncDispatchWorker-&gt;start();
<span class="lineNum">    3942 </span>            : #endif  // ELPP_ASYNC_LOGGING
<a name="3943"><span class="lineNum">    3943 </span><span class="lineCov">          2 :     }</span></a>
<span class="lineNum">    3944 </span>            : 
<span class="lineNum">    3945 </span><span class="lineNoCov">          0 :     virtual ~Storage(void) {</span>
<span class="lineNum">    3946 </span>            :         ELPP_INTERNAL_INFO(4, &quot;Destroying storage&quot;);
<span class="lineNum">    3947 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    3948 </span>            :         ELPP_INTERNAL_INFO(5, &quot;Replacing log dispatch callback to synchronous&quot;);
<span class="lineNum">    3949 </span>            :         uninstallLogDispatchCallback&lt;base::AsyncLogDispatchCallback&gt;(std::string(&quot;AsyncLogDispatchCallback&quot;));
<span class="lineNum">    3950 </span>            :         installLogDispatchCallback&lt;base::DefaultLogDispatchCallback&gt;(std::string(&quot;DefaultLogDispatchCallback&quot;));
<span class="lineNum">    3951 </span>            :         ELPP_INTERNAL_INFO(5, &quot;Destroying asyncDispatchWorker&quot;);
<span class="lineNum">    3952 </span>            :         base::utils::safeDelete(m_asyncDispatchWorker);
<span class="lineNum">    3953 </span>            :         ELPP_INTERNAL_INFO(5, &quot;Destroying asyncLogQueue&quot;);
<span class="lineNum">    3954 </span>            :         base::utils::safeDelete(m_asyncLogQueue);
<span class="lineNum">    3955 </span>            : #endif  // ELPP_ASYNC_LOGGING
<span class="lineNum">    3956 </span>            :         ELPP_INTERNAL_INFO(5, &quot;Destroying registeredHitCounters&quot;);
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :         base::utils::safeDelete(m_registeredHitCounters);</span>
<span class="lineNum">    3958 </span>            :         ELPP_INTERNAL_INFO(5, &quot;Destroying registeredLoggers&quot;);
<span class="lineNum">    3959 </span><span class="lineNoCov">          0 :         base::utils::safeDelete(m_registeredLoggers);</span>
<span class="lineNum">    3960 </span>            :         ELPP_INTERNAL_INFO(5, &quot;Destroying vRegistry&quot;);
<span class="lineNum">    3961 </span><span class="lineNoCov">          0 :         base::utils::safeDelete(m_vRegistry);</span>
<span class="lineNum">    3962 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3963 </span>            : 
<span class="lineNum">    3964 </span>            :     inline bool validateEveryNCounter(const char* filename, unsigned long int lineNumber, std::size_t occasion) {
<span class="lineNum">    3965 </span>            :         return hitCounters()-&gt;validateEveryN(filename, lineNumber, occasion);
<span class="lineNum">    3966 </span>            :     }
<span class="lineNum">    3967 </span>            : 
<span class="lineNum">    3968 </span>            :     inline bool validateAfterNCounter(const char* filename, unsigned long int lineNumber, std::size_t n) { // NOLINT
<span class="lineNum">    3969 </span>            :         return hitCounters()-&gt;validateAfterN(filename, lineNumber, n);
<span class="lineNum">    3970 </span>            :     }
<span class="lineNum">    3971 </span>            : 
<span class="lineNum">    3972 </span>            :     inline bool validateNTimesCounter(const char* filename, unsigned long int lineNumber, std::size_t n) { // NOLINT
<span class="lineNum">    3973 </span>            :         return hitCounters()-&gt;validateNTimes(filename, lineNumber, n);
<span class="lineNum">    3974 </span>            :     }
<span class="lineNum">    3975 </span>            : 
<span class="lineNum">    3976 </span>            :     inline base::RegisteredHitCounters* hitCounters(void) const {
<span class="lineNum">    3977 </span>            :         return m_registeredHitCounters;
<a name="3978"><span class="lineNum">    3978 </span>            :     }</a>
<span class="lineNum">    3979 </span>            : 
<span class="lineNum">    3980 </span><span class="lineCov">       1260 :     inline base::RegisteredLoggers* registeredLoggers(void) const {</span>
<span class="lineNum">    3981 </span><span class="lineCov">       1260 :         return m_registeredLoggers;</span>
<span class="lineNum">    3982 </span>            :     }
<span class="lineNum">    3983 </span>            :     
<span class="lineNum">    3984 </span>            :     inline base::VRegistry* vRegistry(void) const {
<span class="lineNum">    3985 </span>            :         return m_vRegistry;
<span class="lineNum">    3986 </span>            :     }
<span class="lineNum">    3987 </span>            : 
<span class="lineNum">    3988 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    3989 </span>            :     inline base::AsyncLogQueue* asyncLogQueue(void) const {
<span class="lineNum">    3990 </span>            :         return m_asyncLogQueue;
<span class="lineNum">    3991 </span>            :     }
<span class="lineNum">    3992 </span>            : #endif  // ELPP_ASYNC_LOGGING
<span class="lineNum">    3993 </span>            : 
<span class="lineNum">    3994 </span>            :     inline const base::utils::CommandLineArgs* commandLineArgs(void) const {
<span class="lineNum">    3995 </span>            :         return &amp;m_commandLineArgs;
<a name="3996"><span class="lineNum">    3996 </span>            :     }</a>
<span class="lineNum">    3997 </span>            : 
<span class="lineNum">    3998 </span><span class="lineCov">          6 :     inline void addFlag(LoggingFlag flag) {</span>
<span class="lineNum">    3999 </span><span class="lineCov">          6 :         base::utils::addFlag(flag, &amp;m_flags);</span>
<span class="lineNum">    4000 </span><span class="lineCov">          6 :     }</span>
<span class="lineNum">    4001 </span>            : 
<span class="lineNum">    4002 </span>            :     inline void removeFlag(LoggingFlag flag) {
<span class="lineNum">    4003 </span>            :         base::utils::removeFlag(flag, &amp;m_flags);
<a name="4004"><span class="lineNum">    4004 </span>            :     }</a>
<span class="lineNum">    4005 </span>            : 
<span class="lineNum">    4006 </span><span class="lineCov">      12659 :     inline bool hasFlag(LoggingFlag flag) const {</span>
<span class="lineNum">    4007 </span><span class="lineCov">      12659 :         return base::utils::hasFlag(flag, m_flags);</span>
<span class="lineNum">    4008 </span>            :     }
<span class="lineNum">    4009 </span>            : 
<span class="lineNum">    4010 </span>            :     inline base::type::EnumType flags(void) const {
<span class="lineNum">    4011 </span>            :         return m_flags;
<span class="lineNum">    4012 </span>            :     }
<span class="lineNum">    4013 </span>            : 
<span class="lineNum">    4014 </span>            :     inline void setFlags(base::type::EnumType flags) {
<span class="lineNum">    4015 </span>            :         m_flags = flags;
<span class="lineNum">    4016 </span>            :     }
<span class="lineNum">    4017 </span>            : 
<span class="lineNum">    4018 </span>            :     inline void setPreRollOutCallback(const PreRollOutCallback&amp; callback) {
<span class="lineNum">    4019 </span>            :         m_preRollOutCallback = callback;
<span class="lineNum">    4020 </span>            :     }
<span class="lineNum">    4021 </span>            : 
<span class="lineNum">    4022 </span>            :     inline void unsetPreRollOutCallback(void) {
<span class="lineNum">    4023 </span>            :         m_preRollOutCallback = base::defaultPreRollOutCallback;
<a name="4024"><span class="lineNum">    4024 </span>            :     }</a>
<span class="lineNum">    4025 </span>            : 
<span class="lineNum">    4026 </span><span class="lineNoCov">          0 :     inline PreRollOutCallback&amp; preRollOutCallback(void) {</span>
<span class="lineNum">    4027 </span><span class="lineNoCov">          0 :         return m_preRollOutCallback;</span>
<span class="lineNum">    4028 </span>            :     }
<span class="lineNum">    4029 </span>            : 
<span class="lineNum">    4030 </span>            :     inline bool hasCustomFormatSpecifier(const char* formatSpecifier) {
<span class="lineNum">    4031 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    4032 </span>            :         return std::find(m_customFormatSpecifiers.begin(), m_customFormatSpecifiers.end(),
<span class="lineNum">    4033 </span>            :                 formatSpecifier) != m_customFormatSpecifiers.end();
<span class="lineNum">    4034 </span>            :     }
<span class="lineNum">    4035 </span>            : 
<span class="lineNum">    4036 </span>            :     inline void installCustomFormatSpecifier(const CustomFormatSpecifier&amp; customFormatSpecifier) {
<span class="lineNum">    4037 </span>            :         if (hasCustomFormatSpecifier(customFormatSpecifier.formatSpecifier())) {
<span class="lineNum">    4038 </span>            :             return;
<span class="lineNum">    4039 </span>            :         }
<span class="lineNum">    4040 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    4041 </span>            :         m_customFormatSpecifiers.push_back(customFormatSpecifier);
<span class="lineNum">    4042 </span>            :     }
<span class="lineNum">    4043 </span>            : 
<span class="lineNum">    4044 </span>            :     inline bool uninstallCustomFormatSpecifier(const char* formatSpecifier) {
<span class="lineNum">    4045 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    4046 </span>            :         std::vector&lt;CustomFormatSpecifier&gt;::iterator it = std::find(m_customFormatSpecifiers.begin(),
<span class="lineNum">    4047 </span>            :                 m_customFormatSpecifiers.end(), formatSpecifier);
<span class="lineNum">    4048 </span>            :         if (it != m_customFormatSpecifiers.end() &amp;&amp; strcmp(formatSpecifier, it-&gt;formatSpecifier()) == 0) {
<span class="lineNum">    4049 </span>            :             m_customFormatSpecifiers.erase(it);
<span class="lineNum">    4050 </span>            :             return true;
<span class="lineNum">    4051 </span>            :         }
<span class="lineNum">    4052 </span>            :         return false;
<a name="4053"><span class="lineNum">    4053 </span>            :     }</a>
<span class="lineNum">    4054 </span>            : 
<span class="lineNum">    4055 </span><span class="lineCov">       2488 :     const std::vector&lt;CustomFormatSpecifier&gt;* customFormatSpecifiers(void) const {</span>
<span class="lineNum">    4056 </span><span class="lineCov">       2488 :         return &amp;m_customFormatSpecifiers;</span>
<span class="lineNum">    4057 </span>            :     }
<span class="lineNum">    4058 </span>            : 
<span class="lineNum">    4059 </span>            :     inline void setLoggingLevel(Level level) {
<span class="lineNum">    4060 </span>            :         m_loggingLevel = level;
<span class="lineNum">    4061 </span>            :     }
<a name="4062"><span class="lineNum">    4062 </span>            : </a>
<span class="lineNum">    4063 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    4064 </span><span class="lineCov">          2 :     inline bool installLogDispatchCallback(const std::string&amp; id) {</span>
<span class="lineNum">    4065 </span><span class="lineCov">          2 :         return installCallback&lt;T, base::type::LogDispatchCallbackPtr&gt;(id, &amp;m_logDispatchCallbacks);</span>
<span class="lineNum">    4066 </span>            :     }
<span class="lineNum">    4067 </span>            : 
<span class="lineNum">    4068 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    4069 </span>            :     inline void uninstallLogDispatchCallback(const std::string&amp; id) {
<span class="lineNum">    4070 </span>            :         uninstallCallback&lt;T, base::type::LogDispatchCallbackPtr&gt;(id, &amp;m_logDispatchCallbacks);
<span class="lineNum">    4071 </span>            :     }
<span class="lineNum">    4072 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    4073 </span>            :     inline T* logDispatchCallback(const std::string&amp; id) {
<span class="lineNum">    4074 </span>            :         return callback&lt;T, base::type::LogDispatchCallbackPtr&gt;(id, &amp;m_logDispatchCallbacks);
<span class="lineNum">    4075 </span>            :     }
<a name="4076"><span class="lineNum">    4076 </span>            : </a>
<span class="lineNum">    4077 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    4078 </span><span class="lineCov">          2 :     inline bool installPerformanceTrackingCallback(const std::string&amp; id) {</span>
<span class="lineNum">    4079 </span><span class="lineCov">          2 :         return installCallback&lt;T, base::type::PerformanceTrackingCallbackPtr&gt;(id, &amp;m_performanceTrackingCallbacks);</span>
<span class="lineNum">    4080 </span>            :     }
<span class="lineNum">    4081 </span>            : 
<span class="lineNum">    4082 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    4083 </span>            :     inline void uninstallPerformanceTrackingCallback(const std::string&amp; id) {
<span class="lineNum">    4084 </span>            :          uninstallCallback&lt;T, base::type::PerformanceTrackingCallbackPtr&gt;(id, &amp;m_performanceTrackingCallbacks);
<span class="lineNum">    4085 </span>            :     }
<span class="lineNum">    4086 </span>            : 
<span class="lineNum">    4087 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    4088 </span>            :     inline T* performanceTrackingCallback(const std::string&amp; id) {
<span class="lineNum">    4089 </span>            :         return callback&lt;T, base::type::PerformanceTrackingCallbackPtr&gt;(id, &amp;m_performanceTrackingCallbacks);
<span class="lineNum">    4090 </span>            :     }
<span class="lineNum">    4091 </span>            : private:
<span class="lineNum">    4092 </span>            :     base::RegisteredHitCounters* m_registeredHitCounters;
<span class="lineNum">    4093 </span>            :     base::RegisteredLoggers* m_registeredLoggers;
<span class="lineNum">    4094 </span>            :     base::type::EnumType m_flags;
<span class="lineNum">    4095 </span>            :     base::VRegistry* m_vRegistry;
<span class="lineNum">    4096 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    4097 </span>            :     base::AsyncLogQueue* m_asyncLogQueue;
<span class="lineNum">    4098 </span>            :     base::IWorker* m_asyncDispatchWorker;
<span class="lineNum">    4099 </span>            : #endif  // ELPP_ASYNC_LOGGING
<span class="lineNum">    4100 </span>            :     base::utils::CommandLineArgs m_commandLineArgs;
<span class="lineNum">    4101 </span>            :     PreRollOutCallback m_preRollOutCallback;
<span class="lineNum">    4102 </span>            :     std::map&lt;std::string, base::type::LogDispatchCallbackPtr&gt; m_logDispatchCallbacks;
<span class="lineNum">    4103 </span>            :     std::map&lt;std::string, base::type::PerformanceTrackingCallbackPtr&gt; m_performanceTrackingCallbacks;
<span class="lineNum">    4104 </span>            :     std::vector&lt;CustomFormatSpecifier&gt; m_customFormatSpecifiers;
<span class="lineNum">    4105 </span>            :     Level m_loggingLevel;
<span class="lineNum">    4106 </span>            : 
<span class="lineNum">    4107 </span>            :     friend class el::Helpers;
<span class="lineNum">    4108 </span>            :     friend class el::base::DefaultLogDispatchCallback;
<span class="lineNum">    4109 </span>            :     friend class el::LogBuilder;
<span class="lineNum">    4110 </span>            :     friend class el::base::MessageBuilder;
<span class="lineNum">    4111 </span>            :     friend class el::base::Writer;
<span class="lineNum">    4112 </span>            :     friend class el::base::PerformanceTracker;
<span class="lineNum">    4113 </span>            :     friend class el::base::LogDispatcher;
<span class="lineNum">    4114 </span>            : 
<span class="lineNum">    4115 </span>            :     void setApplicationArguments(int argc, char** argv) {
<span class="lineNum">    4116 </span>            :         m_commandLineArgs.setArgs(argc, argv);
<span class="lineNum">    4117 </span>            :         m_vRegistry-&gt;setFromArgs(commandLineArgs());
<span class="lineNum">    4118 </span>            :         // default log file
<span class="lineNum">    4119 </span>            : #if !defined(ELPP_DISABLE_LOG_FILE_FROM_ARG)
<span class="lineNum">    4120 </span>            :         if (m_commandLineArgs.hasParamWithValue(base::consts::kDefaultLogFileParam)) {
<span class="lineNum">    4121 </span>            :             Configurations c;
<span class="lineNum">    4122 </span>            :             c.setGlobally(ConfigurationType::Filename, std::string(m_commandLineArgs.getParamValue(base::consts::kDefaultLogFileParam)));
<span class="lineNum">    4123 </span>            :             registeredLoggers()-&gt;setDefaultConfigurations(c);
<span class="lineNum">    4124 </span>            :             for (base::RegisteredLoggers::iterator it = registeredLoggers()-&gt;begin();
<span class="lineNum">    4125 </span>            :                     it != registeredLoggers()-&gt;end(); ++it) {
<span class="lineNum">    4126 </span>            :                 it-&gt;second-&gt;configure(c);
<span class="lineNum">    4127 </span>            :             }
<span class="lineNum">    4128 </span>            :         }
<span class="lineNum">    4129 </span>            : #endif  // !defined(ELPP_DISABLE_LOG_FILE_FROM_ARG)
<span class="lineNum">    4130 </span>            : #if defined(ELPP_LOGGING_FLAGS_FROM_ARG)
<span class="lineNum">    4131 </span>            :         if (m_commandLineArgs.hasParamWithValue(base::consts::kLoggingFlagsParam)) {
<span class="lineNum">    4132 </span>            :             m_flags = atoi(m_commandLineArgs.getParamValue(base::consts::kLoggingFlagsParam));
<span class="lineNum">    4133 </span>            :         }
<span class="lineNum">    4134 </span>            : #endif  // defined(ELPP_LOGGING_FLAGS_FROM_ARG)
<span class="lineNum">    4135 </span>            :     }
<span class="lineNum">    4136 </span>            : 
<span class="lineNum">    4137 </span>            :     inline void setApplicationArguments(int argc, const char** argv) {
<span class="lineNum">    4138 </span>            :         setApplicationArguments(argc, const_cast&lt;char**&gt;(argv));
<span class="lineNum">    4139 </span>            :     }
<a name="4140"><span class="lineNum">    4140 </span>            : </a>
<span class="lineNum">    4141 </span>            :     template &lt;typename T, typename TPtr&gt;
<span class="lineNum">    4142 </span><span class="lineCov">          4 :     inline bool installCallback(const std::string&amp; id, std::map&lt;std::string, TPtr&gt;* mapT) {</span>
<span class="lineNum">    4143 </span><span class="lineCov">          4 :         if (mapT-&gt;find(id) == mapT-&gt;end()) {</span>
<span class="lineNum">    4144 </span><span class="lineCov">          4 :             mapT-&gt;insert(std::make_pair(id, TPtr(new T())));</span>
<span class="lineNum">    4145 </span><span class="lineCov">          4 :             return true;</span>
<span class="lineNum">    4146 </span>            :         }
<span class="lineNum">    4147 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4148 </span>            :     }
<span class="lineNum">    4149 </span>            : 
<span class="lineNum">    4150 </span>            :     template &lt;typename T, typename TPtr&gt;
<span class="lineNum">    4151 </span>            :     inline void uninstallCallback(const std::string&amp; id, std::map&lt;std::string, TPtr&gt;* mapT) {
<span class="lineNum">    4152 </span>            :         if (mapT-&gt;find(id) != mapT-&gt;end()) {
<span class="lineNum">    4153 </span>            :             mapT-&gt;erase(id);
<span class="lineNum">    4154 </span>            :         }
<span class="lineNum">    4155 </span>            :     }
<span class="lineNum">    4156 </span>            : 
<span class="lineNum">    4157 </span>            :     template &lt;typename T, typename TPtr&gt;
<span class="lineNum">    4158 </span>            :     inline T* callback(const std::string&amp; id, std::map&lt;std::string, TPtr&gt;* mapT) {
<span class="lineNum">    4159 </span>            :         typename std::map&lt;std::string, TPtr&gt;::iterator iter = mapT-&gt;find(id);
<span class="lineNum">    4160 </span>            :         if (iter != mapT-&gt;end()) {
<span class="lineNum">    4161 </span>            :             return static_cast&lt;T*&gt;(iter-&gt;second.get());
<span class="lineNum">    4162 </span>            :         }
<span class="lineNum">    4163 </span>            :         return nullptr;
<span class="lineNum">    4164 </span>            :     }
<span class="lineNum">    4165 </span>            : };
<a name="4166"><span class="lineNum">    4166 </span>            : extern ELPP_EXPORT base::type::StoragePointer elStorage;</a>
<span class="lineNum">    4167 </span>            : #define ELPP el::base::elStorage
<a name="4168"><span class="lineNum">    4168 </span><span class="lineCov">          2 : class DefaultLogDispatchCallback : public LogDispatchCallback {</span></a>
<span class="lineNum">    4169 </span>            : protected:
<span class="lineNum">    4170 </span><span class="lineCov">       1244 :     void handle(const LogDispatchData* data) {</span>
<span class="lineNum">    4171 </span><span class="lineCov">       1244 :         m_data = data;</span>
<span class="lineNum">    4172 </span><span class="lineCov">       1244 :         dispatch(std::move(m_data-&gt;logMessage()-&gt;logger()-&gt;logBuilder()-&gt;build(m_data-&gt;logMessage(), </span>
<span class="lineNum">    4173 </span><span class="lineCov">       1244 :             m_data-&gt;dispatchAction() == base::DispatchAction::NormalLog)));</span>
<span class="lineNum">    4174 </span><span class="lineCov">       1244 :     }</span>
<a name="4175"><span class="lineNum">    4175 </span>            : private:</a>
<span class="lineNum">    4176 </span>            :     const LogDispatchData* m_data;
<span class="lineNum">    4177 </span><span class="lineCov">       1244 :     void dispatch(base::type::string_t&amp;&amp; logLine) {</span>
<span class="lineNum">    4178 </span><span class="lineCov">       1244 :         if (m_data-&gt;dispatchAction() == base::DispatchAction::NormalLog) {</span>
<span class="lineNum">    4179 </span><span class="lineCov">       1244 :             if (m_data-&gt;logMessage()-&gt;logger()-&gt;m_typedConfigurations-&gt;toFile(m_data-&gt;logMessage()-&gt;level())) {</span>
<span class="lineNum">    4180 </span><span class="lineCov">       1244 :                 base::type::fstream_t* fs = m_data-&gt;logMessage()-&gt;logger()-&gt;m_typedConfigurations-&gt;fileStream(m_data-&gt;logMessage()-&gt;level());</span>
<span class="lineNum">    4181 </span><span class="lineCov">       1244 :                 if (fs != nullptr) {</span>
<span class="lineNum">    4182 </span><span class="lineCov">       1244 :                     fs-&gt;write(logLine.c_str(), logLine.size());</span>
<span class="lineNum">    4183 </span><span class="lineCov">       1244 :                     if (fs-&gt;fail()) {</span>
<span class="lineNum">    4184 </span>            :                         ELPP_INTERNAL_ERROR(&quot;Unable to write log to file [&quot;
<span class="lineNum">    4185 </span>            :                             &lt;&lt; m_data-&gt;logMessage()-&gt;logger()-&gt;m_typedConfigurations-&gt;filename(m_data-&gt;logMessage()-&gt;level()) &lt;&lt; &quot;].\n&quot;
<span class="lineNum">    4186 </span>            :                                 &lt;&lt; &quot;Few possible reasons (could be something else):\n&quot; &lt;&lt; &quot;      * Permission denied\n&quot;
<span class="lineNum">    4187 </span>            :                                 &lt;&lt; &quot;      * Disk full\n&quot; &lt;&lt; &quot;      * Disk is not writable&quot;, true);
<span class="lineNum">    4188 </span>            :                     } else {
<span class="lineNum">    4189 </span><span class="lineCov">       1244 :                         if (ELPP-&gt;hasFlag(LoggingFlag::ImmediateFlush) || (m_data-&gt;logMessage()-&gt;logger()-&gt;isFlushNeeded(m_data-&gt;logMessage()-&gt;level()))) {</span>
<span class="lineNum">    4190 </span><span class="lineCov">       1244 :                             m_data-&gt;logMessage()-&gt;logger()-&gt;flush(m_data-&gt;logMessage()-&gt;level(), fs);</span>
<span class="lineNum">    4191 </span>            :                         }
<span class="lineNum">    4192 </span>            :                     }
<span class="lineNum">    4193 </span>            :                 } else {
<span class="lineNum">    4194 </span>            :                     ELPP_INTERNAL_ERROR(&quot;Log file for [&quot; &lt;&lt; LevelHelper::convertToString(m_data-&gt;logMessage()-&gt;level()) &lt;&lt; &quot;] &quot;
<span class="lineNum">    4195 </span>            :                         &lt;&lt; &quot;has not been configured but [TO_FILE] is configured to TRUE. [Logger ID: &quot; 
<span class="lineNum">    4196 </span>            :                         &lt;&lt; m_data-&gt;logMessage()-&gt;logger()-&gt;id() &lt;&lt; &quot;]&quot;, false);
<span class="lineNum">    4197 </span>            :                 }
<span class="lineNum">    4198 </span>            :             }
<span class="lineNum">    4199 </span><span class="lineCov">       1244 :             if (m_data-&gt;logMessage()-&gt;logger()-&gt;m_typedConfigurations-&gt;toStandardOutput(m_data-&gt;logMessage()-&gt;level())) {</span>
<span class="lineNum">    4200 </span><span class="lineCov">       1244 :                 if (ELPP-&gt;hasFlag(LoggingFlag::ColoredTerminalOutput))</span>
<span class="lineNum">    4201 </span><span class="lineCov">       1244 :                     m_data-&gt;logMessage()-&gt;logger()-&gt;logBuilder()-&gt;convertToColoredOutput(&amp;logLine, m_data-&gt;logMessage()-&gt;level());</span>
<span class="lineNum">    4202 </span><span class="lineCov">       1244 :                 ELPP_COUT &lt;&lt; ELPP_COUT_LINE(logLine);</span>
<span class="lineNum">    4203 </span>            :              }
<span class="lineNum">    4204 </span>            :         }
<span class="lineNum">    4205 </span>            : #if defined(ELPP_SYSLOG)
<span class="lineNum">    4206 </span>            :         else if (m_data-&gt;dispatchAction() == base::DispatchAction::SysLog) {
<span class="lineNum">    4207 </span>            :             // Determine syslog priority
<span class="lineNum">    4208 </span>            :             int sysLogPriority = 0;
<span class="lineNum">    4209 </span>            :             if (m_data-&gt;logMessage()-&gt;level() == Level::Fatal)
<span class="lineNum">    4210 </span>            :                 sysLogPriority = LOG_EMERG;
<span class="lineNum">    4211 </span>            :             else if (m_data-&gt;logMessage()-&gt;level() == Level::Error)
<span class="lineNum">    4212 </span>            :                 sysLogPriority = LOG_ERR;
<span class="lineNum">    4213 </span>            :             else if (m_data-&gt;logMessage()-&gt;level() == Level::Warning)
<span class="lineNum">    4214 </span>            :                 sysLogPriority = LOG_WARNING;
<span class="lineNum">    4215 </span>            :             else if (m_data-&gt;logMessage()-&gt;level() == Level::Info)
<span class="lineNum">    4216 </span>            :                 sysLogPriority = LOG_INFO;
<span class="lineNum">    4217 </span>            :             else if (m_data-&gt;logMessage()-&gt;level() == Level::Debug)
<span class="lineNum">    4218 </span>            :                 sysLogPriority = LOG_DEBUG;
<span class="lineNum">    4219 </span>            :             else
<span class="lineNum">    4220 </span>            :                 sysLogPriority = LOG_NOTICE;
<span class="lineNum">    4221 </span>            : #   if defined(ELPP_UNICODE)
<span class="lineNum">    4222 </span>            :             char* line = base::utils::Str::wcharPtrToCharPtr(logLine.c_str());
<span class="lineNum">    4223 </span>            :             syslog(sysLogPriority, &quot;%s&quot;, line);
<span class="lineNum">    4224 </span>            :             free(line);
<span class="lineNum">    4225 </span>            : #   else
<span class="lineNum">    4226 </span>            :             syslog(sysLogPriority, &quot;%s&quot;, logLine.c_str());
<span class="lineNum">    4227 </span>            : #   endif
<span class="lineNum">    4228 </span>            :         }
<span class="lineNum">    4229 </span>            : #endif  // defined(ELPP_SYSLOG)
<span class="lineNum">    4230 </span><span class="lineCov">       1244 :     }</span>
<span class="lineNum">    4231 </span>            : };
<span class="lineNum">    4232 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    4233 </span>            : class AsyncLogDispatchCallback : public LogDispatchCallback {
<span class="lineNum">    4234 </span>            : protected:
<span class="lineNum">    4235 </span>            :     void handle(const LogDispatchData* data) {
<span class="lineNum">    4236 </span>            :         base::type::string_t logLine = data-&gt;logMessage()-&gt;logger()-&gt;logBuilder()-&gt;build(data-&gt;logMessage(), data-&gt;dispatchAction() == base::DispatchAction::NormalLog);
<span class="lineNum">    4237 </span>            :         if (data-&gt;dispatchAction() == base::DispatchAction::NormalLog &amp;&amp; data-&gt;logMessage()-&gt;logger()-&gt;typedConfigurations()-&gt;toStandardOutput(data-&gt;logMessage()-&gt;level())) {
<span class="lineNum">    4238 </span>            :             if (ELPP-&gt;hasFlag(LoggingFlag::ColoredTerminalOutput))
<span class="lineNum">    4239 </span>            :                 data-&gt;logMessage()-&gt;logger()-&gt;logBuilder()-&gt;convertToColoredOutput(&amp;logLine, data-&gt;logMessage()-&gt;level());
<span class="lineNum">    4240 </span>            :             ELPP_COUT &lt;&lt; ELPP_COUT_LINE(logLine);
<span class="lineNum">    4241 </span>            :         }
<span class="lineNum">    4242 </span>            :         // Save resources and only queue if we want to write to file otherwise just ignore handler
<span class="lineNum">    4243 </span>            :         if (data-&gt;logMessage()-&gt;logger()-&gt;typedConfigurations()-&gt;toFile(data-&gt;logMessage()-&gt;level())) {
<span class="lineNum">    4244 </span>            :             ELPP-&gt;asyncLogQueue()-&gt;push(AsyncLogItem(*(data-&gt;logMessage()), *data, logLine));
<span class="lineNum">    4245 </span>            :         }
<span class="lineNum">    4246 </span>            :     }
<span class="lineNum">    4247 </span>            : };
<span class="lineNum">    4248 </span>            : class AsyncDispatchWorker : public base::IWorker, public base::threading::ThreadSafe {
<span class="lineNum">    4249 </span>            : public:
<span class="lineNum">    4250 </span>            :     AsyncDispatchWorker() {
<span class="lineNum">    4251 </span>            :         setContinueRunning(false);
<span class="lineNum">    4252 </span>            :     }
<span class="lineNum">    4253 </span>            : 
<span class="lineNum">    4254 </span>            :     virtual ~AsyncDispatchWorker() {
<span class="lineNum">    4255 </span>            :         setContinueRunning(false);
<span class="lineNum">    4256 </span>            :         ELPP_INTERNAL_INFO(6, &quot;Stopping dispatch worker - Cleaning log queue&quot;);
<span class="lineNum">    4257 </span>            :         clean();
<span class="lineNum">    4258 </span>            :         ELPP_INTERNAL_INFO(6, &quot;Log queue cleaned&quot;);
<span class="lineNum">    4259 </span>            :     }
<span class="lineNum">    4260 </span>            : 
<span class="lineNum">    4261 </span>            :     inline bool clean() {
<span class="lineNum">    4262 </span>            :         std::mutex m;
<span class="lineNum">    4263 </span>            :         std::unique_lock&lt;std::mutex&gt; lk(m);
<span class="lineNum">    4264 </span>            :         cv.wait(lk, []{ return !ELPP-&gt;asyncLogQueue()-&gt;empty(); });
<span class="lineNum">    4265 </span>            :         emptyQueue();
<span class="lineNum">    4266 </span>            :         lk.unlock();
<span class="lineNum">    4267 </span>            :         cv.notify_one();
<span class="lineNum">    4268 </span>            :         return ELPP-&gt;asyncLogQueue()-&gt;empty();
<span class="lineNum">    4269 </span>            :     }
<span class="lineNum">    4270 </span>            : 
<span class="lineNum">    4271 </span>            :     inline void emptyQueue() {
<span class="lineNum">    4272 </span>            :         while (!ELPP-&gt;asyncLogQueue()-&gt;empty()) {
<span class="lineNum">    4273 </span>            :             AsyncLogItem data = ELPP-&gt;asyncLogQueue()-&gt;next();
<span class="lineNum">    4274 </span>            :             handle(&amp;data);
<span class="lineNum">    4275 </span>            :             base::threading::msleep(100);
<span class="lineNum">    4276 </span>            :         }
<span class="lineNum">    4277 </span>            :     }
<span class="lineNum">    4278 </span>            :     
<span class="lineNum">    4279 </span>            :     virtual inline void start() {
<span class="lineNum">    4280 </span>            :         base::threading::msleep(5000); // Wait extra few seconds
<span class="lineNum">    4281 </span>            :         setContinueRunning(true);
<span class="lineNum">    4282 </span>            :         std::thread t1(&amp;AsyncDispatchWorker::runner, this);
<span class="lineNum">    4283 </span>            :         t1.join();
<span class="lineNum">    4284 </span>            :     }
<span class="lineNum">    4285 </span>            : 
<span class="lineNum">    4286 </span>            :     void handle(AsyncLogItem* logItem) {
<span class="lineNum">    4287 </span>            :         LogDispatchData* data = logItem-&gt;data();
<span class="lineNum">    4288 </span>            :         LogMessage* logMessage = logItem-&gt;logMessage();
<span class="lineNum">    4289 </span>            :         Logger* logger = logMessage-&gt;logger();
<span class="lineNum">    4290 </span>            :         base::TypedConfigurations* conf = logger-&gt;typedConfigurations();
<span class="lineNum">    4291 </span>            :         base::type::string_t logLine = logItem-&gt;logLine();
<span class="lineNum">    4292 </span>            :         if (data-&gt;dispatchAction() == base::DispatchAction::NormalLog) {
<span class="lineNum">    4293 </span>            :             if (conf-&gt;toFile(logMessage-&gt;level())) {
<span class="lineNum">    4294 </span>            :                 base::type::fstream_t* fs = conf-&gt;fileStream(logMessage-&gt;level());
<span class="lineNum">    4295 </span>            :                 if (fs != nullptr) {
<span class="lineNum">    4296 </span>            :                     fs-&gt;write(logLine.c_str(), logLine.size());
<span class="lineNum">    4297 </span>            :                     if (fs-&gt;fail()) {
<span class="lineNum">    4298 </span>            :                         ELPP_INTERNAL_ERROR(&quot;Unable to write log to file [&quot;
<span class="lineNum">    4299 </span>            :                             &lt;&lt; conf-&gt;filename(logMessage-&gt;level()) &lt;&lt; &quot;].\n&quot;
<span class="lineNum">    4300 </span>            :                                 &lt;&lt; &quot;Few possible reasons (could be something else):\n&quot; &lt;&lt; &quot;      * Permission denied\n&quot;
<span class="lineNum">    4301 </span>            :                                 &lt;&lt; &quot;      * Disk full\n&quot; &lt;&lt; &quot;      * Disk is not writable&quot;, true);
<span class="lineNum">    4302 </span>            :                     } else {
<span class="lineNum">    4303 </span>            :                         if (ELPP-&gt;hasFlag(LoggingFlag::ImmediateFlush) || (logger-&gt;isFlushNeeded(logMessage-&gt;level()))) {
<span class="lineNum">    4304 </span>            :                             logger-&gt;flush(logMessage-&gt;level(), fs);
<span class="lineNum">    4305 </span>            :                         }
<span class="lineNum">    4306 </span>            :                     }
<span class="lineNum">    4307 </span>            :                 } else {
<span class="lineNum">    4308 </span>            :                     ELPP_INTERNAL_ERROR(&quot;Log file for [&quot; &lt;&lt; LevelHelper::convertToString(logMessage-&gt;level()) &lt;&lt; &quot;] &quot;
<span class="lineNum">    4309 </span>            :                         &lt;&lt; &quot;has not been configured but [TO_FILE] is configured to TRUE. [Logger ID: &quot; &lt;&lt; logger-&gt;id() &lt;&lt; &quot;]&quot;, false);
<span class="lineNum">    4310 </span>            :                 }
<span class="lineNum">    4311 </span>            :             }
<span class="lineNum">    4312 </span>            :         }
<span class="lineNum">    4313 </span>            : #   if defined(ELPP_SYSLOG)
<span class="lineNum">    4314 </span>            :         else if (data-&gt;dispatchAction() == base::DispatchAction::SysLog) {
<span class="lineNum">    4315 </span>            :             // Determine syslog priority
<span class="lineNum">    4316 </span>            :             int sysLogPriority = 0;
<span class="lineNum">    4317 </span>            :             if (logMessage-&gt;level() == Level::Fatal)
<span class="lineNum">    4318 </span>            :                 sysLogPriority = LOG_EMERG;
<span class="lineNum">    4319 </span>            :             else if (logMessage-&gt;level() == Level::Error)
<span class="lineNum">    4320 </span>            :                 sysLogPriority = LOG_ERR;
<span class="lineNum">    4321 </span>            :             else if (logMessage-&gt;level() == Level::Warning)
<span class="lineNum">    4322 </span>            :                 sysLogPriority = LOG_WARNING;
<span class="lineNum">    4323 </span>            :             else if (logMessage-&gt;level() == Level::Info)
<span class="lineNum">    4324 </span>            :                 sysLogPriority = LOG_INFO;
<span class="lineNum">    4325 </span>            :             else if (logMessage-&gt;level() == Level::Debug)
<span class="lineNum">    4326 </span>            :                 sysLogPriority = LOG_DEBUG;
<span class="lineNum">    4327 </span>            :             else
<span class="lineNum">    4328 </span>            :                 sysLogPriority = LOG_NOTICE;
<span class="lineNum">    4329 </span>            : #      if defined(ELPP_UNICODE)
<span class="lineNum">    4330 </span>            :             char* line = base::utils::Str::wcharPtrToCharPtr(logLine.c_str());
<span class="lineNum">    4331 </span>            :             syslog(sysLogPriority, &quot;%s&quot;, line);
<span class="lineNum">    4332 </span>            :             free(line);
<span class="lineNum">    4333 </span>            : #      else
<span class="lineNum">    4334 </span>            :             syslog(sysLogPriority, &quot;%s&quot;, logLine.c_str());
<span class="lineNum">    4335 </span>            : #      endif
<span class="lineNum">    4336 </span>            :         }
<span class="lineNum">    4337 </span>            : #   endif  // defined(ELPP_SYSLOG)
<span class="lineNum">    4338 </span>            :     }
<span class="lineNum">    4339 </span>            : 
<span class="lineNum">    4340 </span>            :     void run() {
<span class="lineNum">    4341 </span>            :         while (continueRunning()) {
<span class="lineNum">    4342 </span>            :             emptyQueue();
<span class="lineNum">    4343 </span>            :             base::threading::msleep(10); // 10ms
<span class="lineNum">    4344 </span>            :         }
<span class="lineNum">    4345 </span>            :     }
<span class="lineNum">    4346 </span>            : 
<span class="lineNum">    4347 </span>            :     static void* runner(void *context) {
<span class="lineNum">    4348 </span>            :         static_cast&lt;AsyncDispatchWorker*&gt;(context)-&gt;run();
<span class="lineNum">    4349 </span>            :         return NULL;
<span class="lineNum">    4350 </span>            :     }
<span class="lineNum">    4351 </span>            :     
<span class="lineNum">    4352 </span>            :     void setContinueRunning(bool value) {
<span class="lineNum">    4353 </span>            :         base::threading::ScopedLock scopedLock(m_continueRunningMutex);
<span class="lineNum">    4354 </span>            :         m_continueRunning = value;
<span class="lineNum">    4355 </span>            :     }
<span class="lineNum">    4356 </span>            :     bool continueRunning(void) {
<span class="lineNum">    4357 </span>            :         return m_continueRunning;
<span class="lineNum">    4358 </span>            :     }
<span class="lineNum">    4359 </span>            : private:
<span class="lineNum">    4360 </span>            :     std::condition_variable cv;
<span class="lineNum">    4361 </span>            :     bool m_continueRunning;
<span class="lineNum">    4362 </span>            :     base::threading::Mutex m_continueRunningMutex;
<span class="lineNum">    4363 </span>            : };
<span class="lineNum">    4364 </span>            : #endif  // ELPP_ASYNC_LOGGING
<a name="4365"><span class="lineNum">    4365 </span>            : }  // namespace base</a>
<span class="lineNum">    4366 </span>            : namespace base {
<a name="4367"><span class="lineNum">    4367 </span><span class="lineCov">          2 : class DefaultLogBuilder : public LogBuilder {</span></a>
<span class="lineNum">    4368 </span>            : public:
<span class="lineNum">    4369 </span><span class="lineCov">       1244 :     base::type::string_t build(const LogMessage* logMessage, bool appendNewLine) const {</span>
<span class="lineNum">    4370 </span><span class="lineCov">       1244 :         base::TypedConfigurations* tc = logMessage-&gt;logger()-&gt;typedConfigurations();</span>
<span class="lineNum">    4371 </span><span class="lineCov">       1244 :         const base::LogFormat* logFormat = &amp;tc-&gt;logFormat(logMessage-&gt;level());</span>
<span class="lineNum">    4372 </span><span class="lineCov">       1244 :         base::type::string_t logLine = logFormat-&gt;format();</span>
<span class="lineNum">    4373 </span><span class="lineCov">       1244 :         char buff[base::consts::kSourceFilenameMaxLength + base::consts::kSourceLineMaxLength] = &quot;&quot;;</span>
<span class="lineNum">    4374 </span><span class="lineCov">       1244 :         const char* bufLim = buff + sizeof(buff);</span>
<span class="lineNum">    4375 </span><span class="lineCov">       1244 :         if (logFormat-&gt;hasFlag(base::FormatFlags::AppName)) {</span>
<span class="lineNum">    4376 </span>            :             // App name
<span class="lineNum">    4377 </span>            :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kAppNameFormatSpecifier,
<span class="lineNum">    4378 </span><span class="lineNoCov">          0 :                     logMessage-&gt;logger()-&gt;parentApplicationName());</span>
<span class="lineNum">    4379 </span>            :         }
<span class="lineNum">    4380 </span><span class="lineCov">       1244 :         if (logFormat-&gt;hasFlag(base::FormatFlags::ThreadId)) {</span>
<span class="lineNum">    4381 </span>            :             // Thread ID
<span class="lineNum">    4382 </span>            :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kThreadIdFormatSpecifier,
<span class="lineNum">    4383 </span><span class="lineNoCov">          0 :                     base::threading::getCurrentThreadId());</span>
<span class="lineNum">    4384 </span>            :         }
<span class="lineNum">    4385 </span><span class="lineCov">       1244 :         if (logFormat-&gt;hasFlag(base::FormatFlags::DateTime)) {</span>
<span class="lineNum">    4386 </span>            :             // DateTime
<span class="lineNum">    4387 </span>            :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kDateTimeFormatSpecifier,
<span class="lineNum">    4388 </span><span class="lineCov">       1244 :                     base::utils::DateTime::getDateTime(logFormat-&gt;dateTimeFormat().c_str(), </span>
<span class="lineNum">    4389 </span><span class="lineCov">       2488 :                         &amp;tc-&gt;millisecondsWidth(logMessage-&gt;level())));</span>
<span class="lineNum">    4390 </span>            :         }
<span class="lineNum">    4391 </span><span class="lineCov">       1244 :         if (logFormat-&gt;hasFlag(base::FormatFlags::Function)) {</span>
<span class="lineNum">    4392 </span>            :             // Function
<span class="lineNum">    4393 </span><span class="lineNoCov">          0 :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogFunctionFormatSpecifier, logMessage-&gt;func());</span>
<span class="lineNum">    4394 </span>            :         }
<span class="lineNum">    4395 </span><span class="lineCov">       1244 :         if (logFormat-&gt;hasFlag(base::FormatFlags::File)) {</span>
<span class="lineNum">    4396 </span>            :             // File
<span class="lineNum">    4397 </span><span class="lineNoCov">          0 :             char* buf = base::utils::Str::clearBuff(buff, base::consts::kSourceFilenameMaxLength);</span>
<span class="lineNum">    4398 </span><span class="lineNoCov">          0 :             base::utils::File::buildStrippedFilename(logMessage-&gt;file().c_str(), buff);</span>
<span class="lineNum">    4399 </span><span class="lineNoCov">          0 :             buf = base::utils::Str::addToBuff(buff, buf, bufLim);</span>
<span class="lineNum">    4400 </span><span class="lineNoCov">          0 :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogFileFormatSpecifier, std::string(buff));</span>
<span class="lineNum">    4401 </span>            :         }
<span class="lineNum">    4402 </span><span class="lineCov">       1244 :         if (logFormat-&gt;hasFlag(base::FormatFlags::FileBase)) {</span>
<span class="lineNum">    4403 </span>            :             // FileBase
<span class="lineNum">    4404 </span><span class="lineCov">       1049 :             char* buf = base::utils::Str::clearBuff(buff, base::consts::kSourceFilenameMaxLength);</span>
<span class="lineNum">    4405 </span><span class="lineCov">       1049 :             base::utils::File::buildBaseFilename(logMessage-&gt;file(), buff);</span>
<span class="lineNum">    4406 </span><span class="lineCov">       1049 :             buf = base::utils::Str::addToBuff(buff, buf, bufLim);</span>
<span class="lineNum">    4407 </span><span class="lineCov">       1049 :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogFileBaseFormatSpecifier, std::string(buff));</span>
<span class="lineNum">    4408 </span>            :         }
<span class="lineNum">    4409 </span><span class="lineCov">       1244 :         if (logFormat-&gt;hasFlag(base::FormatFlags::Line)) {</span>
<span class="lineNum">    4410 </span>            :             // Line
<span class="lineNum">    4411 </span><span class="lineCov">       1049 :             char* buf = base::utils::Str::clearBuff(buff, base::consts::kSourceLineMaxLength);</span>
<span class="lineNum">    4412 </span>            :             buf = base::utils::Str::convertAndAddToBuff(logMessage-&gt;line(), 
<span class="lineNum">    4413 </span><span class="lineCov">       1049 :                 base::consts::kSourceLineMaxLength, buf, bufLim, false);</span>
<span class="lineNum">    4414 </span><span class="lineCov">       1049 :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogLineFormatSpecifier, std::string(buff));</span>
<span class="lineNum">    4415 </span>            :         }
<span class="lineNum">    4416 </span><span class="lineCov">       1244 :         if (logFormat-&gt;hasFlag(base::FormatFlags::Location)) {</span>
<span class="lineNum">    4417 </span>            :             // Location
<span class="lineNum">    4418 </span>            :             char* buf = base::utils::Str::clearBuff(buff, 
<span class="lineNum">    4419 </span><span class="lineNoCov">          0 :                 base::consts::kSourceFilenameMaxLength + base::consts::kSourceLineMaxLength);</span>
<span class="lineNum">    4420 </span><span class="lineNoCov">          0 :             base::utils::File::buildStrippedFilename(logMessage-&gt;file().c_str(), buff);</span>
<span class="lineNum">    4421 </span><span class="lineNoCov">          0 :             buf = base::utils::Str::addToBuff(buff, buf, bufLim);</span>
<span class="lineNum">    4422 </span><span class="lineNoCov">          0 :             buf = base::utils::Str::addToBuff(&quot;:&quot;, buf, bufLim);</span>
<span class="lineNum">    4423 </span>            :             buf = base::utils::Str::convertAndAddToBuff(logMessage-&gt;line(), 
<span class="lineNum">    4424 </span><span class="lineNoCov">          0 :                 base::consts::kSourceLineMaxLength, buf, bufLim, false);</span>
<span class="lineNum">    4425 </span><span class="lineNoCov">          0 :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kLogLocationFormatSpecifier, std::string(buff));</span>
<span class="lineNum">    4426 </span>            :         }
<span class="lineNum">    4427 </span><span class="lineCov">       1244 :         if (logMessage-&gt;level() == Level::Verbose &amp;&amp; logFormat-&gt;hasFlag(base::FormatFlags::VerboseLevel)) {</span>
<span class="lineNum">    4428 </span>            :             // Verbose level
<span class="lineNum">    4429 </span><span class="lineNoCov">          0 :             char* buf = base::utils::Str::clearBuff(buff, 1);</span>
<span class="lineNum">    4430 </span><span class="lineNoCov">          0 :             buf = base::utils::Str::convertAndAddToBuff(logMessage-&gt;verboseLevel(), 1, buf, bufLim, false);</span>
<span class="lineNum">    4431 </span><span class="lineNoCov">          0 :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kVerboseLevelFormatSpecifier, std::string(buff));</span>
<span class="lineNum">    4432 </span>            :         }
<span class="lineNum">    4433 </span><span class="lineCov">       1244 :         if (logFormat-&gt;hasFlag(base::FormatFlags::LogMessage)) {</span>
<span class="lineNum">    4434 </span>            :             // Log message
<span class="lineNum">    4435 </span><span class="lineCov">       1244 :             base::utils::Str::replaceFirstWithEscape(logLine, base::consts::kMessageFormatSpecifier, logMessage-&gt;message());</span>
<span class="lineNum">    4436 </span>            :         }
<span class="lineNum">    4437 </span>            : #if !defined(ELPP_DISABLE_CUSTOM_FORMAT_SPECIFIERS)
<span class="lineNum">    4438 </span><span class="lineCov">       3732 :         for (std::vector&lt;CustomFormatSpecifier&gt;::const_iterator it = ELPP-&gt;customFormatSpecifiers()-&gt;begin();</span>
<span class="lineNum">    4439 </span><span class="lineCov">       2488 :                 it != ELPP-&gt;customFormatSpecifiers()-&gt;end(); ++it) {</span>
<span class="lineNum">    4440 </span><span class="lineNoCov">          0 :             std::string fs(it-&gt;formatSpecifier());</span>
<span class="lineNum">    4441 </span><span class="lineNoCov">          0 :             base::type::string_t wcsFormatSpecifier(fs.begin(), fs.end());</span>
<span class="lineNum">    4442 </span><span class="lineNoCov">          0 :             base::utils::Str::replaceFirstWithEscape(logLine, wcsFormatSpecifier, std::string(it-&gt;resolver()()));</span>
<span class="lineNum">    4443 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    4444 </span>            : #endif  // !defined(ELPP_DISABLE_CUSTOM_FORMAT_SPECIFIERS)
<span class="lineNum">    4445 </span><span class="lineCov">       1244 :         if (appendNewLine) logLine += ELPP_LITERAL(&quot;\n&quot;);</span>
<span class="lineNum">    4446 </span><span class="lineCov">       1244 :         return logLine;</span>
<span class="lineNum">    4447 </span>            :     }
<a name="4448"><span class="lineNum">    4448 </span>            : };</a>
<span class="lineNum">    4449 </span>            : /// @brief Dispatches log messages
<a name="4450"><span class="lineNum">    4450 </span><span class="lineCov">       1244 : class LogDispatcher : base::NoCopy {</span></a>
<span class="lineNum">    4451 </span>            : public:
<span class="lineNum">    4452 </span><span class="lineCov">       1244 :     LogDispatcher(bool proceed, LogMessage&amp;&amp; logMessage, base::DispatchAction dispatchAction) :</span>
<span class="lineNum">    4453 </span>            :         m_proceed(proceed),
<span class="lineNum">    4454 </span><span class="lineCov">       1244 :         m_logMessage(std::move(logMessage)),</span>
<span class="lineNum">    4455 </span><span class="lineCov">       2488 :         m_dispatchAction(std::move(dispatchAction)) {</span>
<a name="4456"><span class="lineNum">    4456 </span><span class="lineCov">       1244 :     }</span></a>
<span class="lineNum">    4457 </span>            : 
<span class="lineNum">    4458 </span><span class="lineCov">       1244 :     void dispatch(void) {</span>
<span class="lineNum">    4459 </span><span class="lineCov">       1244 :         if (m_proceed &amp;&amp; m_dispatchAction == base::DispatchAction::None) {</span>
<span class="lineNum">    4460 </span><span class="lineNoCov">          0 :             m_proceed = false;</span>
<span class="lineNum">    4461 </span>            :         }
<span class="lineNum">    4462 </span><span class="lineCov">       1244 :         if (!m_proceed) {</span>
<span class="lineNum">    4463 </span><span class="lineCov">       1244 :             return;</span>
<span class="lineNum">    4464 </span>            :         }
<span class="lineNum">    4465 </span>            :         // We minimize the time of ELPP's lock - this lock is released after log is written
<span class="lineNum">    4466 </span><span class="lineCov">       1244 :         base::threading::ScopedLock scopedLock(ELPP-&gt;lock());</span>
<span class="lineNum">    4467 </span><span class="lineCov">       1244 :         base::TypedConfigurations* tc = m_logMessage.logger()-&gt;m_typedConfigurations;</span>
<span class="lineNum">    4468 </span><span class="lineCov">       1244 :         if (ELPP-&gt;hasFlag(LoggingFlag::StrictLogFileSizeCheck)) {</span>
<span class="lineNum">    4469 </span><span class="lineNoCov">          0 :             tc-&gt;validateFileRolling(m_logMessage.level(), ELPP-&gt;preRollOutCallback());</span>
<span class="lineNum">    4470 </span>            :         }
<span class="lineNum">    4471 </span><span class="lineCov">       1244 :         LogDispatchCallback* callback = nullptr;</span>
<span class="lineNum">    4472 </span><span class="lineCov">       1244 :         LogDispatchData data;</span>
<span class="lineNum">    4473 </span><span class="lineCov">       2488 :         for (const std::pair&lt;std::string, base::type::LogDispatchCallbackPtr&gt;&amp; h </span>
<span class="lineNum">    4474 </span><span class="lineCov">       2488 :                 : ELPP-&gt;m_logDispatchCallbacks) {</span>
<span class="lineNum">    4475 </span><span class="lineCov">       1244 :             callback = h.second.get();</span>
<span class="lineNum">    4476 </span><span class="lineCov">       1244 :             if (callback != nullptr &amp;&amp; callback-&gt;enabled()) {</span>
<span class="lineNum">    4477 </span><span class="lineCov">       1244 :                 data.setLogMessage(&amp;m_logMessage);</span>
<span class="lineNum">    4478 </span><span class="lineCov">       1244 :                 data.setDispatchAction(m_dispatchAction);</span>
<span class="lineNum">    4479 </span><span class="lineCov">       1244 :                 callback-&gt;acquireLock();</span>
<span class="lineNum">    4480 </span><span class="lineCov">       1244 :                 callback-&gt;handle(&amp;data);</span>
<span class="lineNum">    4481 </span><span class="lineCov">       1244 :                 callback-&gt;releaseLock();</span>
<span class="lineNum">    4482 </span>            :             }
<span class="lineNum">    4483 </span><span class="lineCov">       2488 :         }</span>
<span class="lineNum">    4484 </span>            :     }
<span class="lineNum">    4485 </span>            : 
<span class="lineNum">    4486 </span>            : private:
<span class="lineNum">    4487 </span>            :     bool m_proceed;
<span class="lineNum">    4488 </span>            :     LogMessage m_logMessage;
<span class="lineNum">    4489 </span>            :     base::DispatchAction m_dispatchAction;
<span class="lineNum">    4490 </span>            : };
<span class="lineNum">    4491 </span>            : #if defined(ELPP_STL_LOGGING)
<span class="lineNum">    4492 </span>            : /// @brief Workarounds to write some STL logs
<span class="lineNum">    4493 </span>            : ///
<span class="lineNum">    4494 </span>            : /// @detail There is workaround needed to loop through some stl containers. In order to do that, we need iterable containers
<span class="lineNum">    4495 </span>            : /// of same type and provide iterator interface and pass it on to writeIterator().
<span class="lineNum">    4496 </span>            : /// Remember, this is passed by value in constructor so that we dont change original containers.
<span class="lineNum">    4497 </span>            : /// This operation is as expensive as Big-O(std::min(class_.size(), base::consts::kMaxLogPerContainer))
<span class="lineNum">    4498 </span>            : namespace workarounds {
<span class="lineNum">    4499 </span>            : /// @brief Abstract IterableContainer template that provides interface for iterable classes of type T
<span class="lineNum">    4500 </span>            : template &lt;typename T, typename Container&gt;
<span class="lineNum">    4501 </span>            : class IterableContainer {
<span class="lineNum">    4502 </span>            : public:
<span class="lineNum">    4503 </span>            :     typedef typename Container::iterator iterator;
<span class="lineNum">    4504 </span>            :     typedef typename Container::const_iterator const_iterator;
<span class="lineNum">    4505 </span>            :     IterableContainer(void) {}
<span class="lineNum">    4506 </span>            :     virtual ~IterableContainer(void) {}
<span class="lineNum">    4507 </span>            :     iterator begin(void) { return getContainer().begin(); }
<span class="lineNum">    4508 </span>            :     iterator end(void) { return getContainer().end(); }
<span class="lineNum">    4509 </span>            : private:
<span class="lineNum">    4510 </span>            :     virtual Container&amp; getContainer(void) = 0;
<span class="lineNum">    4511 </span>            : };
<span class="lineNum">    4512 </span>            : /// @brief Implements IterableContainer and provides iterable std::priority_queue class
<span class="lineNum">    4513 </span>            : template&lt;typename T, typename Container = std::vector&lt;T&gt;, typename Comparator = std::less&lt;typename Container::value_type&gt;&gt;
<span class="lineNum">    4514 </span>            : class IterablePriorityQueue : public IterableContainer&lt;T, Container&gt;, public std::priority_queue&lt;T, Container, Comparator&gt; {
<span class="lineNum">    4515 </span>            : public:
<span class="lineNum">    4516 </span>            :     IterablePriorityQueue(std::priority_queue&lt;T, Container, Comparator&gt; queue_) {
<span class="lineNum">    4517 </span>            :         std::size_t count_ = 0;
<span class="lineNum">    4518 </span>            :         while (++count_ &lt; base::consts::kMaxLogPerContainer &amp;&amp; !queue_.empty()) {
<span class="lineNum">    4519 </span>            :             this-&gt;push(queue_.top());
<span class="lineNum">    4520 </span>            :             queue_.pop();
<span class="lineNum">    4521 </span>            :         }
<span class="lineNum">    4522 </span>            :     }
<span class="lineNum">    4523 </span>            : private:
<span class="lineNum">    4524 </span>            :     inline Container&amp; getContainer(void) {
<span class="lineNum">    4525 </span>            :         return this-&gt;c;
<span class="lineNum">    4526 </span>            :     }
<span class="lineNum">    4527 </span>            : };
<span class="lineNum">    4528 </span>            : /// @brief Implements IterableContainer and provides iterable std::queue class
<span class="lineNum">    4529 </span>            : template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt;
<span class="lineNum">    4530 </span>            : class IterableQueue : public IterableContainer&lt;T, Container&gt;, public std::queue&lt;T, Container&gt; {
<span class="lineNum">    4531 </span>            : public:
<span class="lineNum">    4532 </span>            :     IterableQueue(std::queue&lt;T, Container&gt; queue_) {
<span class="lineNum">    4533 </span>            :         std::size_t count_ = 0;
<span class="lineNum">    4534 </span>            :         while (++count_ &lt; base::consts::kMaxLogPerContainer &amp;&amp; !queue_.empty()) {
<span class="lineNum">    4535 </span>            :             this-&gt;push(queue_.front());
<span class="lineNum">    4536 </span>            :             queue_.pop();
<span class="lineNum">    4537 </span>            :         }
<span class="lineNum">    4538 </span>            :     }
<span class="lineNum">    4539 </span>            : private:
<span class="lineNum">    4540 </span>            :     inline Container&amp; getContainer(void) {
<span class="lineNum">    4541 </span>            :         return this-&gt;c;
<span class="lineNum">    4542 </span>            :     }
<span class="lineNum">    4543 </span>            : };
<span class="lineNum">    4544 </span>            : /// @brief Implements IterableContainer and provides iterable std::stack class
<span class="lineNum">    4545 </span>            : template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt;
<span class="lineNum">    4546 </span>            : class IterableStack : public IterableContainer&lt;T, Container&gt;, public std::stack&lt;T, Container&gt; {
<span class="lineNum">    4547 </span>            : public:
<span class="lineNum">    4548 </span>            :     IterableStack(std::stack&lt;T, Container&gt; stack_) {
<span class="lineNum">    4549 </span>            :         std::size_t count_ = 0;
<span class="lineNum">    4550 </span>            :         while (++count_ &lt; base::consts::kMaxLogPerContainer &amp;&amp; !stack_.empty()) {
<span class="lineNum">    4551 </span>            :             this-&gt;push(stack_.top());
<span class="lineNum">    4552 </span>            :             stack_.pop();
<span class="lineNum">    4553 </span>            :         }
<span class="lineNum">    4554 </span>            :     }
<span class="lineNum">    4555 </span>            : private:
<span class="lineNum">    4556 </span>            :     inline Container&amp; getContainer(void) {
<span class="lineNum">    4557 </span>            :         return this-&gt;c;
<span class="lineNum">    4558 </span>            :     }
<span class="lineNum">    4559 </span>            : };
<span class="lineNum">    4560 </span>            : }  // namespace workarounds
<span class="lineNum">    4561 </span>            : #endif  // defined(ELPP_STL_LOGGING)
<span class="lineNum">    4562 </span>            : // Log message builder
<a name="4563"><span class="lineNum">    4563 </span>            : class MessageBuilder {</a>
<a name="4564"><span class="lineNum">    4564 </span>            : public:</a>
<span class="lineNum">    4565 </span><span class="lineCov">       1244 :     MessageBuilder(void) : m_logger(nullptr), m_containerLogSeperator(ELPP_LITERAL(&quot;&quot;)) {}</span>
<span class="lineNum">    4566 </span><span class="lineCov">       1244 :     void initialize(Logger* logger) {</span>
<span class="lineNum">    4567 </span><span class="lineCov">       1244 :         m_logger = logger;</span>
<span class="lineNum">    4568 </span><span class="lineCov">       1244 :         m_containerLogSeperator = ELPP-&gt;hasFlag(LoggingFlag::NewLineForContainer) ? </span>
<span class="lineNum">    4569 </span><span class="lineCov">       1244 :             ELPP_LITERAL(&quot;\n    &quot;) : ELPP_LITERAL(&quot;, &quot;);</span>
<span class="lineNum">    4570 </span><span class="lineCov">       1244 :     }</span>
<span class="lineNum">    4571 </span>            : 
<span class="lineNum">    4572 </span>            : #   define ELPP_SIMPLE_LOG(LOG_TYPE)\
<span class="lineNum">    4573 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(LOG_TYPE msg) {\
<span class="lineNum">    4574 </span>            :         m_logger-&gt;stream() &lt;&lt; msg;\
<span class="lineNum">    4575 </span>            :         if (ELPP-&gt;hasFlag(LoggingFlag::AutoSpacing)) {\
<span class="lineNum">    4576 </span>            :             m_logger-&gt;stream() &lt;&lt; &quot; &quot;;\
<span class="lineNum">    4577 </span>            :         }\
<span class="lineNum">    4578 </span>            :         return *this;\
<a name="4579"><span class="lineNum">    4579 </span>            :     }</a>
<span class="lineNum">    4580 </span>            : 
<span class="lineNum">    4581 </span><span class="lineCov">       1051 :     inline MessageBuilder&amp; operator&lt;&lt;(const std::string&amp; msg) {</span>
<span class="lineNum">    4582 </span><span class="lineCov">       1051 :         return operator&lt;&lt;(msg.c_str());</span>
<span class="lineNum">    4583 </span>            :     }
<span class="lineNum">    4584 </span>            :     ELPP_SIMPLE_LOG(char)
<span class="lineNum">    4585 </span>            :     ELPP_SIMPLE_LOG(bool)
<a name="4586"><span class="lineNum">    4586 </span>            :     ELPP_SIMPLE_LOG(signed short)</a>
<span class="lineNum">    4587 </span>            :     ELPP_SIMPLE_LOG(unsigned short)
<span class="lineNum">    4588 </span><span class="lineCov">        175 :     ELPP_SIMPLE_LOG(signed int)</span>
<a name="4589"><span class="lineNum">    4589 </span>            :     ELPP_SIMPLE_LOG(unsigned int)</a>
<span class="lineNum">    4590 </span>            :     ELPP_SIMPLE_LOG(signed long)
<span class="lineNum">    4591 </span><span class="lineCov">         45 :     ELPP_SIMPLE_LOG(unsigned long)</span>
<span class="lineNum">    4592 </span>            :     ELPP_SIMPLE_LOG(float)
<a name="4593"><span class="lineNum">    4593 </span>            :     ELPP_SIMPLE_LOG(double)</a>
<span class="lineNum">    4594 </span>            :     ELPP_SIMPLE_LOG(char*)
<span class="lineNum">    4595 </span><span class="lineCov">       2487 :     ELPP_SIMPLE_LOG(const char*)</span>
<span class="lineNum">    4596 </span>            :     ELPP_SIMPLE_LOG(const void*)
<span class="lineNum">    4597 </span>            :     ELPP_SIMPLE_LOG(long double)
<span class="lineNum">    4598 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const std::wstring&amp; msg) {
<span class="lineNum">    4599 </span>            :         return operator&lt;&lt;(msg.c_str());
<span class="lineNum">    4600 </span>            :     }
<span class="lineNum">    4601 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const wchar_t* msg) {
<span class="lineNum">    4602 </span>            :         if (msg == nullptr) {
<span class="lineNum">    4603 </span>            :             m_logger-&gt;stream() &lt;&lt; base::consts::kNullPointer;
<span class="lineNum">    4604 </span>            :             return *this;
<span class="lineNum">    4605 </span>            :         }
<span class="lineNum">    4606 </span>            : #   if defined(ELPP_UNICODE)
<span class="lineNum">    4607 </span>            :         m_logger-&gt;stream() &lt;&lt; msg;
<span class="lineNum">    4608 </span>            : #   else
<span class="lineNum">    4609 </span>            :         char* buff_ = base::utils::Str::wcharPtrToCharPtr(msg);
<span class="lineNum">    4610 </span>            :         m_logger-&gt;stream() &lt;&lt; buff_;
<span class="lineNum">    4611 </span>            :         free(buff_);
<span class="lineNum">    4612 </span>            : #   endif
<span class="lineNum">    4613 </span>            :         if (ELPP-&gt;hasFlag(LoggingFlag::AutoSpacing)) {
<span class="lineNum">    4614 </span>            :             m_logger-&gt;stream() &lt;&lt; &quot; &quot;;
<span class="lineNum">    4615 </span>            :         }
<span class="lineNum">    4616 </span>            :         return *this;
<span class="lineNum">    4617 </span>            :     }
<span class="lineNum">    4618 </span>            :     // ostream manipulators
<span class="lineNum">    4619 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(std::ostream&amp; (*OStreamMani)(std::ostream&amp;)) {
<span class="lineNum">    4620 </span>            :         m_logger-&gt;stream() &lt;&lt; OStreamMani;
<span class="lineNum">    4621 </span>            :         return *this;
<span class="lineNum">    4622 </span>            :     }
<span class="lineNum">    4623 </span>            : #define ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(temp)                                                    \
<span class="lineNum">    4624 </span>            :     template &lt;typename T&gt;                                                                            \
<span class="lineNum">    4625 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T&gt;&amp; template_inst) {                                \
<span class="lineNum">    4626 </span>            :         return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \
<span class="lineNum">    4627 </span>            :     }
<span class="lineNum">    4628 </span>            : #define ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(temp)                                                    \
<span class="lineNum">    4629 </span>            :     template &lt;typename T1, typename T2&gt;                                                              \
<span class="lineNum">    4630 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T1, T2&gt;&amp; template_inst) {                           \
<span class="lineNum">    4631 </span>            :         return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \
<span class="lineNum">    4632 </span>            :     }
<span class="lineNum">    4633 </span>            : #define ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(temp)                                                  \
<span class="lineNum">    4634 </span>            :     template &lt;typename T1, typename T2, typename T3&gt;                                                 \
<span class="lineNum">    4635 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T1, T2, T3&gt;&amp; template_inst) {                       \
<span class="lineNum">    4636 </span>            :         return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \
<span class="lineNum">    4637 </span>            :     }
<span class="lineNum">    4638 </span>            : #define ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(temp)                                                   \
<span class="lineNum">    4639 </span>            :     template &lt;typename T1, typename T2, typename T3, typename T4&gt;                                    \
<span class="lineNum">    4640 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T1, T2, T3, T4&gt;&amp; template_inst) {                   \
<span class="lineNum">    4641 </span>            :         return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \
<span class="lineNum">    4642 </span>            :     }
<span class="lineNum">    4643 </span>            : #define ELPP_ITERATOR_CONTAINER_LOG_FIVE_ARG(temp)                                                   \
<span class="lineNum">    4644 </span>            :     template &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;                       \
<span class="lineNum">    4645 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const temp&lt;T1, T2, T3, T4, T5&gt;&amp; template_inst) {               \
<span class="lineNum">    4646 </span>            :         return writeIterator(template_inst.begin(), template_inst.end(), template_inst.size());      \
<span class="lineNum">    4647 </span>            :     }
<span class="lineNum">    4648 </span>            : 
<span class="lineNum">    4649 </span>            : #if defined(ELPP_STL_LOGGING)
<span class="lineNum">    4650 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(std::vector)
<span class="lineNum">    4651 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(std::list)
<span class="lineNum">    4652 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(std::deque)
<span class="lineNum">    4653 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(std::set)
<span class="lineNum">    4654 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(std::multiset)
<span class="lineNum">    4655 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(std::map)
<span class="lineNum">    4656 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(std::multimap)
<span class="lineNum">    4657 </span>            :     template &lt;class T, class Container&gt;
<span class="lineNum">    4658 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const std::queue&lt;T, Container&gt;&amp; queue_) {
<span class="lineNum">    4659 </span>            :         base::workarounds::IterableQueue&lt;T, Container&gt; iterableQueue_ =
<span class="lineNum">    4660 </span>            :                 static_cast&lt;base::workarounds::IterableQueue&lt;T, Container&gt; &gt;(queue_);
<span class="lineNum">    4661 </span>            :         return writeIterator(iterableQueue_.begin(), iterableQueue_.end(), iterableQueue_.size());
<span class="lineNum">    4662 </span>            :     }
<span class="lineNum">    4663 </span>            :     template &lt;class T, class Container&gt;
<span class="lineNum">    4664 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const std::stack&lt;T, Container&gt;&amp; stack_) {
<span class="lineNum">    4665 </span>            :         base::workarounds::IterableStack&lt;T, Container&gt; iterableStack_ =
<span class="lineNum">    4666 </span>            :                 static_cast&lt;base::workarounds::IterableStack&lt;T, Container&gt; &gt;(stack_);
<span class="lineNum">    4667 </span>            :         return writeIterator(iterableStack_.begin(), iterableStack_.end(), iterableStack_.size());
<span class="lineNum">    4668 </span>            :     }
<span class="lineNum">    4669 </span>            :     template &lt;class T, class Container, class Comparator&gt;
<span class="lineNum">    4670 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const std::priority_queue&lt;T, Container, Comparator&gt;&amp; priorityQueue_) {
<span class="lineNum">    4671 </span>            :         base::workarounds::IterablePriorityQueue&lt;T, Container, Comparator&gt; iterablePriorityQueue_ =
<span class="lineNum">    4672 </span>            :                 static_cast&lt;base::workarounds::IterablePriorityQueue&lt;T, Container, Comparator&gt; &gt;(priorityQueue_);
<span class="lineNum">    4673 </span>            :         return writeIterator(iterablePriorityQueue_.begin(), iterablePriorityQueue_.end(), iterablePriorityQueue_.size());
<span class="lineNum">    4674 </span>            :     }
<span class="lineNum">    4675 </span>            :     template &lt;class First, class Second&gt;
<span class="lineNum">    4676 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const std::pair&lt;First, Second&gt;&amp; pair_) {
<span class="lineNum">    4677 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;(&quot;);
<span class="lineNum">    4678 </span>            :         operator &lt;&lt; (static_cast&lt;First&gt;(pair_.first));
<span class="lineNum">    4679 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;, &quot;);
<span class="lineNum">    4680 </span>            :         operator &lt;&lt; (static_cast&lt;Second&gt;(pair_.second));
<span class="lineNum">    4681 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;)&quot;);
<span class="lineNum">    4682 </span>            :         return *this;
<span class="lineNum">    4683 </span>            :     }
<span class="lineNum">    4684 </span>            :     template &lt;std::size_t Size&gt;
<span class="lineNum">    4685 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const std::bitset&lt;Size&gt;&amp; bitset_) {
<span class="lineNum">    4686 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;[&quot;);
<span class="lineNum">    4687 </span>            :         operator &lt;&lt; (bitset_.to_string());
<span class="lineNum">    4688 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;]&quot;);
<span class="lineNum">    4689 </span>            :         return *this;
<span class="lineNum">    4690 </span>            :     }
<span class="lineNum">    4691 </span>            : #   if defined(ELPP_LOG_STD_ARRAY)
<span class="lineNum">    4692 </span>            :     template &lt;class T, std::size_t Size&gt;
<span class="lineNum">    4693 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const std::array&lt;T, Size&gt;&amp; array) {
<span class="lineNum">    4694 </span>            :         return writeIterator(array.begin(), array.end(), array.size());
<span class="lineNum">    4695 </span>            :     }
<span class="lineNum">    4696 </span>            : #   endif  // defined(ELPP_LOG_STD_ARRAY)
<span class="lineNum">    4697 </span>            : #   if defined(ELPP_LOG_UNORDERED_MAP)
<span class="lineNum">    4698 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_FIVE_ARG(std::unordered_map)
<span class="lineNum">    4699 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_FIVE_ARG(std::unordered_multimap)
<span class="lineNum">    4700 </span>            : #   endif  // defined(ELPP_LOG_UNORDERED_MAP)
<span class="lineNum">    4701 </span>            : #   if defined(ELPP_LOG_UNORDERED_SET)
<span class="lineNum">    4702 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(std::unordered_set)
<span class="lineNum">    4703 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(std::unordered_multiset)
<span class="lineNum">    4704 </span>            : #   endif  // defined(ELPP_LOG_UNORDERED_SET)
<span class="lineNum">    4705 </span>            : #endif  // defined(ELPP_STL_LOGGING)
<span class="lineNum">    4706 </span>            : #if defined(ELPP_QT_LOGGING)
<span class="lineNum">    4707 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const QString&amp; msg) {
<span class="lineNum">    4708 </span>            : #   if defined(ELPP_UNICODE)
<span class="lineNum">    4709 </span>            :         m_logger-&gt;stream() &lt;&lt; msg.toStdWString();
<span class="lineNum">    4710 </span>            : #   else
<span class="lineNum">    4711 </span>            :         m_logger-&gt;stream() &lt;&lt; msg.toStdString();
<span class="lineNum">    4712 </span>            : #   endif  // defined(ELPP_UNICODE)
<span class="lineNum">    4713 </span>            :         return *this;
<span class="lineNum">    4714 </span>            :     }
<span class="lineNum">    4715 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const QByteArray&amp; msg) {
<span class="lineNum">    4716 </span>            :         return operator &lt;&lt; (QString(msg));
<span class="lineNum">    4717 </span>            :     }
<span class="lineNum">    4718 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const QStringRef&amp; msg) {
<span class="lineNum">    4719 </span>            :         return operator&lt;&lt;(msg.toString());
<span class="lineNum">    4720 </span>            :     }
<span class="lineNum">    4721 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(qint64 msg) {
<span class="lineNum">    4722 </span>            : #   if defined(ELPP_UNICODE)
<span class="lineNum">    4723 </span>            :         m_logger-&gt;stream() &lt;&lt; QString::number(msg).toStdWString();
<span class="lineNum">    4724 </span>            : #   else
<span class="lineNum">    4725 </span>            :         m_logger-&gt;stream() &lt;&lt; QString::number(msg).toStdString();
<span class="lineNum">    4726 </span>            : #   endif  // defined(ELPP_UNICODE)
<span class="lineNum">    4727 </span>            :         return *this;
<span class="lineNum">    4728 </span>            :     }
<span class="lineNum">    4729 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(quint64 msg) {
<span class="lineNum">    4730 </span>            : #   if defined(ELPP_UNICODE)
<span class="lineNum">    4731 </span>            :         m_logger-&gt;stream() &lt;&lt; QString::number(msg).toStdWString();
<span class="lineNum">    4732 </span>            : #   else
<span class="lineNum">    4733 </span>            :         m_logger-&gt;stream() &lt;&lt; QString::number(msg).toStdString();
<span class="lineNum">    4734 </span>            : #   endif  // defined(ELPP_UNICODE)
<span class="lineNum">    4735 </span>            :         return *this;
<span class="lineNum">    4736 </span>            :     }
<span class="lineNum">    4737 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(QChar msg) {
<span class="lineNum">    4738 </span>            :         m_logger-&gt;stream() &lt;&lt; msg.toLatin1();
<span class="lineNum">    4739 </span>            :         return *this;
<span class="lineNum">    4740 </span>            :     }
<span class="lineNum">    4741 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const QLatin1String&amp; msg) {
<span class="lineNum">    4742 </span>            :         m_logger-&gt;stream() &lt;&lt; msg.latin1();
<span class="lineNum">    4743 </span>            :         return *this;
<span class="lineNum">    4744 </span>            :     }
<span class="lineNum">    4745 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QList)
<span class="lineNum">    4746 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QVector)
<span class="lineNum">    4747 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QQueue)
<span class="lineNum">    4748 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QSet)
<span class="lineNum">    4749 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QLinkedList)
<span class="lineNum">    4750 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(QStack)
<span class="lineNum">    4751 </span>            :     template &lt;typename First, typename Second&gt;
<span class="lineNum">    4752 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const QPair&lt;First, Second&gt;&amp; pair_) {
<span class="lineNum">    4753 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;(&quot;);
<span class="lineNum">    4754 </span>            :         operator &lt;&lt; (static_cast&lt;First&gt;(pair_.first));
<span class="lineNum">    4755 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;, &quot;);
<span class="lineNum">    4756 </span>            :         operator &lt;&lt; (static_cast&lt;Second&gt;(pair_.second));
<span class="lineNum">    4757 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;)&quot;);
<span class="lineNum">    4758 </span>            :         return *this;
<span class="lineNum">    4759 </span>            :     }
<span class="lineNum">    4760 </span>            :     template &lt;typename K, typename V&gt;
<span class="lineNum">    4761 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const QMap&lt;K, V&gt;&amp; map_) {
<span class="lineNum">    4762 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;[&quot;);
<span class="lineNum">    4763 </span>            :         QList&lt;K&gt; keys = map_.keys();
<span class="lineNum">    4764 </span>            :         typename QList&lt;K&gt;::const_iterator begin = keys.begin();
<span class="lineNum">    4765 </span>            :         typename QList&lt;K&gt;::const_iterator end = keys.end();
<span class="lineNum">    4766 </span>            :         int max_ = static_cast&lt;int&gt;(base::consts::kMaxLogPerContainer);  // to prevent warning
<span class="lineNum">    4767 </span>            :         for (int index_ = 0; begin != end &amp;&amp; index_ &lt; max_; ++index_, ++begin) {
<span class="lineNum">    4768 </span>            :             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;(&quot;);
<span class="lineNum">    4769 </span>            :             operator &lt;&lt; (static_cast&lt;K&gt;(*begin));
<span class="lineNum">    4770 </span>            :             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;, &quot;);
<span class="lineNum">    4771 </span>            :             operator &lt;&lt; (static_cast&lt;V&gt;(map_.value(*begin)));
<span class="lineNum">    4772 </span>            :             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;)&quot;);
<span class="lineNum">    4773 </span>            :             m_logger-&gt;stream() &lt;&lt; ((index_ &lt; keys.size() -1) ? m_containerLogSeperator : ELPP_LITERAL(&quot;&quot;));
<span class="lineNum">    4774 </span>            :         }
<span class="lineNum">    4775 </span>            :         if (begin != end) {
<span class="lineNum">    4776 </span>            :             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;...&quot;);
<span class="lineNum">    4777 </span>            :         }
<span class="lineNum">    4778 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;]&quot;);
<span class="lineNum">    4779 </span>            :         return *this;
<span class="lineNum">    4780 </span>            :     }
<span class="lineNum">    4781 </span>            :     template &lt;typename K, typename V&gt;
<span class="lineNum">    4782 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const QMultiMap&lt;K, V&gt;&amp; map_) {
<span class="lineNum">    4783 </span>            :         operator &lt;&lt; (static_cast&lt;QMap&lt;K, V&gt;&gt;(map_));
<span class="lineNum">    4784 </span>            :         return *this;
<span class="lineNum">    4785 </span>            :     }
<span class="lineNum">    4786 </span>            :     template &lt;typename K, typename V&gt;
<span class="lineNum">    4787 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const QHash&lt;K, V&gt;&amp; hash_) {
<span class="lineNum">    4788 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;[&quot;);
<span class="lineNum">    4789 </span>            :         QList&lt;K&gt; keys = hash_.keys();
<span class="lineNum">    4790 </span>            :         typename QList&lt;K&gt;::const_iterator begin = keys.begin();
<span class="lineNum">    4791 </span>            :         typename QList&lt;K&gt;::const_iterator end = keys.end();
<span class="lineNum">    4792 </span>            :         int max_ = static_cast&lt;int&gt;(base::consts::kMaxLogPerContainer);  // prevent type warning
<span class="lineNum">    4793 </span>            :         for (int index_ = 0; begin != end &amp;&amp; index_ &lt; max_; ++index_, ++begin) {
<span class="lineNum">    4794 </span>            :             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;(&quot;);
<span class="lineNum">    4795 </span>            :             operator &lt;&lt; (static_cast&lt;K&gt;(*begin));
<span class="lineNum">    4796 </span>            :             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;, &quot;);
<span class="lineNum">    4797 </span>            :             operator &lt;&lt; (static_cast&lt;V&gt;(hash_.value(*begin)));
<span class="lineNum">    4798 </span>            :             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;)&quot;);
<span class="lineNum">    4799 </span>            :             m_logger-&gt;stream() &lt;&lt; ((index_ &lt; keys.size() -1) ? m_containerLogSeperator : ELPP_LITERAL(&quot;&quot;));
<span class="lineNum">    4800 </span>            :         }
<span class="lineNum">    4801 </span>            :         if (begin != end) {
<span class="lineNum">    4802 </span>            :             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;...&quot;);
<span class="lineNum">    4803 </span>            :         }
<span class="lineNum">    4804 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;]&quot;);
<span class="lineNum">    4805 </span>            :         return *this;
<span class="lineNum">    4806 </span>            :     }
<span class="lineNum">    4807 </span>            :     template &lt;typename K, typename V&gt;
<span class="lineNum">    4808 </span>            :     inline MessageBuilder&amp; operator&lt;&lt;(const QMultiHash&lt;K, V&gt;&amp; multiHash_) {
<span class="lineNum">    4809 </span>            :         operator &lt;&lt; (static_cast&lt;QHash&lt;K, V&gt;&gt;(multiHash_));
<span class="lineNum">    4810 </span>            :         return *this;
<span class="lineNum">    4811 </span>            :     }
<span class="lineNum">    4812 </span>            : #endif  // defined(ELPP_QT_LOGGING)
<span class="lineNum">    4813 </span>            : #if defined(ELPP_BOOST_LOGGING)
<span class="lineNum">    4814 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(boost::container::vector)
<span class="lineNum">    4815 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(boost::container::stable_vector)
<span class="lineNum">    4816 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(boost::container::list)
<span class="lineNum">    4817 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG(boost::container::deque)
<span class="lineNum">    4818 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(boost::container::map)
<span class="lineNum">    4819 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG(boost::container::flat_map)
<span class="lineNum">    4820 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(boost::container::set)
<span class="lineNum">    4821 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG(boost::container::flat_set)
<span class="lineNum">    4822 </span>            : #endif  // defined(ELPP_BOOST_LOGGING)
<span class="lineNum">    4823 </span>            : 
<span class="lineNum">    4824 </span>            : /// @brief Macro used internally that can be used externally to make containers easylogging++ friendly
<span class="lineNum">    4825 </span>            : ///
<span class="lineNum">    4826 </span>            : /// @detail This macro expands to write an ostream&amp; operator&lt;&lt; for container. This container is expected to
<span class="lineNum">    4827 </span>            : ///         have begin() and end() methods that return respective iterators
<span class="lineNum">    4828 </span>            : /// @param ContainerType Type of container e.g, MyList from WX_DECLARE_LIST(int, MyList); in wxwidgets
<span class="lineNum">    4829 </span>            : /// @param SizeMethod Method used to get size of container.
<span class="lineNum">    4830 </span>            : /// @param ElementInstance Instance of element to be fed out. Insance name is &quot;elem&quot;. See WXELPP_ENABLED macro
<span class="lineNum">    4831 </span>            : ///        for an example usage
<span class="lineNum">    4832 </span>            : #define MAKE_CONTAINERELPP_FRIENDLY(ContainerType, SizeMethod, ElementInstance) \
<span class="lineNum">    4833 </span>            :     el::base::type::ostream_t&amp; operator&lt;&lt;(el::base::type::ostream_t&amp; ss, const ContainerType&amp; container) {\
<span class="lineNum">    4834 </span>            :         const el::base::type::char_t* sep = ELPP-&gt;hasFlag(el::LoggingFlag::NewLineForContainer) ? \
<span class="lineNum">    4835 </span>            :             ELPP_LITERAL(&quot;\n    &quot;) : ELPP_LITERAL(&quot;, &quot;);\
<span class="lineNum">    4836 </span>            :         ContainerType::const_iterator elem = container.begin();\
<span class="lineNum">    4837 </span>            :         ContainerType::const_iterator endElem = container.end();\
<span class="lineNum">    4838 </span>            :         std::size_t size_ = container.SizeMethod; \
<span class="lineNum">    4839 </span>            :         ss &lt;&lt; ELPP_LITERAL(&quot;[&quot;);\
<span class="lineNum">    4840 </span>            :         for (std::size_t i = 0; elem != endElem &amp;&amp; i &lt; el::base::consts::kMaxLogPerContainer; ++i, ++elem) { \
<span class="lineNum">    4841 </span>            :             ss &lt;&lt; ElementInstance;\
<span class="lineNum">    4842 </span>            :             ss &lt;&lt; ((i &lt; size_ - 1) ? sep : ELPP_LITERAL(&quot;&quot;));\
<span class="lineNum">    4843 </span>            :         }\
<span class="lineNum">    4844 </span>            :         if (elem != endElem) {\
<span class="lineNum">    4845 </span>            :             ss &lt;&lt; ELPP_LITERAL(&quot;...&quot;);\
<span class="lineNum">    4846 </span>            :         }\
<span class="lineNum">    4847 </span>            :         ss &lt;&lt; ELPP_LITERAL(&quot;]&quot;);\
<span class="lineNum">    4848 </span>            :         return ss;\
<span class="lineNum">    4849 </span>            :     }
<span class="lineNum">    4850 </span>            : #if defined(ELPP_WXWIDGETS_LOGGING)
<span class="lineNum">    4851 </span>            :     ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG(wxVector)
<span class="lineNum">    4852 </span>            : #   define ELPP_WX_PTR_ENABLED(ContainerType) MAKE_CONTAINERELPP_FRIENDLY(ContainerType, size(), *(*elem))
<span class="lineNum">    4853 </span>            : #   define ELPP_WX_ENABLED(ContainerType) MAKE_CONTAINERELPP_FRIENDLY(ContainerType, size(), (*elem))
<span class="lineNum">    4854 </span>            : #   define ELPP_WX_HASH_MAP_ENABLED(ContainerType) MAKE_CONTAINERELPP_FRIENDLY(ContainerType, size(), \
<span class="lineNum">    4855 </span>            :         ELPP_LITERAL(&quot;(&quot;) &lt;&lt; elem-&gt;first &lt;&lt; ELPP_LITERAL(&quot;, &quot;) &lt;&lt; elem-&gt;second &lt;&lt; ELPP_LITERAL(&quot;)&quot;)
<span class="lineNum">    4856 </span>            : #else
<span class="lineNum">    4857 </span>            : #   define ELPP_WX_PTR_ENABLED(ContainerType)
<span class="lineNum">    4858 </span>            : #   define ELPP_WX_ENABLED(ContainerType)
<span class="lineNum">    4859 </span>            : #   define ELPP_WX_HASH_MAP_ENABLED(ContainerType)
<span class="lineNum">    4860 </span>            : #endif  // defined(ELPP_WXWIDGETS_LOGGING)
<span class="lineNum">    4861 </span>            :     // Other classes
<span class="lineNum">    4862 </span>            :     template &lt;class Class&gt;
<span class="lineNum">    4863 </span>            :     ELPP_SIMPLE_LOG(const Class&amp;)
<span class="lineNum">    4864 </span>            : #undef ELPP_SIMPLE_LOG
<span class="lineNum">    4865 </span>            : #undef ELPP_ITERATOR_CONTAINER_LOG_ONE_ARG
<span class="lineNum">    4866 </span>            : #undef ELPP_ITERATOR_CONTAINER_LOG_TWO_ARG
<span class="lineNum">    4867 </span>            : #undef ELPP_ITERATOR_CONTAINER_LOG_THREE_ARG
<span class="lineNum">    4868 </span>            : #undef ELPP_ITERATOR_CONTAINER_LOG_FOUR_ARG
<span class="lineNum">    4869 </span>            : #undef ELPP_ITERATOR_CONTAINER_LOG_FIVE_ARG
<span class="lineNum">    4870 </span>            : private:
<span class="lineNum">    4871 </span>            :     Logger* m_logger;
<span class="lineNum">    4872 </span>            :     const base::type::char_t* m_containerLogSeperator;
<span class="lineNum">    4873 </span>            : 
<span class="lineNum">    4874 </span>            :     template&lt;class Iterator&gt;
<span class="lineNum">    4875 </span>            :     inline MessageBuilder&amp; writeIterator(Iterator begin_, Iterator end_, std::size_t size_) {
<span class="lineNum">    4876 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;[&quot;);
<span class="lineNum">    4877 </span>            :         for (std::size_t i = 0; begin_ != end_ &amp;&amp; i &lt; base::consts::kMaxLogPerContainer; ++i, ++begin_) {
<span class="lineNum">    4878 </span>            :             operator &lt;&lt; (*begin_);
<span class="lineNum">    4879 </span>            :             m_logger-&gt;stream() &lt;&lt; ((i &lt; size_ - 1) ? m_containerLogSeperator : ELPP_LITERAL(&quot;&quot;));
<span class="lineNum">    4880 </span>            :         }
<span class="lineNum">    4881 </span>            :         if (begin_ != end_) {
<span class="lineNum">    4882 </span>            :             m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;...&quot;);
<span class="lineNum">    4883 </span>            :         }
<span class="lineNum">    4884 </span>            :         m_logger-&gt;stream() &lt;&lt; ELPP_LITERAL(&quot;]&quot;);
<span class="lineNum">    4885 </span>            :         if (ELPP-&gt;hasFlag(LoggingFlag::AutoSpacing)) {
<span class="lineNum">    4886 </span>            :             m_logger-&gt;stream() &lt;&lt; &quot; &quot;;
<span class="lineNum">    4887 </span>            :         }
<span class="lineNum">    4888 </span>            :         return *this;
<span class="lineNum">    4889 </span>            :     }
<span class="lineNum">    4890 </span>            : };
<span class="lineNum">    4891 </span>            : /// @brief Writes nothing - Used when certain log is disabled
<span class="lineNum">    4892 </span>            : class NullWriter : base::NoCopy {
<span class="lineNum">    4893 </span>            : public:
<span class="lineNum">    4894 </span>            :     NullWriter(void) {}
<span class="lineNum">    4895 </span>            : 
<span class="lineNum">    4896 </span>            :     // Null manipulator
<span class="lineNum">    4897 </span>            :     inline NullWriter&amp; operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;)) {
<span class="lineNum">    4898 </span>            :         return *this;
<span class="lineNum">    4899 </span>            :     }
<span class="lineNum">    4900 </span>            : 
<span class="lineNum">    4901 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    4902 </span>            :     inline NullWriter&amp; operator&lt;&lt;(const T&amp;) {
<span class="lineNum">    4903 </span>            :         return *this;
<span class="lineNum">    4904 </span>            :     }
<span class="lineNum">    4905 </span>            : };
<span class="lineNum">    4906 </span>            : /// @brief Main entry point of each logging
<a name="4907"><span class="lineNum">    4907 </span>            : class Writer : base::NoCopy {</a>
<span class="lineNum">    4908 </span>            : public:
<span class="lineNum">    4909 </span><span class="lineCov">       1244 :     Writer(Level level, const char* file, unsigned long int line,</span>
<span class="lineNum">    4910 </span>            :                const char* func, base::DispatchAction dispatchAction = base::DispatchAction::NormalLog,
<span class="lineNum">    4911 </span>            :                base::type::VerboseLevel verboseLevel = 0) :
<span class="lineNum">    4912 </span>            :                    m_level(level), m_file(file), m_line(line), m_func(func), m_verboseLevel(verboseLevel),
<span class="lineNum">    4913 </span><span class="lineCov">       1244 :                    m_proceed(false), m_dispatchAction(dispatchAction) {</span>
<a name="4914"><span class="lineNum">    4914 </span><span class="lineCov">       1244 :     }</span></a>
<span class="lineNum">    4915 </span>            : 
<span class="lineNum">    4916 </span><span class="lineCov">       2488 :     virtual ~Writer(void) {</span>
<span class="lineNum">    4917 </span><span class="lineCov">       1244 :         processDispatch();</span>
<span class="lineNum">    4918 </span><span class="lineCov">       1244 :     }</span>
<a name="4919"><span class="lineNum">    4919 </span>            : </a>
<span class="lineNum">    4920 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    4921 </span><span class="lineCov">       2866 :     inline Writer&amp; operator&lt;&lt;(const T&amp; log) {</span>
<span class="lineNum">    4922 </span>            : #if ELPP_LOGGING_ENABLED
<span class="lineNum">    4923 </span><span class="lineCov">       2866 :         if (m_proceed) {</span>
<span class="lineNum">    4924 </span><span class="lineCov">       2866 :             m_messageBuilder &lt;&lt; log;</span>
<span class="lineNum">    4925 </span>            :         }
<span class="lineNum">    4926 </span>            : #endif  // ELPP_LOGGING_ENABLED
<span class="lineNum">    4927 </span><span class="lineCov">       2866 :         return *this;</span>
<span class="lineNum">    4928 </span>            :     }
<span class="lineNum">    4929 </span>            : 
<span class="lineNum">    4930 </span>            :     inline Writer&amp; operator&lt;&lt;(std::ostream&amp; (*log)(std::ostream&amp;)) {
<span class="lineNum">    4931 </span>            : #if ELPP_LOGGING_ENABLED
<span class="lineNum">    4932 </span>            :         if (m_proceed) {
<span class="lineNum">    4933 </span>            :             m_messageBuilder &lt;&lt; log;
<span class="lineNum">    4934 </span>            :         }
<span class="lineNum">    4935 </span>            : #endif  // ELPP_LOGGING_ENABLED
<span class="lineNum">    4936 </span>            :         return *this;
<span class="lineNum">    4937 </span>            :     }
<span class="lineNum">    4938 </span>            : 
<span class="lineNum">    4939 </span>            :     Writer&amp; construct(Logger* logger, bool needLock = true) {
<span class="lineNum">    4940 </span>            :         m_logger = logger;
<span class="lineNum">    4941 </span>            :         initializeLogger(logger-&gt;id(), false, needLock);
<span class="lineNum">    4942 </span>            :         m_messageBuilder.initialize(m_logger);
<span class="lineNum">    4943 </span>            :         return *this;
<a name="4944"><span class="lineNum">    4944 </span>            :     }</a>
<span class="lineNum">    4945 </span>            : 
<span class="lineNum">    4946 </span><span class="lineCov">       1244 :     Writer&amp; construct(int count, const char* loggerIds, ...) {</span>
<span class="lineNum">    4947 </span><span class="lineCov">       1244 :         if (ELPP-&gt;hasFlag(LoggingFlag::MultiLoggerSupport)) {</span>
<span class="lineNum">    4948 </span>            :             va_list loggersList;
<span class="lineNum">    4949 </span><span class="lineNoCov">          0 :             va_start(loggersList, loggerIds);</span>
<span class="lineNum">    4950 </span><span class="lineNoCov">          0 :             const char* id = loggerIds;</span>
<span class="lineNum">    4951 </span><span class="lineNoCov">          0 :             for (int i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    4952 </span><span class="lineNoCov">          0 :                 m_loggerIds.push_back(std::string(id));</span>
<span class="lineNum">    4953 </span><span class="lineNoCov">          0 :                 id = va_arg(loggersList, const char*);</span>
<span class="lineNum">    4954 </span>            :             }
<span class="lineNum">    4955 </span><span class="lineNoCov">          0 :             va_end(loggersList);</span>
<span class="lineNum">    4956 </span><span class="lineNoCov">          0 :             initializeLogger(m_loggerIds.at(0));</span>
<span class="lineNum">    4957 </span>            :         } else {
<span class="lineNum">    4958 </span><span class="lineCov">       1244 :             initializeLogger(std::string(loggerIds));</span>
<span class="lineNum">    4959 </span>            :         }
<span class="lineNum">    4960 </span><span class="lineCov">       1244 :         m_messageBuilder.initialize(m_logger);</span>
<span class="lineNum">    4961 </span><span class="lineCov">       1244 :         return *this;</span>
<span class="lineNum">    4962 </span>            :     }
<span class="lineNum">    4963 </span>            : protected:
<span class="lineNum">    4964 </span>            :     Level m_level;
<span class="lineNum">    4965 </span>            :     const char* m_file;
<span class="lineNum">    4966 </span>            :     const unsigned long int m_line;
<span class="lineNum">    4967 </span>            :     const char* m_func;
<span class="lineNum">    4968 </span>            :     base::type::VerboseLevel m_verboseLevel;
<span class="lineNum">    4969 </span>            :     Logger* m_logger;
<span class="lineNum">    4970 </span>            :     bool m_proceed;
<span class="lineNum">    4971 </span>            :     base::MessageBuilder m_messageBuilder;
<span class="lineNum">    4972 </span>            :     base::DispatchAction m_dispatchAction;
<span class="lineNum">    4973 </span>            :     std::vector&lt;std::string&gt; m_loggerIds;
<a name="4974"><span class="lineNum">    4974 </span>            :     friend class el::Helpers;</a>
<span class="lineNum">    4975 </span>            : 
<span class="lineNum">    4976 </span><span class="lineCov">       1244 :     void initializeLogger(const std::string&amp; loggerId, bool lookup = true, bool needLock = true) {</span>
<span class="lineNum">    4977 </span><span class="lineCov">       1244 :         if (lookup) {</span>
<span class="lineNum">    4978 </span><span class="lineCov">       1244 :             m_logger = ELPP-&gt;registeredLoggers()-&gt;get(loggerId, ELPP-&gt;hasFlag(LoggingFlag::CreateLoggerAutomatically));</span>
<span class="lineNum">    4979 </span>            :         }
<span class="lineNum">    4980 </span><span class="lineCov">       1244 :         if (m_logger == nullptr) {</span>
<span class="lineNum">    4981 </span><span class="lineNoCov">          0 :             ELPP-&gt;acquireLock();</span>
<span class="lineNum">    4982 </span><span class="lineNoCov">          0 :             if (!ELPP-&gt;registeredLoggers()-&gt;has(std::string(base::consts::kDefaultLoggerId))) {</span>
<span class="lineNum">    4983 </span>            :                 // Somehow default logger has been unregistered. Not good! Register again
<span class="lineNum">    4984 </span><span class="lineNoCov">          0 :                 ELPP-&gt;registeredLoggers()-&gt;get(std::string(base::consts::kDefaultLoggerId));</span>
<span class="lineNum">    4985 </span>            :             }
<span class="lineNum">    4986 </span><span class="lineNoCov">          0 :             ELPP-&gt;releaseLock();  // Need to unlock it for next writer</span>
<span class="lineNum">    4987 </span><span class="lineNoCov">          0 :             Writer(Level::Debug, m_file, m_line, m_func).construct(1, base::consts::kDefaultLoggerId)</span>
<span class="lineNum">    4988 </span><span class="lineNoCov">          0 :                     &lt;&lt; &quot;Logger [&quot; &lt;&lt; loggerId &lt;&lt; &quot;] is not registered yet!&quot;;</span>
<span class="lineNum">    4989 </span><span class="lineNoCov">          0 :             m_proceed = false;</span>
<span class="lineNum">    4990 </span>            :         } else {
<span class="lineNum">    4991 </span><span class="lineCov">       1244 :             if (needLock) {</span>
<span class="lineNum">    4992 </span><span class="lineCov">       1244 :                 m_logger-&gt;acquireLock();  // This should not be unlocked by checking m_proceed because</span>
<span class="lineNum">    4993 </span>            :                                           // m_proceed can be changed by lines below
<span class="lineNum">    4994 </span>            :             }
<span class="lineNum">    4995 </span><span class="lineCov">       1244 :             if (ELPP-&gt;hasFlag(LoggingFlag::HierarchicalLogging)) {</span>
<span class="lineNum">    4996 </span><span class="lineNoCov">          0 :                 m_proceed = m_level == Level::Verbose ? m_logger-&gt;enabled(m_level) :</span>
<span class="lineNum">    4997 </span><span class="lineNoCov">          0 :                         LevelHelper::castToInt(m_level) &gt;= LevelHelper::castToInt(ELPP-&gt;m_loggingLevel);</span>
<span class="lineNum">    4998 </span>            :             } else {
<span class="lineNum">    4999 </span><span class="lineCov">       1244 :                 m_proceed = m_logger-&gt;enabled(m_level);</span>
<span class="lineNum">    5000 </span>            :             }
<span class="lineNum">    5001 </span>            :         }
<a name="5002"><span class="lineNum">    5002 </span><span class="lineCov">       1244 :     }</span></a>
<span class="lineNum">    5003 </span>            :     
<span class="lineNum">    5004 </span><span class="lineCov">       1244 :     void processDispatch() {</span>
<span class="lineNum">    5005 </span>            : #if ELPP_LOGGING_ENABLED
<span class="lineNum">    5006 </span><span class="lineCov">       1244 :         if (ELPP-&gt;hasFlag(LoggingFlag::MultiLoggerSupport)) {</span>
<span class="lineNum">    5007 </span><span class="lineNoCov">          0 :             bool firstDispatched = false;</span>
<span class="lineNum">    5008 </span><span class="lineNoCov">          0 :             base::type::string_t logMessage;</span>
<span class="lineNum">    5009 </span><span class="lineNoCov">          0 :             std::size_t i = 0;</span>
<span class="lineNum">    5010 </span><span class="lineNoCov">          0 :             do {</span>
<span class="lineNum">    5011 </span><span class="lineNoCov">          0 :                 if (m_proceed) {</span>
<span class="lineNum">    5012 </span><span class="lineNoCov">          0 :                     if (firstDispatched) {</span>
<span class="lineNum">    5013 </span><span class="lineNoCov">          0 :                         m_logger-&gt;stream() &lt;&lt; logMessage;</span>
<span class="lineNum">    5014 </span>            :                     } else {
<span class="lineNum">    5015 </span><span class="lineNoCov">          0 :                         firstDispatched = true;</span>
<span class="lineNum">    5016 </span><span class="lineNoCov">          0 :                         if (m_loggerIds.size() &gt; 1) {</span>
<span class="lineNum">    5017 </span><span class="lineNoCov">          0 :                             logMessage = m_logger-&gt;stream().str();</span>
<span class="lineNum">    5018 </span>            :                         }
<span class="lineNum">    5019 </span>            :                     }
<span class="lineNum">    5020 </span><span class="lineNoCov">          0 :                     triggerDispatch();</span>
<span class="lineNum">    5021 </span><span class="lineNoCov">          0 :                 } else if (m_logger != nullptr) {</span>
<span class="lineNum">    5022 </span><span class="lineNoCov">          0 :                     m_logger-&gt;stream().str(ELPP_LITERAL(&quot;&quot;));</span>
<span class="lineNum">    5023 </span><span class="lineNoCov">          0 :                     m_logger-&gt;releaseLock();</span>
<span class="lineNum">    5024 </span>            :                 }
<span class="lineNum">    5025 </span><span class="lineNoCov">          0 :                 if (i + 1 &lt; m_loggerIds.size()) {</span>
<span class="lineNum">    5026 </span><span class="lineNoCov">          0 :                     initializeLogger(m_loggerIds.at(i + 1));</span>
<span class="lineNum">    5027 </span>            :                 }
<span class="lineNum">    5028 </span><span class="lineNoCov">          0 :             } while (++i &lt; m_loggerIds.size());</span>
<span class="lineNum">    5029 </span>            :         } else {
<span class="lineNum">    5030 </span><span class="lineCov">       1244 :             if (m_proceed) {</span>
<span class="lineNum">    5031 </span><span class="lineCov">       1244 :                 triggerDispatch();</span>
<span class="lineNum">    5032 </span><span class="lineNoCov">          0 :             } else if (m_logger != nullptr) {</span>
<span class="lineNum">    5033 </span><span class="lineNoCov">          0 :                 m_logger-&gt;stream().str(ELPP_LITERAL(&quot;&quot;));</span>
<span class="lineNum">    5034 </span><span class="lineNoCov">          0 :                 m_logger-&gt;releaseLock();</span>
<span class="lineNum">    5035 </span>            :             }
<span class="lineNum">    5036 </span>            :         }
<span class="lineNum">    5037 </span>            : #else
<span class="lineNum">    5038 </span>            :         if (m_logger != nullptr) {
<span class="lineNum">    5039 </span>            :             m_logger-&gt;stream().str(ELPP_LITERAL(&quot;&quot;));
<span class="lineNum">    5040 </span>            :             m_logger-&gt;releaseLock();
<span class="lineNum">    5041 </span>            :         }
<span class="lineNum">    5042 </span>            : #endif // ELPP_LOGGING_ENABLED
<a name="5043"><span class="lineNum">    5043 </span><span class="lineCov">       1244 :     }</span></a>
<span class="lineNum">    5044 </span>            : 
<span class="lineNum">    5045 </span><span class="lineCov">       1244 :     void triggerDispatch(void) {</span>
<span class="lineNum">    5046 </span><span class="lineCov">       1244 :         if (m_proceed) {</span>
<span class="lineNum">    5047 </span>            :             base::LogDispatcher(m_proceed, LogMessage(m_level, m_file, m_line, m_func, m_verboseLevel,
<span class="lineNum">    5048 </span><span class="lineCov">       1244 :                           m_logger), m_dispatchAction).dispatch();</span>
<span class="lineNum">    5049 </span>            :         }
<span class="lineNum">    5050 </span><span class="lineCov">       1244 :         if (m_logger != nullptr) {</span>
<span class="lineNum">    5051 </span><span class="lineCov">       1244 :             m_logger-&gt;stream().str(ELPP_LITERAL(&quot;&quot;));</span>
<span class="lineNum">    5052 </span><span class="lineCov">       1244 :             m_logger-&gt;releaseLock();</span>
<span class="lineNum">    5053 </span>            :         }
<span class="lineNum">    5054 </span><span class="lineCov">       2488 :         if (m_proceed &amp;&amp; m_level == Level::Fatal</span>
<span class="lineNum">    5055 </span><span class="lineCov">       1244 :                 &amp;&amp; !ELPP-&gt;hasFlag(LoggingFlag::DisableApplicationAbortOnFatalLog)) {</span>
<span class="lineNum">    5056 </span><span class="lineNoCov">          0 :             base::Writer(Level::Warning, m_file, m_line, m_func).construct(1, base::consts::kDefaultLoggerId)</span>
<span class="lineNum">    5057 </span><span class="lineNoCov">          0 :                     &lt;&lt; &quot;Aborting application. Reason: Fatal log at [&quot; &lt;&lt; m_file &lt;&lt; &quot;:&quot; &lt;&lt; m_line &lt;&lt; &quot;]&quot;;</span>
<span class="lineNum">    5058 </span><span class="lineNoCov">          0 :             std::stringstream reasonStream;</span>
<span class="lineNum">    5059 </span><span class="lineNoCov">          0 :             reasonStream &lt;&lt; &quot;Fatal log at [&quot; &lt;&lt; m_file &lt;&lt; &quot;:&quot; &lt;&lt; m_line &lt;&lt; &quot;]&quot;</span>
<span class="lineNum">    5060 </span><span class="lineNoCov">          0 :                 &lt;&lt; &quot; If you wish to disable 'abort on fatal log' please use &quot;</span>
<span class="lineNum">    5061 </span><span class="lineNoCov">          0 :                 &lt;&lt; &quot;el::Helpers::addFlag(el::LoggingFlag::DisableApplicationAbortOnFatalLog)&quot;;</span>
<span class="lineNum">    5062 </span><span class="lineNoCov">          0 :             base::utils::abort(1, reasonStream.str());</span>
<span class="lineNum">    5063 </span>            :         }
<span class="lineNum">    5064 </span><span class="lineCov">       1244 :         m_proceed = false;</span>
<span class="lineNum">    5065 </span><span class="lineCov">       1244 :     }</span>
<span class="lineNum">    5066 </span>            : };
<span class="lineNum">    5067 </span>            : class PErrorWriter : public base::Writer {
<span class="lineNum">    5068 </span>            : public:
<span class="lineNum">    5069 </span>            :     PErrorWriter(Level level, const char* file, unsigned long int line,
<span class="lineNum">    5070 </span>            :                const char* func, base::DispatchAction dispatchAction = base::DispatchAction::NormalLog,
<span class="lineNum">    5071 </span>            :                base::type::VerboseLevel verboseLevel = 0) :
<span class="lineNum">    5072 </span>            :         base::Writer(level, file, line, func, dispatchAction, verboseLevel) {
<span class="lineNum">    5073 </span>            :     }
<span class="lineNum">    5074 </span>            : 
<span class="lineNum">    5075 </span>            :     virtual ~PErrorWriter(void) {
<span class="lineNum">    5076 </span>            :         if (m_proceed) {
<span class="lineNum">    5077 </span>            : #if ELPP_COMPILER_MSVC
<span class="lineNum">    5078 </span>            :             char buff[256];
<span class="lineNum">    5079 </span>            :             strerror_s(buff, 256, errno);
<span class="lineNum">    5080 </span>            :             m_logger-&gt;stream() &lt;&lt; &quot;: &quot; &lt;&lt; buff &lt;&lt; &quot; [&quot; &lt;&lt; errno &lt;&lt; &quot;]&quot;;
<span class="lineNum">    5081 </span>            : #else
<span class="lineNum">    5082 </span>            :             m_logger-&gt;stream() &lt;&lt; &quot;: &quot; &lt;&lt; strerror(errno) &lt;&lt; &quot; [&quot; &lt;&lt; errno &lt;&lt; &quot;]&quot;;
<span class="lineNum">    5083 </span>            : #endif
<span class="lineNum">    5084 </span>            :         }
<span class="lineNum">    5085 </span>            :     }
<span class="lineNum">    5086 </span>            : };
<span class="lineNum">    5087 </span>            : }  // namespace base
<span class="lineNum">    5088 </span>            : // Logging from Logger class. Why this is here? Because we have Storage and Writer class available
<span class="lineNum">    5089 </span>            : #if ELPP_VARIADIC_TEMPLATES_SUPPORTED
<span class="lineNum">    5090 </span>            :     template &lt;typename T, typename... Args&gt;
<span class="lineNum">    5091 </span>            :     void Logger::log_(Level level, int vlevel, const char* s, const T&amp; value, const Args&amp;... args) {
<span class="lineNum">    5092 </span>            :         base::MessageBuilder b;
<span class="lineNum">    5093 </span>            :         b.initialize(this);
<span class="lineNum">    5094 </span>            :         while (*s) {
<span class="lineNum">    5095 </span>            :             if (*s == base::consts::kFormatSpecifierChar) {
<span class="lineNum">    5096 </span>            :                 if (*(s + 1) == base::consts::kFormatSpecifierChar) {
<span class="lineNum">    5097 </span>            :                     ++s;
<span class="lineNum">    5098 </span>            :                 } else {
<span class="lineNum">    5099 </span>            :                     if (*(s + 1) == base::consts::kFormatSpecifierCharValue) {
<span class="lineNum">    5100 </span>            :                         ++s;
<span class="lineNum">    5101 </span>            :                         b &lt;&lt; value;
<span class="lineNum">    5102 </span>            :                         log_(level, vlevel, ++s, args...);
<span class="lineNum">    5103 </span>            :                         return;
<span class="lineNum">    5104 </span>            :                     }
<span class="lineNum">    5105 </span>            :                 }
<span class="lineNum">    5106 </span>            :             }
<span class="lineNum">    5107 </span>            :             b &lt;&lt; *s++;
<span class="lineNum">    5108 </span>            :         }
<span class="lineNum">    5109 </span>            :         ELPP_INTERNAL_ERROR(&quot;Too many arguments provided. Unable to handle. Please provide more format specifiers&quot;, false);
<span class="lineNum">    5110 </span>            :     }
<span class="lineNum">    5111 </span>            :     template &lt;typename T&gt; 
<span class="lineNum">    5112 </span>            :     inline void Logger::log_(Level level, int vlevel, const T&amp; log) {
<span class="lineNum">    5113 </span>            :         if (level == Level::Verbose) {
<span class="lineNum">    5114 </span>            :             if (ELPP-&gt;vRegistry()-&gt;allowed(vlevel, __FILE__)) {
<span class="lineNum">    5115 </span>            :                 base::Writer(Level::Verbose, &quot;FILE&quot;, 0, &quot;FUNCTION&quot;, 
<span class="lineNum">    5116 </span>            :                     base::DispatchAction::NormalLog, vlevel).construct(this, false) &lt;&lt; log;
<span class="lineNum">    5117 </span>            :             } else {
<span class="lineNum">    5118 </span>            :                 stream().str(ELPP_LITERAL(&quot;&quot;));
<span class="lineNum">    5119 </span>            :             }
<span class="lineNum">    5120 </span>            :         } else {
<span class="lineNum">    5121 </span>            :             base::Writer(level, &quot;FILE&quot;, 0, &quot;FUNCTION&quot;).construct(this, false) &lt;&lt; log;
<span class="lineNum">    5122 </span>            :         }
<span class="lineNum">    5123 </span>            :     }
<span class="lineNum">    5124 </span>            :     template &lt;typename T, typename... Args&gt;
<span class="lineNum">    5125 </span>            :     void Logger::log(Level level, const char* s, const T&amp; value, const Args&amp;... args) {
<span class="lineNum">    5126 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    5127 </span>            :         log_(level, 0, s, value, args...);
<span class="lineNum">    5128 </span>            :     }
<span class="lineNum">    5129 </span>            :     template &lt;typename T&gt; 
<span class="lineNum">    5130 </span>            :     inline void Logger::log(Level level, const T&amp; log) { 
<span class="lineNum">    5131 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    5132 </span>            :         log_(level, 0, log);
<span class="lineNum">    5133 </span>            :     }
<span class="lineNum">    5134 </span>            : #   if ELPP_VERBOSE_LOG
<span class="lineNum">    5135 </span>            :     template &lt;typename T, typename... Args&gt;
<span class="lineNum">    5136 </span>            :     inline void Logger::verbose(int vlevel, const char* s, const T&amp; value, const Args&amp;... args) {
<span class="lineNum">    5137 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    5138 </span>            :         log_(el::Level::Verbose, vlevel, s, value, args...);
<span class="lineNum">    5139 </span>            :     }
<span class="lineNum">    5140 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    5141 </span>            :     inline void Logger::verbose(int vlevel, const T&amp; log) {
<span class="lineNum">    5142 </span>            :         base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    5143 </span>            :         log_(el::Level::Verbose, vlevel, log);
<span class="lineNum">    5144 </span>            :     }
<span class="lineNum">    5145 </span>            : #   else
<span class="lineNum">    5146 </span>            :     template &lt;typename T, typename... Args&gt;
<span class="lineNum">    5147 </span>            :     inline void Logger::verbose(int, const char*, const T&amp;, const Args&amp;...) {
<span class="lineNum">    5148 </span>            :         return;
<span class="lineNum">    5149 </span>            :     }
<span class="lineNum">    5150 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    5151 </span>            :     inline void Logger::verbose(int, const T&amp;) {
<span class="lineNum">    5152 </span>            :         return;
<span class="lineNum">    5153 </span>            :     }
<span class="lineNum">    5154 </span>            : #   endif  // ELPP_VERBOSE_LOG
<span class="lineNum">    5155 </span>            : #   define LOGGER_LEVEL_WRITERS(FUNCTION_NAME, LOG_LEVEL)\
<span class="lineNum">    5156 </span>            :     template &lt;typename T, typename... Args&gt;\
<span class="lineNum">    5157 </span>            :     inline void Logger::FUNCTION_NAME(const char* s, const T&amp; value, const Args&amp;... args) {\
<span class="lineNum">    5158 </span>            :         log(LOG_LEVEL, s, value, args...);\
<span class="lineNum">    5159 </span>            :     }\
<span class="lineNum">    5160 </span>            :     template &lt;typename T&gt;\
<span class="lineNum">    5161 </span>            :     inline void Logger::FUNCTION_NAME(const T&amp; value) {\
<span class="lineNum">    5162 </span>            :         log(LOG_LEVEL, value);\
<span class="lineNum">    5163 </span>            :     }
<span class="lineNum">    5164 </span>            : #   define LOGGER_LEVEL_WRITERS_DISABLED(FUNCTION_NAME, LOG_LEVEL)\
<span class="lineNum">    5165 </span>            :     template &lt;typename T, typename... Args&gt;\
<span class="lineNum">    5166 </span>            :     inline void Logger::FUNCTION_NAME(const char*, const T&amp;, const Args&amp;...) {\
<span class="lineNum">    5167 </span>            :         return;\
<span class="lineNum">    5168 </span>            :     }\
<span class="lineNum">    5169 </span>            :     template &lt;typename T&gt;\
<span class="lineNum">    5170 </span>            :     inline void Logger::FUNCTION_NAME(const T&amp;) {\
<span class="lineNum">    5171 </span>            :         return;\
<span class="lineNum">    5172 </span>            :     }
<span class="lineNum">    5173 </span>            : 
<span class="lineNum">    5174 </span>            : #   if ELPP_INFO_LOG
<span class="lineNum">    5175 </span>            :     LOGGER_LEVEL_WRITERS(info, Level::Info)
<span class="lineNum">    5176 </span>            : #   else
<span class="lineNum">    5177 </span>            :     LOGGER_LEVEL_WRITERS_DISABLED(info, Level::Info)
<span class="lineNum">    5178 </span>            : #   endif // ELPP_INFO_LOG
<span class="lineNum">    5179 </span>            : #   if ELPP_DEBUG_LOG
<span class="lineNum">    5180 </span>            :     LOGGER_LEVEL_WRITERS(debug, Level::Debug)
<span class="lineNum">    5181 </span>            : #   else
<span class="lineNum">    5182 </span>            :     LOGGER_LEVEL_WRITERS_DISABLED(debug, Level::Debug)
<span class="lineNum">    5183 </span>            : #   endif // ELPP_DEBUG_LOG
<span class="lineNum">    5184 </span>            : #   if ELPP_WARNING_LOG
<span class="lineNum">    5185 </span>            :     LOGGER_LEVEL_WRITERS(warn, Level::Warning)
<span class="lineNum">    5186 </span>            : #   else
<span class="lineNum">    5187 </span>            :     LOGGER_LEVEL_WRITERS_DISABLED(warn, Level::Warning)
<span class="lineNum">    5188 </span>            : #   endif // ELPP_WARNING_LOG
<span class="lineNum">    5189 </span>            : #   if ELPP_ERROR_LOG
<span class="lineNum">    5190 </span>            :     LOGGER_LEVEL_WRITERS(error, Level::Error)
<span class="lineNum">    5191 </span>            : #   else
<span class="lineNum">    5192 </span>            :     LOGGER_LEVEL_WRITERS_DISABLED(error, Level::Error)
<span class="lineNum">    5193 </span>            : #   endif // ELPP_ERROR_LOG
<span class="lineNum">    5194 </span>            : #   if ELPP_FATAL_LOG
<span class="lineNum">    5195 </span>            :     LOGGER_LEVEL_WRITERS(fatal, Level::Fatal)
<span class="lineNum">    5196 </span>            : #   else
<span class="lineNum">    5197 </span>            :     LOGGER_LEVEL_WRITERS_DISABLED(fatal, Level::Fatal)
<span class="lineNum">    5198 </span>            : #   endif // ELPP_FATAL_LOG
<span class="lineNum">    5199 </span>            : #   if ELPP_TRACE_LOG
<span class="lineNum">    5200 </span>            :     LOGGER_LEVEL_WRITERS(trace, Level::Trace)
<span class="lineNum">    5201 </span>            : #   else
<span class="lineNum">    5202 </span>            :     LOGGER_LEVEL_WRITERS_DISABLED(trace, Level::Trace)
<span class="lineNum">    5203 </span>            : #   endif // ELPP_TRACE_LOG
<span class="lineNum">    5204 </span>            : #   undef LOGGER_LEVEL_WRITERS
<span class="lineNum">    5205 </span>            : #   undef LOGGER_LEVEL_WRITERS_DISABLED
<span class="lineNum">    5206 </span>            : #endif // ELPP_VARIADIC_TEMPLATES_SUPPORTED
<span class="lineNum">    5207 </span>            : #if ELPP_COMPILER_MSVC
<span class="lineNum">    5208 </span>            : #   define ELPP_VARIADIC_FUNC_MSVC(variadicFunction, variadicArgs) variadicFunction variadicArgs
<span class="lineNum">    5209 </span>            : #   define ELPP_VARIADIC_FUNC_MSVC_RUN(variadicFunction, ...) ELPP_VARIADIC_FUNC_MSVC(variadicFunction, (__VA_ARGS__))
<span class="lineNum">    5210 </span>            : #   define el_getVALength(...) ELPP_VARIADIC_FUNC_MSVC_RUN(el_resolveVALength, 0, ## __VA_ARGS__,\
<span class="lineNum">    5211 </span>            :        10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
<span class="lineNum">    5212 </span>            : #else
<span class="lineNum">    5213 </span>            : #   if ELPP_COMPILER_CLANG
<span class="lineNum">    5214 </span>            : #      define el_getVALength(...) el_resolveVALength(0, __VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
<span class="lineNum">    5215 </span>            : #   else
<span class="lineNum">    5216 </span>            : #      define el_getVALength(...) el_resolveVALength(0, ## __VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
<span class="lineNum">    5217 </span>            : #   endif // ELPP_COMPILER_CLANG
<span class="lineNum">    5218 </span>            : #endif // ELPP_COMPILER_MSVC
<span class="lineNum">    5219 </span>            : #define el_resolveVALength(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
<span class="lineNum">    5220 </span>            : #define ELPP_WRITE_LOG(writer, level, dispatchAction, ...) \
<span class="lineNum">    5221 </span>            :     writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
<span class="lineNum">    5222 </span>            : #define ELPP_WRITE_LOG_IF(writer, condition, level, dispatchAction, ...) if (condition) \
<span class="lineNum">    5223 </span>            :     writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
<span class="lineNum">    5224 </span>            : #define ELPP_WRITE_LOG_EVERY_N(writer, occasion, level, dispatchAction, ...) \
<span class="lineNum">    5225 </span>            :     if (ELPP-&gt;validateEveryNCounter(__FILE__, __LINE__, occasion)) \
<span class="lineNum">    5226 </span>            :         writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
<span class="lineNum">    5227 </span>            : #define ELPP_WRITE_LOG_AFTER_N(writer, n, level, dispatchAction, ...) \
<span class="lineNum">    5228 </span>            :     if (ELPP-&gt;validateAfterNCounter(__FILE__, __LINE__, n)) \
<span class="lineNum">    5229 </span>            :         writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
<span class="lineNum">    5230 </span>            : #define ELPP_WRITE_LOG_N_TIMES(writer, n, level, dispatchAction, ...) \
<span class="lineNum">    5231 </span>            :     if (ELPP-&gt;validateNTimesCounter(__FILE__, __LINE__, n)) \
<span class="lineNum">    5232 </span>            :         writer(level, __FILE__, __LINE__, ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
<span class="lineNum">    5233 </span>            : #undef ELPP_CURR_FILE_PERFORMANCE_LOGGER
<span class="lineNum">    5234 </span>            : #if defined(ELPP_PERFORMANCE_LOGGER)
<span class="lineNum">    5235 </span>            : #   define ELPP_CURR_FILE_PERFORMANCE_LOGGER ELPP_PERFORMANCE_LOGGER
<span class="lineNum">    5236 </span>            : #else
<span class="lineNum">    5237 </span>            : #   define ELPP_CURR_FILE_PERFORMANCE_LOGGER el::base::consts::kPerformanceLoggerId
<span class="lineNum">    5238 </span>            : #endif
<span class="lineNum">    5239 </span>            : class PerformanceTrackingData {
<span class="lineNum">    5240 </span>            : public:
<span class="lineNum">    5241 </span>            :     enum class DataType : base::type::EnumType {
<span class="lineNum">    5242 </span>            :         Checkpoint = 1, Complete = 2
<span class="lineNum">    5243 </span>            :     };
<span class="lineNum">    5244 </span>            :     // Do not use constructor, will run into multiple definition error, use init(PerformanceTracker*)
<span class="lineNum">    5245 </span>            :     explicit PerformanceTrackingData(DataType dataType) : m_performanceTracker(nullptr), 
<span class="lineNum">    5246 </span>            :         m_dataType(dataType), m_file(&quot;&quot;), m_line(0), m_func(&quot;&quot;) {}
<span class="lineNum">    5247 </span>            :     inline const std::string* blockName(void) const;
<span class="lineNum">    5248 </span>            :     inline const struct timeval* startTime(void) const;
<a name="5249"><span class="lineNum">    5249 </span>            :     inline const struct timeval* endTime(void) const;</a>
<a name="5250"><span class="lineNum">    5250 </span>            :     inline const struct timeval* lastCheckpointTime(void) const;</a>
<span class="lineNum">    5251 </span><span class="lineNoCov">          0 :     inline const base::PerformanceTracker* performanceTracker(void) const { return m_performanceTracker; }</span>
<a name="5252"><span class="lineNum">    5252 </span><span class="lineNoCov">          0 :     inline PerformanceTrackingData::DataType dataType(void) const { return m_dataType; }</span></a>
<a name="5253"><span class="lineNum">    5253 </span>            :     inline bool firstCheckpoint(void) const { return m_firstCheckpoint; }</a>
<a name="5254"><span class="lineNum">    5254 </span><span class="lineNoCov">          0 :     inline std::string checkpointId(void) const { return m_checkpointId; }</span></a>
<a name="5255"><span class="lineNum">    5255 </span><span class="lineNoCov">          0 :     inline const char* file(void) const { return m_file; }</span></a>
<a name="5256"><span class="lineNum">    5256 </span><span class="lineNoCov">          0 :     inline unsigned long int line(void) const { return m_line; }</span></a>
<span class="lineNum">    5257 </span><span class="lineNoCov">          0 :     inline const char* func(void) const { return m_func; }</span>
<span class="lineNum">    5258 </span><span class="lineNoCov">          0 :     inline const base::type::string_t* formattedTimeTaken() const { return &amp;m_formattedTimeTaken; }</span>
<span class="lineNum">    5259 </span>            :     inline const std::string&amp; loggerId(void) const;
<span class="lineNum">    5260 </span>            : private:
<span class="lineNum">    5261 </span>            :     base::PerformanceTracker* m_performanceTracker;
<span class="lineNum">    5262 </span>            :     base::type::string_t m_formattedTimeTaken;
<span class="lineNum">    5263 </span>            :     PerformanceTrackingData::DataType m_dataType;
<span class="lineNum">    5264 </span>            :     bool m_firstCheckpoint;
<span class="lineNum">    5265 </span>            :     std::string m_checkpointId;
<span class="lineNum">    5266 </span>            :     const char* m_file;
<span class="lineNum">    5267 </span>            :     unsigned long int m_line;
<span class="lineNum">    5268 </span>            :     const char* m_func;    
<span class="lineNum">    5269 </span>            :     inline void init(base::PerformanceTracker* performanceTracker, bool firstCheckpoint = false) {
<span class="lineNum">    5270 </span>            :         m_performanceTracker = performanceTracker;
<span class="lineNum">    5271 </span>            :         m_firstCheckpoint = firstCheckpoint;
<span class="lineNum">    5272 </span>            :     }
<span class="lineNum">    5273 </span>            : 
<span class="lineNum">    5274 </span>            :     friend class el::base::PerformanceTracker;
<span class="lineNum">    5275 </span>            : };
<span class="lineNum">    5276 </span>            : namespace base {
<span class="lineNum">    5277 </span>            : /// @brief Represents performanceTracker block of code that conditionally adds performance status to log
<span class="lineNum">    5278 </span>            : ///        either when goes outside the scope of when checkpoint() is called
<span class="lineNum">    5279 </span>            : class PerformanceTracker : public base::threading::ThreadSafe, public Loggable {
<span class="lineNum">    5280 </span>            : public:
<span class="lineNum">    5281 </span>            :     PerformanceTracker(const std::string&amp; blockName,
<span class="lineNum">    5282 </span>            :             base::TimestampUnit timestampUnit = base::TimestampUnit::Millisecond,
<span class="lineNum">    5283 </span>            :             const std::string&amp; loggerId = std::string(ELPP_CURR_FILE_PERFORMANCE_LOGGER), 
<span class="lineNum">    5284 </span>            :             bool scopedLog = true, Level level = base::consts::kPerformanceTrackerDefaultLevel) :
<span class="lineNum">    5285 </span>            :         m_blockName(blockName), m_timestampUnit(timestampUnit), m_loggerId(loggerId), m_scopedLog(scopedLog),
<span class="lineNum">    5286 </span>            :         m_level(level), m_hasChecked(false), m_lastCheckpointId(std::string()), m_enabled(false) {
<span class="lineNum">    5287 </span>            : #if !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED
<span class="lineNum">    5288 </span>            :         // We store it locally so that if user happen to change configuration by the end of scope
<span class="lineNum">    5289 </span>            :         // or before calling checkpoint, we still depend on state of configuraton at time of construction
<span class="lineNum">    5290 </span>            :         el::Logger* loggerPtr = ELPP-&gt;registeredLoggers()-&gt;get(loggerId, false);
<span class="lineNum">    5291 </span>            :         m_enabled = loggerPtr != nullptr &amp;&amp; loggerPtr-&gt;m_typedConfigurations-&gt;performanceTracking(m_level);
<span class="lineNum">    5292 </span>            :         if (m_enabled) {
<span class="lineNum">    5293 </span>            :             base::utils::DateTime::gettimeofday(&amp;m_startTime);
<span class="lineNum">    5294 </span>            :         }
<span class="lineNum">    5295 </span>            : #endif  // !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED
<span class="lineNum">    5296 </span>            :     }
<span class="lineNum">    5297 </span>            :     /// @brief Copy constructor
<span class="lineNum">    5298 </span>            :     PerformanceTracker(const PerformanceTracker&amp; t) :
<span class="lineNum">    5299 </span>            :         m_blockName(t.m_blockName), m_timestampUnit(t.m_timestampUnit), m_loggerId(t.m_loggerId), m_scopedLog(t.m_scopedLog),
<span class="lineNum">    5300 </span>            :         m_level(t.m_level), m_hasChecked(t.m_hasChecked), m_lastCheckpointId(t.m_lastCheckpointId), m_enabled(t.m_enabled),
<span class="lineNum">    5301 </span>            :         m_startTime(t.m_startTime), m_endTime(t.m_endTime), m_lastCheckpointTime(t.m_lastCheckpointTime) {
<span class="lineNum">    5302 </span>            :     }
<span class="lineNum">    5303 </span>            :     virtual ~PerformanceTracker(void) {
<span class="lineNum">    5304 </span>            : #if !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED
<span class="lineNum">    5305 </span>            :         if (m_enabled) {
<span class="lineNum">    5306 </span>            :             base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    5307 </span>            :             if (m_scopedLog) {
<span class="lineNum">    5308 </span>            :                 base::utils::DateTime::gettimeofday(&amp;m_endTime);
<span class="lineNum">    5309 </span>            :                 base::type::string_t formattedTime = getFormattedTimeTaken();
<span class="lineNum">    5310 </span>            :                 PerformanceTrackingData data(PerformanceTrackingData::DataType::Complete);
<span class="lineNum">    5311 </span>            :                 data.init(this);
<span class="lineNum">    5312 </span>            :                 data.m_formattedTimeTaken = formattedTime;
<span class="lineNum">    5313 </span>            :                 PerformanceTrackingCallback* callback = nullptr;
<span class="lineNum">    5314 </span>            :                 for (const std::pair&lt;std::string, base::type::PerformanceTrackingCallbackPtr&gt;&amp; h
<span class="lineNum">    5315 </span>            :                         : ELPP-&gt;m_performanceTrackingCallbacks) {
<span class="lineNum">    5316 </span>            :                     callback = h.second.get();
<span class="lineNum">    5317 </span>            :                     if (callback != nullptr &amp;&amp; callback-&gt;enabled()) {
<span class="lineNum">    5318 </span>            :                         callback-&gt;acquireLock();
<span class="lineNum">    5319 </span>            :                         callback-&gt;handle(&amp;data);
<span class="lineNum">    5320 </span>            :                         callback-&gt;releaseLock();
<span class="lineNum">    5321 </span>            :                     }
<span class="lineNum">    5322 </span>            :                 }
<span class="lineNum">    5323 </span>            :             }
<span class="lineNum">    5324 </span>            :         }
<span class="lineNum">    5325 </span>            : #endif  // !defined(ELPP_DISABLE_PERFORMANCE_TRACKING)
<span class="lineNum">    5326 </span>            :     }
<span class="lineNum">    5327 </span>            :     /// @brief A checkpoint for current performanceTracker block.
<span class="lineNum">    5328 </span>            :     void checkpoint(const std::string&amp; id = std::string(), const char* file = __FILE__, unsigned long int line = __LINE__, const char* func = &quot;&quot;) {
<span class="lineNum">    5329 </span>            : #if !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED
<span class="lineNum">    5330 </span>            :         if (m_enabled) {
<span class="lineNum">    5331 </span>            :             base::threading::ScopedLock scopedLock(lock());
<span class="lineNum">    5332 </span>            :             base::utils::DateTime::gettimeofday(&amp;m_endTime);            
<span class="lineNum">    5333 </span>            :             base::type::string_t formattedTime = m_hasChecked ? getFormattedTimeTaken(m_lastCheckpointTime) : ELPP_LITERAL(&quot;&quot;);
<span class="lineNum">    5334 </span>            :             PerformanceTrackingData data(PerformanceTrackingData::DataType::Checkpoint);
<span class="lineNum">    5335 </span>            :             data.init(this);
<span class="lineNum">    5336 </span>            :             data.m_checkpointId = id;
<span class="lineNum">    5337 </span>            :             data.m_file = file;
<span class="lineNum">    5338 </span>            :             data.m_line = line;
<span class="lineNum">    5339 </span>            :             data.m_func = func;
<span class="lineNum">    5340 </span>            :             data.m_formattedTimeTaken = formattedTime;
<span class="lineNum">    5341 </span>            :             PerformanceTrackingCallback* callback = nullptr;
<span class="lineNum">    5342 </span>            :             for (const std::pair&lt;std::string, base::type::PerformanceTrackingCallbackPtr&gt;&amp; h
<span class="lineNum">    5343 </span>            :                     : ELPP-&gt;m_performanceTrackingCallbacks) {
<span class="lineNum">    5344 </span>            :                 callback = h.second.get();
<span class="lineNum">    5345 </span>            :                 if (callback != nullptr &amp;&amp; callback-&gt;enabled()) {
<span class="lineNum">    5346 </span>            :                     callback-&gt;acquireLock();
<span class="lineNum">    5347 </span>            :                     callback-&gt;handle(&amp;data);
<span class="lineNum">    5348 </span>            :                     callback-&gt;releaseLock();
<span class="lineNum">    5349 </span>            :                 }
<span class="lineNum">    5350 </span>            :             }
<span class="lineNum">    5351 </span>            :             base::utils::DateTime::gettimeofday(&amp;m_lastCheckpointTime);
<span class="lineNum">    5352 </span>            :             m_hasChecked = true;
<span class="lineNum">    5353 </span>            :             m_lastCheckpointId = id;
<span class="lineNum">    5354 </span>            :         }
<span class="lineNum">    5355 </span>            : #endif  // !defined(ELPP_DISABLE_PERFORMANCE_TRACKING) &amp;&amp; ELPP_LOGGING_ENABLED
<span class="lineNum">    5356 </span>            :         ELPP_UNUSED(id);
<span class="lineNum">    5357 </span>            :         ELPP_UNUSED(file);
<span class="lineNum">    5358 </span>            :         ELPP_UNUSED(line);
<a name="5359"><span class="lineNum">    5359 </span>            :         ELPP_UNUSED(func);</a>
<span class="lineNum">    5360 </span>            :     }
<span class="lineNum">    5361 </span><span class="lineNoCov">          0 :     inline Level level(void) const { return m_level; }</span>
<span class="lineNum">    5362 </span>            : private:
<span class="lineNum">    5363 </span>            :     std::string m_blockName;
<span class="lineNum">    5364 </span>            :     base::TimestampUnit m_timestampUnit;
<span class="lineNum">    5365 </span>            :     std::string m_loggerId;
<span class="lineNum">    5366 </span>            :     bool m_scopedLog;
<span class="lineNum">    5367 </span>            :     Level m_level;
<span class="lineNum">    5368 </span>            :     bool m_hasChecked;
<span class="lineNum">    5369 </span>            :     std::string m_lastCheckpointId;
<span class="lineNum">    5370 </span>            :     bool m_enabled;
<span class="lineNum">    5371 </span>            :     struct timeval m_startTime, m_endTime, m_lastCheckpointTime;
<span class="lineNum">    5372 </span>            : 
<span class="lineNum">    5373 </span>            :     PerformanceTracker(void);
<span class="lineNum">    5374 </span>            : 
<span class="lineNum">    5375 </span>            :     friend class el::PerformanceTrackingData;
<span class="lineNum">    5376 </span>            :     friend class base::DefaultPerformanceTrackingCallback;
<span class="lineNum">    5377 </span>            : 
<span class="lineNum">    5378 </span>            :     const inline base::type::string_t getFormattedTimeTaken() const {
<span class="lineNum">    5379 </span>            :         return getFormattedTimeTaken(m_startTime);
<span class="lineNum">    5380 </span>            :     }
<span class="lineNum">    5381 </span>            :     
<span class="lineNum">    5382 </span>            :     const base::type::string_t getFormattedTimeTaken(struct timeval startTime) const {
<span class="lineNum">    5383 </span>            :         if (ELPP-&gt;hasFlag(LoggingFlag::FixedTimeFormat)) {
<span class="lineNum">    5384 </span>            :             base::type::stringstream_t ss;
<span class="lineNum">    5385 </span>            :             ss &lt;&lt; base::utils::DateTime::getTimeDifference(m_endTime,
<span class="lineNum">    5386 </span>            :                 startTime, m_timestampUnit) &lt;&lt; &quot; &quot; &lt;&lt; base::consts::kTimeFormats[static_cast&lt;base::type::EnumType&gt;(m_timestampUnit)].unit;
<span class="lineNum">    5387 </span>            :             return ss.str();
<span class="lineNum">    5388 </span>            :         }
<span class="lineNum">    5389 </span>            :         return base::utils::DateTime::formatTime(base::utils::DateTime::getTimeDifference(m_endTime,
<span class="lineNum">    5390 </span>            :                 startTime, m_timestampUnit), m_timestampUnit);
<span class="lineNum">    5391 </span>            :     }
<span class="lineNum">    5392 </span>            : 
<span class="lineNum">    5393 </span>            :     virtual inline void log(el::base::type::ostream_t&amp; os) const {
<span class="lineNum">    5394 </span>            :         os &lt;&lt; getFormattedTimeTaken();
<a name="5395"><span class="lineNum">    5395 </span>            :     }</a>
<span class="lineNum">    5396 </span>            : };
<a name="5397"><span class="lineNum">    5397 </span><span class="lineCov">          2 : class DefaultPerformanceTrackingCallback : public PerformanceTrackingCallback {</span></a>
<span class="lineNum">    5398 </span>            : protected:
<span class="lineNum">    5399 </span><span class="lineNoCov">          0 :     void handle(const PerformanceTrackingData* data) {</span>
<span class="lineNum">    5400 </span><span class="lineNoCov">          0 :         m_data = data;</span>
<span class="lineNum">    5401 </span><span class="lineNoCov">          0 :         base::type::stringstream_t ss;</span>
<span class="lineNum">    5402 </span><span class="lineNoCov">          0 :         if (m_data-&gt;dataType() == PerformanceTrackingData::DataType::Complete) {</span>
<span class="lineNum">    5403 </span><span class="lineNoCov">          0 :             ss &lt;&lt; ELPP_LITERAL(&quot;Executed [&quot;) &lt;&lt; m_data-&gt;blockName()-&gt;c_str() &lt;&lt; ELPP_LITERAL(&quot;] in [&quot;) &lt;&lt; *m_data-&gt;formattedTimeTaken() &lt;&lt; ELPP_LITERAL(&quot;]&quot;);</span>
<span class="lineNum">    5404 </span>            :         } else {
<span class="lineNum">    5405 </span><span class="lineNoCov">          0 :             ss &lt;&lt; ELPP_LITERAL(&quot;Performance checkpoint&quot;);</span>
<span class="lineNum">    5406 </span><span class="lineNoCov">          0 :             if (!m_data-&gt;checkpointId().empty()) {</span>
<span class="lineNum">    5407 </span><span class="lineNoCov">          0 :                 ss &lt;&lt; ELPP_LITERAL(&quot; [&quot;) &lt;&lt; m_data-&gt;checkpointId().c_str() &lt;&lt; ELPP_LITERAL(&quot;]&quot;);</span>
<span class="lineNum">    5408 </span>            :             }
<span class="lineNum">    5409 </span><span class="lineNoCov">          0 :             ss &lt;&lt; ELPP_LITERAL(&quot; for block [&quot;) &lt;&lt; m_data-&gt;blockName()-&gt;c_str() &lt;&lt; ELPP_LITERAL(&quot;] : [&quot;) &lt;&lt; *m_data-&gt;performanceTracker();</span>
<span class="lineNum">    5410 </span><span class="lineNoCov">          0 :             if (!ELPP-&gt;hasFlag(LoggingFlag::DisablePerformanceTrackingCheckpointComparison) &amp;&amp; m_data-&gt;performanceTracker()-&gt;m_hasChecked) {</span>
<span class="lineNum">    5411 </span><span class="lineNoCov">          0 :                 ss &lt;&lt; ELPP_LITERAL(&quot; ([&quot;) &lt;&lt; *m_data-&gt;formattedTimeTaken() &lt;&lt; ELPP_LITERAL(&quot;] from &quot;);</span>
<span class="lineNum">    5412 </span><span class="lineNoCov">          0 :                 if (m_data-&gt;performanceTracker()-&gt;m_lastCheckpointId.empty()) {</span>
<span class="lineNum">    5413 </span><span class="lineNoCov">          0 :                     ss &lt;&lt; ELPP_LITERAL(&quot;last checkpoint&quot;);</span>
<span class="lineNum">    5414 </span>            :                 } else {
<span class="lineNum">    5415 </span><span class="lineNoCov">          0 :                     ss &lt;&lt; ELPP_LITERAL(&quot;checkpoint '&quot;) &lt;&lt; m_data-&gt;performanceTracker()-&gt;m_lastCheckpointId.c_str() &lt;&lt; ELPP_LITERAL(&quot;'&quot;);</span>
<span class="lineNum">    5416 </span>            :                 }
<span class="lineNum">    5417 </span><span class="lineNoCov">          0 :                 ss &lt;&lt; ELPP_LITERAL(&quot;)]&quot;);</span>
<span class="lineNum">    5418 </span>            :             } else {
<span class="lineNum">    5419 </span><span class="lineNoCov">          0 :                 ss &lt;&lt; ELPP_LITERAL(&quot;]&quot;);</span>
<span class="lineNum">    5420 </span>            :             }
<span class="lineNum">    5421 </span>            :         }
<span class="lineNum">    5422 </span><span class="lineNoCov">          0 :         el::base::Writer(m_data-&gt;performanceTracker()-&gt;level(), m_data-&gt;file(), m_data-&gt;line(), m_data-&gt;func()).construct(1, m_data-&gt;loggerId().c_str()) &lt;&lt; ss.str();</span>
<span class="lineNum">    5423 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    5424 </span>            : private:
<span class="lineNum">    5425 </span>            :     const PerformanceTrackingData* m_data;
<a name="5426"><span class="lineNum">    5426 </span>            : };</a>
<span class="lineNum">    5427 </span>            : }  // namespace base
<span class="lineNum">    5428 </span><span class="lineNoCov">          0 : inline const std::string* PerformanceTrackingData::blockName() const {</span>
<span class="lineNum">    5429 </span><span class="lineNoCov">          0 :     return const_cast&lt;const std::string*&gt;(&amp;m_performanceTracker-&gt;m_blockName);</span>
<span class="lineNum">    5430 </span>            : }
<span class="lineNum">    5431 </span>            : inline const struct timeval* PerformanceTrackingData::startTime() const {
<span class="lineNum">    5432 </span>            :     return const_cast&lt;const struct timeval*&gt;(&amp;m_performanceTracker-&gt;m_startTime);
<span class="lineNum">    5433 </span>            : }
<span class="lineNum">    5434 </span>            : inline const struct timeval* PerformanceTrackingData::endTime() const {
<span class="lineNum">    5435 </span>            :     return const_cast&lt;const struct timeval*&gt;(&amp;m_performanceTracker-&gt;m_endTime);
<span class="lineNum">    5436 </span>            : }
<span class="lineNum">    5437 </span>            : inline const struct timeval* PerformanceTrackingData::lastCheckpointTime() const {
<a name="5438"><span class="lineNum">    5438 </span>            :     return const_cast&lt;const struct timeval*&gt;(&amp;m_performanceTracker-&gt;m_lastCheckpointTime);</a>
<span class="lineNum">    5439 </span>            : }
<span class="lineNum">    5440 </span><span class="lineNoCov">          0 : inline const std::string&amp; PerformanceTrackingData::loggerId(void) const { return m_performanceTracker-&gt;m_loggerId; }</span>
<span class="lineNum">    5441 </span>            : namespace base {
<span class="lineNum">    5442 </span>            : /// @brief Contains some internal debugging tools like crash handler and stack tracer
<span class="lineNum">    5443 </span>            : namespace debug {
<span class="lineNum">    5444 </span>            : class StackTrace : base::NoCopy {
<span class="lineNum">    5445 </span>            : public:
<span class="lineNum">    5446 </span>            :     static const std::size_t kMaxStack = 64;
<span class="lineNum">    5447 </span>            :     static const std::size_t kStackStart = 2;  // We want to skip c'tor and StackTrace::generateNew()
<span class="lineNum">    5448 </span>            :     class StackTraceEntry {
<span class="lineNum">    5449 </span>            :     public:
<span class="lineNum">    5450 </span>            :         StackTraceEntry(std::size_t index, const char* loc, const char* demang, const char* hex, const char* addr) {
<span class="lineNum">    5451 </span>            :             m_index = index;
<span class="lineNum">    5452 </span>            :             m_location = std::string(loc);
<span class="lineNum">    5453 </span>            :             m_demangled = std::string(demang);
<span class="lineNum">    5454 </span>            :             m_hex = std::string(hex);
<span class="lineNum">    5455 </span>            :             m_addr = std::string(addr);
<span class="lineNum">    5456 </span>            :         }
<span class="lineNum">    5457 </span>            :         StackTraceEntry(std::size_t index, char* loc) {
<span class="lineNum">    5458 </span>            :             m_index = index;
<span class="lineNum">    5459 </span>            :             m_location = std::string(loc);
<span class="lineNum">    5460 </span>            :         }
<span class="lineNum">    5461 </span>            :         std::size_t m_index;
<span class="lineNum">    5462 </span>            :         std::string m_location;
<span class="lineNum">    5463 </span>            :         std::string m_demangled;
<span class="lineNum">    5464 </span>            :         std::string m_hex;
<span class="lineNum">    5465 </span>            :         std::string m_addr;
<span class="lineNum">    5466 </span>            :         friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ss, const StackTraceEntry&amp; si) {
<span class="lineNum">    5467 </span>            :            ss &lt;&lt; &quot;[&quot; &lt;&lt; si.m_index &lt;&lt; &quot;] &quot; &lt;&lt; si.m_location &lt;&lt; (si.m_demangled.empty() ? &quot;&quot; : &quot;:&quot;) &lt;&lt; si.m_demangled
<span class="lineNum">    5468 </span>            :                    &lt;&lt; (si.m_hex.empty() ? &quot;&quot; : &quot;+&quot;) &lt;&lt; si.m_hex &lt;&lt; si.m_addr;
<span class="lineNum">    5469 </span>            :            return ss;
<span class="lineNum">    5470 </span>            :         }
<span class="lineNum">    5471 </span>            : 
<span class="lineNum">    5472 </span>            :     private:
<span class="lineNum">    5473 </span>            :         StackTraceEntry(void);
<span class="lineNum">    5474 </span>            :     };
<span class="lineNum">    5475 </span>            : 
<span class="lineNum">    5476 </span>            :     StackTrace(void) {
<span class="lineNum">    5477 </span>            :         generateNew();
<span class="lineNum">    5478 </span>            :     }
<span class="lineNum">    5479 </span>            : 
<span class="lineNum">    5480 </span>            :     virtual ~StackTrace(void) {
<span class="lineNum">    5481 </span>            :     }
<span class="lineNum">    5482 </span>            : 
<span class="lineNum">    5483 </span>            :     inline std::vector&lt;StackTraceEntry&gt;&amp; getLatestStack(void) {
<span class="lineNum">    5484 </span>            :         return m_stack;
<span class="lineNum">    5485 </span>            :     }
<span class="lineNum">    5486 </span>            : 
<span class="lineNum">    5487 </span>            :     friend inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const StackTrace&amp; st) {
<span class="lineNum">    5488 </span>            :        std::vector&lt;StackTraceEntry&gt;::const_iterator it = st.m_stack.begin();
<span class="lineNum">    5489 </span>            :        while (it != st.m_stack.end()) {
<span class="lineNum">    5490 </span>            :            os &lt;&lt; &quot;    &quot; &lt;&lt; *it++ &lt;&lt; &quot;\n&quot;;
<span class="lineNum">    5491 </span>            :        }
<span class="lineNum">    5492 </span>            :        return os;
<span class="lineNum">    5493 </span>            :     }
<span class="lineNum">    5494 </span>            : 
<span class="lineNum">    5495 </span>            : private:
<span class="lineNum">    5496 </span>            :     std::vector&lt;StackTraceEntry&gt; m_stack;
<span class="lineNum">    5497 </span>            : 
<span class="lineNum">    5498 </span>            :     void generateNew(void) {
<span class="lineNum">    5499 </span>            : #if ELPP_STACKTRACE
<span class="lineNum">    5500 </span>            :         m_stack.clear();
<span class="lineNum">    5501 </span>            :         void* stack[kMaxStack];
<span class="lineNum">    5502 </span>            :         std::size_t size = backtrace(stack, kMaxStack);
<span class="lineNum">    5503 </span>            :         char** strings = backtrace_symbols(stack, size);
<span class="lineNum">    5504 </span>            :         if (size &gt; kStackStart) {  // Skip StackTrace c'tor and generateNew
<span class="lineNum">    5505 </span>            :             for (std::size_t i = kStackStart; i &lt; size; ++i) {
<span class="lineNum">    5506 </span>            :                 char* mangName = nullptr;
<span class="lineNum">    5507 </span>            :                 char* hex = nullptr;
<span class="lineNum">    5508 </span>            :                 char* addr = nullptr;
<span class="lineNum">    5509 </span>            :                 for (char* c = strings[i]; *c; ++c) {
<span class="lineNum">    5510 </span>            :                     switch (*c) {
<span class="lineNum">    5511 </span>            :                     case '(':
<span class="lineNum">    5512 </span>            :                         mangName = c;
<span class="lineNum">    5513 </span>            :                         break;
<span class="lineNum">    5514 </span>            :                     case '+':
<span class="lineNum">    5515 </span>            :                         hex = c;
<span class="lineNum">    5516 </span>            :                         break;
<span class="lineNum">    5517 </span>            :                     case ')':
<span class="lineNum">    5518 </span>            :                         addr = c;
<span class="lineNum">    5519 </span>            :                         break;
<span class="lineNum">    5520 </span>            :                     }
<span class="lineNum">    5521 </span>            :                 }
<span class="lineNum">    5522 </span>            :                 // Perform demangling if parsed properly
<span class="lineNum">    5523 </span>            :                 if (mangName != nullptr &amp;&amp; hex != nullptr &amp;&amp; addr != nullptr &amp;&amp; mangName &lt; hex) {
<span class="lineNum">    5524 </span>            :                     *mangName++ = '\0';
<span class="lineNum">    5525 </span>            :                     *hex++ = '\0';
<span class="lineNum">    5526 </span>            :                     *addr++ = '\0';
<span class="lineNum">    5527 </span>            :                     int status = 0;
<span class="lineNum">    5528 </span>            :                     char* demangName = abi::__cxa_demangle(mangName, 0, 0, &amp;status);
<span class="lineNum">    5529 </span>            :                     // if demangling is successful, output the demangled function name
<span class="lineNum">    5530 </span>            :                     if (status == 0) {
<span class="lineNum">    5531 </span>            :                         // Success (see http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01696.html)
<span class="lineNum">    5532 </span>            :                         StackTraceEntry entry(i - 1, strings[i], demangName, hex, addr);
<span class="lineNum">    5533 </span>            :                         m_stack.push_back(entry);
<span class="lineNum">    5534 </span>            :                     } else {
<span class="lineNum">    5535 </span>            :                         // Not successful - we will use mangled name
<span class="lineNum">    5536 </span>            :                         StackTraceEntry entry(i - 1, strings[i], mangName, hex, addr);
<span class="lineNum">    5537 </span>            :                         m_stack.push_back(entry);
<span class="lineNum">    5538 </span>            :                     }
<span class="lineNum">    5539 </span>            :                     free(demangName);
<span class="lineNum">    5540 </span>            :                 } else {
<span class="lineNum">    5541 </span>            :                     StackTraceEntry entry(i - 1, strings[i]);
<span class="lineNum">    5542 </span>            :                     m_stack.push_back(entry);
<span class="lineNum">    5543 </span>            :                 }
<span class="lineNum">    5544 </span>            :             }
<span class="lineNum">    5545 </span>            :         }
<span class="lineNum">    5546 </span>            :         free(strings);
<span class="lineNum">    5547 </span>            : #else
<span class="lineNum">    5548 </span>            :         ELPP_INTERNAL_INFO(1, &quot;Stacktrace generation not supported for selected compiler&quot;);
<span class="lineNum">    5549 </span>            : #endif  // ELPP_STACKTRACE
<a name="5550"><span class="lineNum">    5550 </span>            :     }</a>
<span class="lineNum">    5551 </span>            : };
<span class="lineNum">    5552 </span><span class="lineNoCov">          0 : static std::string crashReason(int sig) {</span>
<span class="lineNum">    5553 </span><span class="lineNoCov">          0 :     std::stringstream ss;</span>
<span class="lineNum">    5554 </span><span class="lineNoCov">          0 :     bool foundReason = false;</span>
<span class="lineNum">    5555 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; base::consts::kCrashSignalsCount; ++i) {</span>
<span class="lineNum">    5556 </span><span class="lineNoCov">          0 :         if (base::consts::kCrashSignals[i].numb == sig) {</span>
<span class="lineNum">    5557 </span><span class="lineNoCov">          0 :             ss &lt;&lt; &quot;Application has crashed due to [&quot; &lt;&lt; base::consts::kCrashSignals[i].name &lt;&lt; &quot;] signal&quot;;</span>
<span class="lineNum">    5558 </span><span class="lineNoCov">          0 :             if (ELPP-&gt;hasFlag(el::LoggingFlag::LogDetailedCrashReason)) {</span>
<span class="lineNum">    5559 </span><span class="lineNoCov">          0 :                 ss &lt;&lt; std::endl &lt;&lt;</span>
<span class="lineNum">    5560 </span><span class="lineNoCov">          0 :                       &quot;    &quot; &lt;&lt; base::consts::kCrashSignals[i].brief &lt;&lt; std::endl &lt;&lt;</span>
<span class="lineNum">    5561 </span><span class="lineNoCov">          0 :                       &quot;    &quot; &lt;&lt; base::consts::kCrashSignals[i].detail;</span>
<span class="lineNum">    5562 </span>            :                 }
<span class="lineNum">    5563 </span><span class="lineNoCov">          0 :             foundReason = true;</span>
<span class="lineNum">    5564 </span>            :         }
<span class="lineNum">    5565 </span>            :     }
<span class="lineNum">    5566 </span><span class="lineNoCov">          0 :     if (!foundReason) {</span>
<span class="lineNum">    5567 </span><span class="lineNoCov">          0 :         ss &lt;&lt; &quot;Application has crashed due to unknown signal [&quot; &lt;&lt; sig &lt;&lt; &quot;]&quot;;</span>
<span class="lineNum">    5568 </span>            :     }
<span class="lineNum">    5569 </span><span class="lineNoCov">          0 :     return ss.str();</span>
<a name="5570"><span class="lineNum">    5570 </span>            : }</a>
<span class="lineNum">    5571 </span>            : /// @brief Logs reason of crash from sig
<span class="lineNum">    5572 </span><span class="lineNoCov">          0 : static void logCrashReason(int sig, bool stackTraceIfAvailable, Level level, const char* logger) {</span>
<span class="lineNum">    5573 </span><span class="lineNoCov">          0 :     std::stringstream ss;</span>
<span class="lineNum">    5574 </span><span class="lineNoCov">          0 :     ss &lt;&lt; &quot;CRASH HANDLED; &quot;;</span>
<span class="lineNum">    5575 </span><span class="lineNoCov">          0 :     ss &lt;&lt; crashReason(sig);</span>
<span class="lineNum">    5576 </span>            : #if ELPP_STACKTRACE
<span class="lineNum">    5577 </span>            :     if (stackTraceIfAvailable) {
<span class="lineNum">    5578 </span>            :         ss &lt;&lt; std::endl &lt;&lt; &quot;    ======= Backtrace: =========&quot; &lt;&lt; std::endl &lt;&lt; base::debug::StackTrace();
<span class="lineNum">    5579 </span>            :     }
<span class="lineNum">    5580 </span>            : #else
<span class="lineNum">    5581 </span>            :     ELPP_UNUSED(stackTraceIfAvailable);
<span class="lineNum">    5582 </span>            : #endif  // ELPP_STACKTRACE
<a name="5583"><span class="lineNum">    5583 </span><span class="lineNoCov">          0 :     ELPP_WRITE_LOG(el::base::Writer, level, base::DispatchAction::NormalLog, logger) &lt;&lt; ss.str();</span></a>
<span class="lineNum">    5584 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5585 </span><span class="lineNoCov">          0 : static inline void crashAbort(int sig) {</span>
<span class="lineNum">    5586 </span><span class="lineNoCov">          0 :     base::utils::abort(sig);</span>
<span class="lineNum">    5587 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5588 </span>            : /// @brief Default application crash handler
<a name="5589"><span class="lineNum">    5589 </span>            : ///</a>
<span class="lineNum">    5590 </span>            : /// @detail This function writes log using 'default' logger, prints stack trace for GCC based compilers and aborts program.
<span class="lineNum">    5591 </span><span class="lineNoCov">          0 : static inline void defaultCrashHandler(int sig) {</span>
<span class="lineNum">    5592 </span><span class="lineNoCov">          0 :     base::debug::logCrashReason(sig, true, Level::Fatal, base::consts::kDefaultLoggerId);</span>
<span class="lineNum">    5593 </span><span class="lineNoCov">          0 :     base::debug::crashAbort(sig);</span>
<span class="lineNum">    5594 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5595 </span>            : /// @brief Handles unexpected crashes
<span class="lineNum">    5596 </span>            : class CrashHandler : base::NoCopy {
<span class="lineNum">    5597 </span>            : public:
<a name="5598"><span class="lineNum">    5598 </span>            :     typedef void (*Handler)(int);</a>
<span class="lineNum">    5599 </span>            : 
<span class="lineNum">    5600 </span><span class="lineCov">          2 :     explicit CrashHandler(bool useDefault) {</span>
<span class="lineNum">    5601 </span><span class="lineCov">          2 :         if (useDefault) {</span>
<span class="lineNum">    5602 </span><span class="lineCov">          2 :             setHandler(defaultCrashHandler);</span>
<span class="lineNum">    5603 </span>            :         }
<span class="lineNum">    5604 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    5605 </span>            :     explicit CrashHandler(const Handler&amp; cHandler) {
<a name="5606"><span class="lineNum">    5606 </span>            :         setHandler(cHandler);</a>
<span class="lineNum">    5607 </span>            :     }
<span class="lineNum">    5608 </span><span class="lineCov">          2 :     void setHandler(const Handler&amp; cHandler) {</span>
<span class="lineNum">    5609 </span><span class="lineCov">          2 :         m_handler = cHandler;</span>
<span class="lineNum">    5610 </span>            : #if defined(ELPP_HANDLE_SIGABRT)
<span class="lineNum">    5611 </span>            :             int i = 0;  // SIGABRT is at base::consts::kCrashSignals[0]
<span class="lineNum">    5612 </span>            : #else
<span class="lineNum">    5613 </span><span class="lineCov">          2 :             int i = 1;</span>
<span class="lineNum">    5614 </span>            : #endif  // defined(ELPP_HANDLE_SIGABRT)
<span class="lineNum">    5615 </span><span class="lineCov">         10 :         for (; i &lt; base::consts::kCrashSignalsCount; ++i) {</span>
<span class="lineNum">    5616 </span><span class="lineCov">          8 :             m_handler = signal(base::consts::kCrashSignals[i].numb, cHandler);</span>
<span class="lineNum">    5617 </span>            :         }
<span class="lineNum">    5618 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    5619 </span>            : 
<span class="lineNum">    5620 </span>            : private:
<span class="lineNum">    5621 </span>            :     Handler m_handler;
<span class="lineNum">    5622 </span>            : };
<span class="lineNum">    5623 </span>            : }  // namespace debug
<span class="lineNum">    5624 </span>            : }  // namespace base
<span class="lineNum">    5625 </span>            : extern base::debug::CrashHandler elCrashHandler;
<span class="lineNum">    5626 </span>            : #define MAKE_LOGGABLE(ClassType, ClassInstance, OutputStreamInstance) \
<span class="lineNum">    5627 </span>            :     el::base::type::ostream_t&amp; operator&lt;&lt;(el::base::type::ostream_t&amp; OutputStreamInstance, const ClassType&amp; ClassInstance)
<span class="lineNum">    5628 </span>            : /// @brief Initializes syslog with process ID, options and facility. calls closelog() on d'tor
<span class="lineNum">    5629 </span>            : class SysLogInitializer {
<span class="lineNum">    5630 </span>            : public:
<span class="lineNum">    5631 </span>            :     SysLogInitializer(const char* processIdent, int options = 0, int facility = 0) {
<span class="lineNum">    5632 </span>            : #if defined(ELPP_SYSLOG)
<span class="lineNum">    5633 </span>            :         openlog(processIdent, options, facility);
<span class="lineNum">    5634 </span>            : #else
<span class="lineNum">    5635 </span>            :         ELPP_UNUSED(processIdent);
<span class="lineNum">    5636 </span>            :         ELPP_UNUSED(options);
<span class="lineNum">    5637 </span>            :         ELPP_UNUSED(facility);
<span class="lineNum">    5638 </span>            : #endif  // defined(ELPP_SYSLOG)
<span class="lineNum">    5639 </span>            :     }
<span class="lineNum">    5640 </span>            :     virtual ~SysLogInitializer(void) {
<span class="lineNum">    5641 </span>            : #if defined(ELPP_SYSLOG)
<span class="lineNum">    5642 </span>            :         closelog();
<span class="lineNum">    5643 </span>            : #endif  // defined(ELPP_SYSLOG)
<span class="lineNum">    5644 </span>            :     }
<span class="lineNum">    5645 </span>            : };
<span class="lineNum">    5646 </span>            : #define ELPP_INITIALIZE_SYSLOG(id, opt, fac) el::SysLogInitializer elSyslogInit(id, opt, fac)
<span class="lineNum">    5647 </span>            : /// @brief Static helpers for developers
<span class="lineNum">    5648 </span>            : class Helpers : base::StaticClass {
<span class="lineNum">    5649 </span>            : public:
<span class="lineNum">    5650 </span>            :     /// @brief Shares logging repository (base::Storage)
<span class="lineNum">    5651 </span>            :     static inline void setStorage(base::type::StoragePointer storage) {
<span class="lineNum">    5652 </span>            :         ELPP = storage;
<span class="lineNum">    5653 </span>            :     }
<span class="lineNum">    5654 </span>            :     /// @return Main storage repository
<span class="lineNum">    5655 </span>            :     static inline base::type::StoragePointer storage() {
<span class="lineNum">    5656 </span>            :         return ELPP;
<span class="lineNum">    5657 </span>            :     }
<span class="lineNum">    5658 </span>            :     /// @brief Sets application arguments and figures out whats active for logging and whats not.
<span class="lineNum">    5659 </span>            :     static inline void setArgs(int argc, char** argv) {
<span class="lineNum">    5660 </span>            :         ELPP-&gt;setApplicationArguments(argc, argv);
<span class="lineNum">    5661 </span>            :     }
<span class="lineNum">    5662 </span>            :     /// @copydoc setArgs(int argc, char** argv)
<span class="lineNum">    5663 </span>            :     static inline void setArgs(int argc, const char** argv) {
<span class="lineNum">    5664 </span>            :         ELPP-&gt;setApplicationArguments(argc, const_cast&lt;char**&gt;(argv));
<span class="lineNum">    5665 </span>            :     }
<span class="lineNum">    5666 </span>            :     /// @brief Overrides default crash handler and installs custom handler.
<span class="lineNum">    5667 </span>            :     /// @param crashHandler A functor with no return type that takes single int argument.
<span class="lineNum">    5668 </span>            :     ///        Handler is a typedef with specification: void (*Handler)(int)
<span class="lineNum">    5669 </span>            :     static inline void setCrashHandler(const el::base::debug::CrashHandler::Handler&amp; crashHandler) {
<span class="lineNum">    5670 </span>            :         el::elCrashHandler.setHandler(crashHandler);
<span class="lineNum">    5671 </span>            :     }
<span class="lineNum">    5672 </span>            :     /// @brief Abort due to crash with signal in parameter
<span class="lineNum">    5673 </span>            :     /// @param sig Crash signal
<span class="lineNum">    5674 </span>            :     static inline void crashAbort(int sig, const char* sourceFile = &quot;&quot;, unsigned int long line = 0) {
<span class="lineNum">    5675 </span>            :         std::stringstream ss;
<span class="lineNum">    5676 </span>            :         ss &lt;&lt; base::debug::crashReason(sig).c_str();
<span class="lineNum">    5677 </span>            :         ss &lt;&lt; &quot; - [Called el::Helpers::crashAbort(&quot; &lt;&lt; sig &lt;&lt; &quot;)]&quot;;
<span class="lineNum">    5678 </span>            :         if (sourceFile != nullptr &amp;&amp; strlen(sourceFile) &gt; 0) {
<span class="lineNum">    5679 </span>            :             ss &lt;&lt; &quot; - Source: &quot; &lt;&lt; sourceFile;
<span class="lineNum">    5680 </span>            :             if (line &gt; 0)
<span class="lineNum">    5681 </span>            :                 ss &lt;&lt; &quot;:&quot; &lt;&lt; line;
<span class="lineNum">    5682 </span>            :             else
<span class="lineNum">    5683 </span>            :                 ss &lt;&lt; &quot; (line number not specified)&quot;;
<span class="lineNum">    5684 </span>            :         }
<span class="lineNum">    5685 </span>            :         base::utils::abort(sig, ss.str());
<span class="lineNum">    5686 </span>            :     }
<span class="lineNum">    5687 </span>            :     /// @brief Logs reason of crash as per sig
<span class="lineNum">    5688 </span>            :     /// @param sig Crash signal
<span class="lineNum">    5689 </span>            :     /// @param stackTraceIfAvailable Includes stack trace if available
<span class="lineNum">    5690 </span>            :     /// @param level Logging level
<span class="lineNum">    5691 </span>            :     /// @param logger Logger to use for logging
<span class="lineNum">    5692 </span>            :     static inline void logCrashReason(int sig, bool stackTraceIfAvailable = false,
<span class="lineNum">    5693 </span>            :             Level level = Level::Fatal, const char* logger = base::consts::kDefaultLoggerId) {
<span class="lineNum">    5694 </span>            :         el::base::debug::logCrashReason(sig, stackTraceIfAvailable, level, logger);
<span class="lineNum">    5695 </span>            :     }
<span class="lineNum">    5696 </span>            :     /// @brief Installs pre rollout callback, this callback is triggered when log file is about to be rolled out
<span class="lineNum">    5697 </span>            :     ///        (can be useful for backing up)
<span class="lineNum">    5698 </span>            :     static inline void installPreRollOutCallback(const PreRollOutCallback&amp; callback) {
<span class="lineNum">    5699 </span>            :         ELPP-&gt;setPreRollOutCallback(callback);
<span class="lineNum">    5700 </span>            :     }
<span class="lineNum">    5701 </span>            :     /// @brief Uninstalls pre rollout callback
<span class="lineNum">    5702 </span>            :     static inline void uninstallPreRollOutCallback(void) {
<span class="lineNum">    5703 </span>            :         ELPP-&gt;unsetPreRollOutCallback();
<span class="lineNum">    5704 </span>            :     }
<span class="lineNum">    5705 </span>            :     /// @brief Installs post log dispatch callback, this callback is triggered when log is dispatched
<span class="lineNum">    5706 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    5707 </span>            :     static inline bool installLogDispatchCallback(const std::string&amp; id) {
<span class="lineNum">    5708 </span>            :         return ELPP-&gt;installLogDispatchCallback&lt;T&gt;(id);
<span class="lineNum">    5709 </span>            :     }
<span class="lineNum">    5710 </span>            :     /// @brief Uninstalls log dispatch callback
<span class="lineNum">    5711 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    5712 </span>            :     static inline void uninstallLogDispatchCallback(const std::string&amp; id) {
<span class="lineNum">    5713 </span>            :         ELPP-&gt;uninstallLogDispatchCallback&lt;T&gt;(id);
<span class="lineNum">    5714 </span>            :     }
<span class="lineNum">    5715 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    5716 </span>            :     static inline T* logDispatchCallback(const std::string&amp; id) {
<span class="lineNum">    5717 </span>            :         return ELPP-&gt;logDispatchCallback&lt;T&gt;(id);
<span class="lineNum">    5718 </span>            :     }
<span class="lineNum">    5719 </span>            :     /// @brief Installs post performance tracking callback, this callback is triggered when performance tracking is finished
<span class="lineNum">    5720 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    5721 </span>            :     static inline bool installPerformanceTrackingCallback(const std::string&amp; id) {
<span class="lineNum">    5722 </span>            :         return ELPP-&gt;installPerformanceTrackingCallback&lt;T&gt;(id);
<span class="lineNum">    5723 </span>            :     }
<span class="lineNum">    5724 </span>            :     /// @brief Uninstalls post performance tracking handler
<span class="lineNum">    5725 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    5726 </span>            :     static inline void uninstallPerformanceTrackingCallback(const std::string&amp; id) {
<span class="lineNum">    5727 </span>            :         ELPP-&gt;uninstallPerformanceTrackingCallback&lt;T&gt;(id);
<span class="lineNum">    5728 </span>            :     }
<span class="lineNum">    5729 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    5730 </span>            :     static inline T* performanceTrackingCallback(const std::string&amp; id) {
<span class="lineNum">    5731 </span>            :         return ELPP-&gt;performanceTrackingCallback&lt;T&gt;(id);
<span class="lineNum">    5732 </span>            :     }
<span class="lineNum">    5733 </span>            :     /// @brief Converts template to std::string - useful for loggable classes to log containers within log(std::ostream&amp;) const
<span class="lineNum">    5734 </span>            :     template &lt;typename T&gt;
<span class="lineNum">    5735 </span>            :     static std::string convertTemplateToStdString(const T&amp; templ) {
<span class="lineNum">    5736 </span>            :         el::Logger* logger = 
<span class="lineNum">    5737 </span>            :             ELPP-&gt;registeredLoggers()-&gt;get(el::base::consts::kDefaultLoggerId);
<span class="lineNum">    5738 </span>            :         if (logger == nullptr) {
<span class="lineNum">    5739 </span>            :             return std::string();
<span class="lineNum">    5740 </span>            :         }
<span class="lineNum">    5741 </span>            :         base::MessageBuilder b;
<span class="lineNum">    5742 </span>            :         b.initialize(logger);
<span class="lineNum">    5743 </span>            :         logger-&gt;acquireLock();
<span class="lineNum">    5744 </span>            :         b &lt;&lt; templ;
<span class="lineNum">    5745 </span>            : #if defined(ELPP_UNICODE)
<span class="lineNum">    5746 </span>            :         std::string s = std::string(logger-&gt;stream().str().begin(), logger-&gt;stream().str().end());
<span class="lineNum">    5747 </span>            : #else
<span class="lineNum">    5748 </span>            :         std::string s = logger-&gt;stream().str();
<span class="lineNum">    5749 </span>            : #endif  // defined(ELPP_UNICODE)
<span class="lineNum">    5750 </span>            :         logger-&gt;stream().str(ELPP_LITERAL(&quot;&quot;));
<span class="lineNum">    5751 </span>            :         logger-&gt;releaseLock();
<span class="lineNum">    5752 </span>            :         return s;
<span class="lineNum">    5753 </span>            :     }
<span class="lineNum">    5754 </span>            :     /// @brief Returns command line arguments (pointer) provided to easylogging++
<span class="lineNum">    5755 </span>            :     static inline const el::base::utils::CommandLineArgs* commandLineArgs(void) {
<span class="lineNum">    5756 </span>            :         return ELPP-&gt;commandLineArgs();
<span class="lineNum">    5757 </span>            :     }
<span class="lineNum">    5758 </span>            :     /// @brief Installs user defined format specifier and handler
<span class="lineNum">    5759 </span>            :     static inline void installCustomFormatSpecifier(const CustomFormatSpecifier&amp; customFormatSpecifier) {
<span class="lineNum">    5760 </span>            :         ELPP-&gt;installCustomFormatSpecifier(customFormatSpecifier);
<span class="lineNum">    5761 </span>            :     }
<span class="lineNum">    5762 </span>            :     /// @brief Uninstalls user defined format specifier and handler
<span class="lineNum">    5763 </span>            :     static inline bool uninstallCustomFormatSpecifier(const char* formatSpecifier) {
<span class="lineNum">    5764 </span>            :         return ELPP-&gt;uninstallCustomFormatSpecifier(formatSpecifier);
<span class="lineNum">    5765 </span>            :     }
<span class="lineNum">    5766 </span>            :     /// @brief Returns true if custom format specifier is installed
<span class="lineNum">    5767 </span>            :     static inline bool hasCustomFormatSpecifier(const char* formatSpecifier) {
<span class="lineNum">    5768 </span>            :         return ELPP-&gt;hasCustomFormatSpecifier(formatSpecifier);
<span class="lineNum">    5769 </span>            :     }
<span class="lineNum">    5770 </span>            :     static inline void validateFileRolling(Logger* logger, Level level) {
<span class="lineNum">    5771 </span>            :         if (logger == nullptr) return;
<span class="lineNum">    5772 </span>            :         logger-&gt;m_typedConfigurations-&gt;validateFileRolling(level, ELPP-&gt;preRollOutCallback());
<span class="lineNum">    5773 </span>            :     }
<span class="lineNum">    5774 </span>            : };
<span class="lineNum">    5775 </span>            : /// @brief Static helpers to deal with loggers and their configurations
<span class="lineNum">    5776 </span>            : class Loggers : base::StaticClass {
<span class="lineNum">    5777 </span>            : public:
<span class="lineNum">    5778 </span>            :     /// @brief Gets existing or registers new logger
<span class="lineNum">    5779 </span>            :     static inline Logger* getLogger(const std::string&amp; identity, bool registerIfNotAvailable = true) {
<span class="lineNum">    5780 </span>            :         base::threading::ScopedLock scopedLock(ELPP-&gt;lock());
<span class="lineNum">    5781 </span>            :         return ELPP-&gt;registeredLoggers()-&gt;get(identity, registerIfNotAvailable);
<span class="lineNum">    5782 </span>            :     }
<span class="lineNum">    5783 </span>            :     /// @brief Unregisters logger - use it only when you know what you are doing, you may unregister
<span class="lineNum">    5784 </span>            :     ///        loggers initialized / used by third-party libs.
<span class="lineNum">    5785 </span>            :     static inline bool unregisterLogger(const std::string&amp; identity) {
<span class="lineNum">    5786 </span>            :         base::threading::ScopedLock scopedLock(ELPP-&gt;lock());
<span class="lineNum">    5787 </span>            :         return ELPP-&gt;registeredLoggers()-&gt;remove(identity);
<span class="lineNum">    5788 </span>            :     }
<span class="lineNum">    5789 </span>            :     /// @brief Whether or not logger with id is registered
<span class="lineNum">    5790 </span>            :     static inline bool hasLogger(const std::string&amp; identity) {
<span class="lineNum">    5791 </span>            :         base::threading::ScopedLock scopedLock(ELPP-&gt;lock());
<span class="lineNum">    5792 </span>            :         return ELPP-&gt;registeredLoggers()-&gt;has(identity);
<a name="5793"><span class="lineNum">    5793 </span>            :     }</a>
<span class="lineNum">    5794 </span>            :     /// @brief Reconfigures specified logger with new configurations
<span class="lineNum">    5795 </span><span class="lineCov">         24 :     static inline Logger* reconfigureLogger(Logger* logger, const Configurations&amp; configurations) {</span>
<span class="lineNum">    5796 </span><span class="lineCov">         24 :         if (!logger) return nullptr;</span>
<span class="lineNum">    5797 </span><span class="lineCov">         24 :         logger-&gt;configure(configurations);</span>
<span class="lineNum">    5798 </span><span class="lineCov">         24 :         return logger;</span>
<span class="lineNum">    5799 </span>            :     }
<span class="lineNum">    5800 </span>            :     /// @brief Reconfigures logger with new configurations after looking it up using identity
<span class="lineNum">    5801 </span>            :     static inline Logger* reconfigureLogger(const std::string&amp; identity, const Configurations&amp; configurations) {
<span class="lineNum">    5802 </span>            :         return Loggers::reconfigureLogger(Loggers::getLogger(identity), configurations);
<span class="lineNum">    5803 </span>            :     }
<span class="lineNum">    5804 </span>            :     /// @brief Reconfigures logger's single configuration
<span class="lineNum">    5805 </span>            :     static inline Logger* reconfigureLogger(const std::string&amp; identity, ConfigurationType configurationType,
<span class="lineNum">    5806 </span>            :             const std::string&amp; value) {
<span class="lineNum">    5807 </span>            :         Logger* logger = Loggers::getLogger(identity);
<span class="lineNum">    5808 </span>            :         if (logger == nullptr) {
<span class="lineNum">    5809 </span>            :             return nullptr;
<span class="lineNum">    5810 </span>            :         }
<span class="lineNum">    5811 </span>            :         logger-&gt;configurations()-&gt;set(Level::Global, configurationType, value);
<span class="lineNum">    5812 </span>            :         logger-&gt;reconfigure();
<span class="lineNum">    5813 </span>            :         return logger;
<a name="5814"><span class="lineNum">    5814 </span>            :     }</a>
<span class="lineNum">    5815 </span>            :     /// @brief Reconfigures all the existing loggers with new configurations
<span class="lineNum">    5816 </span><span class="lineCov">         12 :     static inline void reconfigureAllLoggers(const Configurations&amp; configurations) {</span>
<span class="lineNum">    5817 </span><span class="lineCov">        108 :         for (base::RegisteredLoggers::iterator it = ELPP-&gt;registeredLoggers()-&gt;begin();</span>
<span class="lineNum">    5818 </span><span class="lineCov">         72 :                 it != ELPP-&gt;registeredLoggers()-&gt;end(); ++it) {</span>
<span class="lineNum">    5819 </span><span class="lineCov">         24 :             Loggers::reconfigureLogger(it-&gt;second, configurations);</span>
<span class="lineNum">    5820 </span>            :         }
<span class="lineNum">    5821 </span><span class="lineCov">         12 :     }</span>
<span class="lineNum">    5822 </span>            :     /// @brief Reconfigures single configuration for all the loggers
<span class="lineNum">    5823 </span>            :     static inline void reconfigureAllLoggers(ConfigurationType configurationType, const std::string&amp; value) {
<span class="lineNum">    5824 </span>            :         reconfigureAllLoggers(Level::Global, configurationType, value);
<span class="lineNum">    5825 </span>            :     }
<span class="lineNum">    5826 </span>            :     /// @brief Reconfigures single configuration for all the loggers for specified level
<span class="lineNum">    5827 </span>            :     static inline void reconfigureAllLoggers(Level level, ConfigurationType configurationType, 
<span class="lineNum">    5828 </span>            :             const std::string&amp; value) {
<span class="lineNum">    5829 </span>            :         for (base::RegisteredLoggers::iterator it = ELPP-&gt;registeredLoggers()-&gt;begin();
<span class="lineNum">    5830 </span>            :                 it != ELPP-&gt;registeredLoggers()-&gt;end(); ++it) {
<span class="lineNum">    5831 </span>            :             Logger* logger = it-&gt;second;
<span class="lineNum">    5832 </span>            :             logger-&gt;configurations()-&gt;set(level, configurationType, value);
<span class="lineNum">    5833 </span>            :             logger-&gt;reconfigure();
<span class="lineNum">    5834 </span>            :         }
<span class="lineNum">    5835 </span>            :     }
<span class="lineNum">    5836 </span>            :     /// @brief Sets default configurations. This configuration is used for future (and conditionally for existing) loggers
<span class="lineNum">    5837 </span>            :     static inline void setDefaultConfigurations(const Configurations&amp; configurations, bool reconfigureExistingLoggers = false) {
<span class="lineNum">    5838 </span>            :         ELPP-&gt;registeredLoggers()-&gt;setDefaultConfigurations(configurations);
<span class="lineNum">    5839 </span>            :         if (reconfigureExistingLoggers) {
<span class="lineNum">    5840 </span>            :             Loggers::reconfigureAllLoggers(configurations);
<span class="lineNum">    5841 </span>            :         }
<span class="lineNum">    5842 </span>            :     }
<span class="lineNum">    5843 </span>            :     /// @brief Returns current default
<span class="lineNum">    5844 </span>            :     static inline const Configurations* defaultConfigurations(void) {
<span class="lineNum">    5845 </span>            :         return ELPP-&gt;registeredLoggers()-&gt;defaultConfigurations();
<span class="lineNum">    5846 </span>            :     }
<span class="lineNum">    5847 </span>            :     /// @brief Returns log stream reference pointer if needed by user
<span class="lineNum">    5848 </span>            :     static inline const base::LogStreamsReferenceMap* logStreamsReference(void) {
<span class="lineNum">    5849 </span>            :         return ELPP-&gt;registeredLoggers()-&gt;logStreamsReference();
<span class="lineNum">    5850 </span>            :     }
<span class="lineNum">    5851 </span>            :     /// @brief Default typed configuration based on existing defaultConf
<span class="lineNum">    5852 </span>            :     static base::TypedConfigurations defaultTypedConfigurations(void) {
<span class="lineNum">    5853 </span>            :         return base::TypedConfigurations(
<span class="lineNum">    5854 </span>            :             ELPP-&gt;registeredLoggers()-&gt;defaultConfigurations(),
<span class="lineNum">    5855 </span>            :             ELPP-&gt;registeredLoggers()-&gt;logStreamsReference());
<span class="lineNum">    5856 </span>            :     }
<span class="lineNum">    5857 </span>            :     /// @brief Populates all logger IDs in current repository.
<span class="lineNum">    5858 </span>            :     /// @param [out] targetList List of fill up.
<span class="lineNum">    5859 </span>            :     static inline std::vector&lt;std::string&gt;* populateAllLoggerIds(std::vector&lt;std::string&gt;* targetList) {
<span class="lineNum">    5860 </span>            :         targetList-&gt;clear();
<span class="lineNum">    5861 </span>            :         for (base::RegisteredLoggers::iterator it = ELPP-&gt;registeredLoggers()-&gt;list().begin();
<span class="lineNum">    5862 </span>            :                 it != ELPP-&gt;registeredLoggers()-&gt;list().end(); ++it) {
<span class="lineNum">    5863 </span>            :             targetList-&gt;push_back(it-&gt;first);
<span class="lineNum">    5864 </span>            :         }
<span class="lineNum">    5865 </span>            :         return targetList;
<span class="lineNum">    5866 </span>            :     }
<span class="lineNum">    5867 </span>            :     /// @brief Sets configurations from global configuration file.
<span class="lineNum">    5868 </span>            :     static void configureFromGlobal(const char* globalConfigurationFilePath) {
<span class="lineNum">    5869 </span>            :         std::ifstream gcfStream(globalConfigurationFilePath, std::ifstream::in);
<span class="lineNum">    5870 </span>            :         ELPP_ASSERT(gcfStream.is_open(), &quot;Unable to open global configuration file [&quot; &lt;&lt; globalConfigurationFilePath 
<span class="lineNum">    5871 </span>            :             &lt;&lt; &quot;] for parsing.&quot;);
<span class="lineNum">    5872 </span>            :         std::string line = std::string();
<span class="lineNum">    5873 </span>            :         std::stringstream ss;
<span class="lineNum">    5874 </span>            :         Logger* logger = nullptr;
<span class="lineNum">    5875 </span>            :         auto configure = [&amp;](void) {
<span class="lineNum">    5876 </span>            :             ELPP_INTERNAL_INFO(8, &quot;Configuring logger: '&quot; &lt;&lt; logger-&gt;id() &lt;&lt; &quot;' with configurations \n&quot; &lt;&lt; ss.str() 
<span class="lineNum">    5877 </span>            :                 &lt;&lt; &quot;\n--------------&quot;);
<span class="lineNum">    5878 </span>            :             Configurations c;
<span class="lineNum">    5879 </span>            :             c.parseFromText(ss.str());
<span class="lineNum">    5880 </span>            :             logger-&gt;configure(c);
<span class="lineNum">    5881 </span>            :         };
<span class="lineNum">    5882 </span>            :         while (gcfStream.good()) {
<span class="lineNum">    5883 </span>            :            std::getline(gcfStream, line);
<span class="lineNum">    5884 </span>            :            ELPP_INTERNAL_INFO(1, &quot;Parsing line: &quot; &lt;&lt; line);
<span class="lineNum">    5885 </span>            :            base::utils::Str::trim(line);
<span class="lineNum">    5886 </span>            :            if (Configurations::Parser::isComment(line)) continue;
<span class="lineNum">    5887 </span>            :            Configurations::Parser::ignoreComments(&amp;line);
<span class="lineNum">    5888 </span>            :            base::utils::Str::trim(line);
<span class="lineNum">    5889 </span>            :            if (line.size() &gt; 2 &amp;&amp; base::utils::Str::startsWith(line, std::string(base::consts::kConfigurationLoggerId))) {
<span class="lineNum">    5890 </span>            :                if (!ss.str().empty() &amp;&amp; logger != nullptr) {
<span class="lineNum">    5891 </span>            :                    configure();
<span class="lineNum">    5892 </span>            :                }
<span class="lineNum">    5893 </span>            :                ss.str(std::string(&quot;&quot;));
<span class="lineNum">    5894 </span>            :                line = line.substr(2);
<span class="lineNum">    5895 </span>            :                base::utils::Str::trim(line);
<span class="lineNum">    5896 </span>            :                if (line.size() &gt; 1) {
<span class="lineNum">    5897 </span>            :                    ELPP_INTERNAL_INFO(1, &quot;Getting logger: '&quot; &lt;&lt; line &lt;&lt; &quot;'&quot;);
<span class="lineNum">    5898 </span>            :                    logger = getLogger(line);
<span class="lineNum">    5899 </span>            :                }
<span class="lineNum">    5900 </span>            :             } else {
<span class="lineNum">    5901 </span>            :                ss &lt;&lt; line &lt;&lt; &quot;\n&quot;;
<span class="lineNum">    5902 </span>            :             }
<span class="lineNum">    5903 </span>            :         }
<span class="lineNum">    5904 </span>            :         if (!ss.str().empty() &amp;&amp; logger != nullptr) {
<span class="lineNum">    5905 </span>            :             configure();
<span class="lineNum">    5906 </span>            :         }
<span class="lineNum">    5907 </span>            :     }
<span class="lineNum">    5908 </span>            :     /// @brief Configures loggers using command line arg. Ensure you have already set command line args, 
<span class="lineNum">    5909 </span>            :     /// @return False if invalid argument or argument with no value provided, true if attempted to configure logger.
<span class="lineNum">    5910 </span>            :     ///         If true is returned that does not mean it has been configured successfully, it only means that it
<span class="lineNum">    5911 </span>            :     ///         has attempeted to configure logger using configuration file provided in argument
<span class="lineNum">    5912 </span>            :     static inline bool configureFromArg(const char* argKey) {
<span class="lineNum">    5913 </span>            : #if defined(ELPP_DISABLE_CONFIGURATION_FROM_PROGRAM_ARGS)
<span class="lineNum">    5914 </span>            :         ELPP_UNUSED(argKey);
<span class="lineNum">    5915 </span>            : #else
<span class="lineNum">    5916 </span>            :         if (!Helpers::commandLineArgs()-&gt;hasParamWithValue(argKey)) {
<span class="lineNum">    5917 </span>            :             return false;
<span class="lineNum">    5918 </span>            :         }
<span class="lineNum">    5919 </span>            :         configureFromGlobal(Helpers::commandLineArgs()-&gt;getParamValue(argKey));
<span class="lineNum">    5920 </span>            : #endif  // defined(ELPP_DISABLE_CONFIGURATION_FROM_PROGRAM_ARGS)
<span class="lineNum">    5921 </span>            :         return true;
<span class="lineNum">    5922 </span>            :     }
<span class="lineNum">    5923 </span>            :     /// @brief Flushes all loggers for all levels - Be careful if you dont know how many loggers are registered
<span class="lineNum">    5924 </span>            :     static inline void flushAll(void) {
<span class="lineNum">    5925 </span>            :         ELPP-&gt;registeredLoggers()-&gt;flushAll();
<a name="5926"><span class="lineNum">    5926 </span>            :     }</a>
<span class="lineNum">    5927 </span>            :     /// @brief Adds logging flag used internally.
<span class="lineNum">    5928 </span><span class="lineCov">         12 :     static inline void addFlag(LoggingFlag flag) {</span>
<span class="lineNum">    5929 </span><span class="lineCov">         12 :         ELPP-&gt;addFlag(flag);</span>
<span class="lineNum">    5930 </span><span class="lineCov">         12 :     }</span>
<span class="lineNum">    5931 </span>            :     /// @brief Removes logging flag used internally.
<span class="lineNum">    5932 </span>            :     static inline void removeFlag(LoggingFlag flag) {
<span class="lineNum">    5933 </span>            :         ELPP-&gt;removeFlag(flag);
<span class="lineNum">    5934 </span>            :     }
<span class="lineNum">    5935 </span>            :     /// @brief Determines whether or not certain flag is active
<span class="lineNum">    5936 </span>            :     static inline bool hasFlag(LoggingFlag flag) {
<span class="lineNum">    5937 </span>            :         return ELPP-&gt;hasFlag(flag);
<span class="lineNum">    5938 </span>            :     }
<span class="lineNum">    5939 </span>            :     /// @brief Adds flag and removes it when scope goes out
<span class="lineNum">    5940 </span>            :     class ScopedAddFlag {
<span class="lineNum">    5941 </span>            :     public:
<span class="lineNum">    5942 </span>            :         ScopedAddFlag(LoggingFlag flag) : m_flag(flag) { Loggers::addFlag(m_flag); }
<span class="lineNum">    5943 </span>            :         ~ScopedAddFlag(void) { Loggers::removeFlag(m_flag); }
<span class="lineNum">    5944 </span>            :     private:
<span class="lineNum">    5945 </span>            :         LoggingFlag m_flag;
<span class="lineNum">    5946 </span>            :     };
<span class="lineNum">    5947 </span>            :     /// @brief Removes flag and add it when scope goes out
<span class="lineNum">    5948 </span>            :     class ScopedRemoveFlag {
<span class="lineNum">    5949 </span>            :     public:
<span class="lineNum">    5950 </span>            :         ScopedRemoveFlag(LoggingFlag flag) : m_flag(flag) { Loggers::removeFlag(m_flag); }
<span class="lineNum">    5951 </span>            :         ~ScopedRemoveFlag(void) { Loggers::addFlag(m_flag); }
<span class="lineNum">    5952 </span>            :     private:
<span class="lineNum">    5953 </span>            :         LoggingFlag m_flag;
<span class="lineNum">    5954 </span>            :     };
<span class="lineNum">    5955 </span>            :     /// @brief Sets hierarchy for logging. Needs to enable logging flag (HierarchicalLogging)
<span class="lineNum">    5956 </span>            :     static inline void setLoggingLevel(Level level) {
<span class="lineNum">    5957 </span>            :         ELPP-&gt;setLoggingLevel(level);
<span class="lineNum">    5958 </span>            :     }
<span class="lineNum">    5959 </span>            :     /// @brief Sets verbose level on the fly
<span class="lineNum">    5960 </span>            :     static inline void setVerboseLevel(base::type::VerboseLevel level) {
<span class="lineNum">    5961 </span>            :         ELPP-&gt;vRegistry()-&gt;setLevel(level);
<span class="lineNum">    5962 </span>            :     }
<span class="lineNum">    5963 </span>            :     /// @brief Gets current verbose level
<span class="lineNum">    5964 </span>            :     static inline base::type::VerboseLevel verboseLevel(void) {
<span class="lineNum">    5965 </span>            :         return ELPP-&gt;vRegistry()-&gt;level();
<span class="lineNum">    5966 </span>            :     }
<span class="lineNum">    5967 </span>            :         /// @brief Sets vmodules as specified (on the fly)
<span class="lineNum">    5968 </span>            :     static inline void setVModules(const char* modules) {
<span class="lineNum">    5969 </span>            :         if (ELPP-&gt;vRegistry()-&gt;vModulesEnabled()) {
<span class="lineNum">    5970 </span>            :             ELPP-&gt;vRegistry()-&gt;setModules(modules);
<span class="lineNum">    5971 </span>            :         }
<span class="lineNum">    5972 </span>            :     }
<span class="lineNum">    5973 </span>            :         /// @brief Clears vmodules
<span class="lineNum">    5974 </span>            :     static inline void clearVModules(void) {
<span class="lineNum">    5975 </span>            :         ELPP-&gt;vRegistry()-&gt;clearModules();
<span class="lineNum">    5976 </span>            :     }
<span class="lineNum">    5977 </span>            : };
<span class="lineNum">    5978 </span>            : class VersionInfo : base::StaticClass {
<span class="lineNum">    5979 </span>            : public:
<span class="lineNum">    5980 </span>            :     /// @brief Current version number
<span class="lineNum">    5981 </span>            :     static inline const std::string version(void) { return std::string(&quot;9.80&quot;); }
<span class="lineNum">    5982 </span>            :     /// @brief Release date of current version
<span class="lineNum">    5983 </span>            :     static inline const std::string releaseDate(void) { return std::string(&quot;08-01-2015 0850hrs&quot;); }
<span class="lineNum">    5984 </span>            : };
<span class="lineNum">    5985 </span>            : }  // namespace el
<span class="lineNum">    5986 </span>            : #undef VLOG_IS_ON
<span class="lineNum">    5987 </span>            : /// @brief Determines whether verbose logging is on for specified level current file.
<span class="lineNum">    5988 </span>            : #define VLOG_IS_ON(verboseLevel) (ELPP-&gt;vRegistry()-&gt;allowed(verboseLevel, __FILE__))
<span class="lineNum">    5989 </span>            : #undef TIMED_BLOCK
<span class="lineNum">    5990 </span>            : #undef TIMED_SCOPE
<span class="lineNum">    5991 </span>            : #undef TIMED_FUNC
<span class="lineNum">    5992 </span>            : #undef ELPP_MIN_UNIT
<span class="lineNum">    5993 </span>            : #if defined(ELPP_PERFORMANCE_MICROSECONDS)
<span class="lineNum">    5994 </span>            : #   define ELPP_MIN_UNIT el::base::TimestampUnit::Microsecond
<span class="lineNum">    5995 </span>            : #else
<span class="lineNum">    5996 </span>            : #   define ELPP_MIN_UNIT el::base::TimestampUnit::Millisecond
<span class="lineNum">    5997 </span>            : #endif  // (defined(ELPP_PERFORMANCE_MICROSECONDS))
<span class="lineNum">    5998 </span>            : /// @brief Performance tracked scope. Performance gets written when goes out of scope using
<span class="lineNum">    5999 </span>            : ///        'performance' logger.
<span class="lineNum">    6000 </span>            : ///
<span class="lineNum">    6001 </span>            : /// @detail Please note in order to check the performance at a certain time you can use obj.checkpoint();
<span class="lineNum">    6002 </span>            : /// @see el::base::PerformanceTracker
<span class="lineNum">    6003 </span>            : /// @see el::base::PerformanceTracker::checkpoint
<span class="lineNum">    6004 </span>            : // Note: Do not surround this definition with null macro because of obj instance
<span class="lineNum">    6005 </span>            : #define TIMED_SCOPE(obj, blockname) el::base::PerformanceTracker obj(blockname, ELPP_MIN_UNIT)
<span class="lineNum">    6006 </span>            : #define TIMED_BLOCK(obj, blockName) for (struct { int i; el::base::PerformanceTracker timer; } obj = { 0, \
<span class="lineNum">    6007 </span>            :     el::base::PerformanceTracker(blockName, ELPP_MIN_UNIT) }; obj.i &lt; 1; ++obj.i)
<span class="lineNum">    6008 </span>            : /// @brief Performance tracked function. Performance gets written when goes out of scope using
<span class="lineNum">    6009 </span>            : ///        'performance' logger.
<span class="lineNum">    6010 </span>            : ///
<span class="lineNum">    6011 </span>            : /// @detail Please note in order to check the performance at a certain time you can use obj.checkpoint();
<span class="lineNum">    6012 </span>            : /// @see el::base::PerformanceTracker
<span class="lineNum">    6013 </span>            : /// @see el::base::PerformanceTracker::checkpoint
<span class="lineNum">    6014 </span>            : #define TIMED_FUNC(obj) TIMED_SCOPE(obj, ELPP_FUNC)
<span class="lineNum">    6015 </span>            : #undef PERFORMANCE_CHECKPOINT
<span class="lineNum">    6016 </span>            : #undef PERFORMANCE_CHECKPOINT_WITH_ID
<span class="lineNum">    6017 </span>            : #define PERFORMANCE_CHECKPOINT(obj) obj.checkpoint(std::string(), __FILE__, __LINE__, ELPP_FUNC)
<span class="lineNum">    6018 </span>            : #define PERFORMANCE_CHECKPOINT_WITH_ID(obj, id) obj.checkpoint(id, __FILE__, __LINE__, ELPP_FUNC)
<span class="lineNum">    6019 </span>            : #undef ELPP_COUNTER
<span class="lineNum">    6020 </span>            : #undef ELPP_COUNTER_POS
<span class="lineNum">    6021 </span>            : /// @brief Gets hit counter for file/line
<span class="lineNum">    6022 </span>            : #define ELPP_COUNTER (ELPP-&gt;hitCounters()-&gt;getCounter(__FILE__, __LINE__))
<span class="lineNum">    6023 </span>            : /// @brief Gets hit counter position for file/line, -1 if not registered yet
<span class="lineNum">    6024 </span>            : #define ELPP_COUNTER_POS (ELPP_COUNTER == nullptr ? -1 : ELPP_COUNTER-&gt;hitCounts())
<span class="lineNum">    6025 </span>            : // Undef levels to support LOG(LEVEL)
<span class="lineNum">    6026 </span>            : #undef INFO
<span class="lineNum">    6027 </span>            : #undef WARNING
<span class="lineNum">    6028 </span>            : #undef DEBUG
<span class="lineNum">    6029 </span>            : #undef ERROR
<span class="lineNum">    6030 </span>            : #undef FATAL
<span class="lineNum">    6031 </span>            : #undef TRACE
<span class="lineNum">    6032 </span>            : #undef VERBOSE
<span class="lineNum">    6033 </span>            : // Undef existing
<span class="lineNum">    6034 </span>            : #undef CINFO
<span class="lineNum">    6035 </span>            : #undef CWARNING
<span class="lineNum">    6036 </span>            : #undef CDEBUG
<span class="lineNum">    6037 </span>            : #undef CFATAL
<span class="lineNum">    6038 </span>            : #undef CERROR
<span class="lineNum">    6039 </span>            : #undef CTRACE
<span class="lineNum">    6040 </span>            : #undef CVERBOSE
<span class="lineNum">    6041 </span>            : #undef CINFO_IF
<span class="lineNum">    6042 </span>            : #undef CWARNING_IF
<span class="lineNum">    6043 </span>            : #undef CDEBUG_IF
<span class="lineNum">    6044 </span>            : #undef CERROR_IF
<span class="lineNum">    6045 </span>            : #undef CFATAL_IF
<span class="lineNum">    6046 </span>            : #undef CTRACE_IF
<span class="lineNum">    6047 </span>            : #undef CVERBOSE_IF
<span class="lineNum">    6048 </span>            : #undef CINFO_EVERY_N
<span class="lineNum">    6049 </span>            : #undef CWARNING_EVERY_N
<span class="lineNum">    6050 </span>            : #undef CDEBUG_EVERY_N
<span class="lineNum">    6051 </span>            : #undef CERROR_EVERY_N
<span class="lineNum">    6052 </span>            : #undef CFATAL_EVERY_N
<span class="lineNum">    6053 </span>            : #undef CTRACE_EVERY_N
<span class="lineNum">    6054 </span>            : #undef CVERBOSE_EVERY_N
<span class="lineNum">    6055 </span>            : #undef CINFO_AFTER_N
<span class="lineNum">    6056 </span>            : #undef CWARNING_AFTER_N
<span class="lineNum">    6057 </span>            : #undef CDEBUG_AFTER_N
<span class="lineNum">    6058 </span>            : #undef CERROR_AFTER_N
<span class="lineNum">    6059 </span>            : #undef CFATAL_AFTER_N
<span class="lineNum">    6060 </span>            : #undef CTRACE_AFTER_N
<span class="lineNum">    6061 </span>            : #undef CVERBOSE_AFTER_N
<span class="lineNum">    6062 </span>            : #undef CINFO_N_TIMES
<span class="lineNum">    6063 </span>            : #undef CWARNING_N_TIMES
<span class="lineNum">    6064 </span>            : #undef CDEBUG_N_TIMES
<span class="lineNum">    6065 </span>            : #undef CERROR_N_TIMES
<span class="lineNum">    6066 </span>            : #undef CFATAL_N_TIMES
<span class="lineNum">    6067 </span>            : #undef CTRACE_N_TIMES
<span class="lineNum">    6068 </span>            : #undef CVERBOSE_N_TIMES
<span class="lineNum">    6069 </span>            : // Normal logs
<span class="lineNum">    6070 </span>            : #if ELPP_INFO_LOG
<span class="lineNum">    6071 </span>            : #   define CINFO(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Info, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6072 </span>            : #else
<span class="lineNum">    6073 </span>            : #   define CINFO(writer, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6074 </span>            : #endif  // ELPP_INFO_LOG
<span class="lineNum">    6075 </span>            : #if ELPP_WARNING_LOG
<span class="lineNum">    6076 </span>            : #   define CWARNING(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Warning, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6077 </span>            : #else
<span class="lineNum">    6078 </span>            : #   define CWARNING(writer, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6079 </span>            : #endif  // ELPP_WARNING_LOG
<span class="lineNum">    6080 </span>            : #if ELPP_DEBUG_LOG
<span class="lineNum">    6081 </span>            : #   define CDEBUG(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Debug, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6082 </span>            : #else
<span class="lineNum">    6083 </span>            : #   define CDEBUG(writer, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6084 </span>            : #endif  // ELPP_DEBUG_LOG
<span class="lineNum">    6085 </span>            : #if ELPP_ERROR_LOG
<span class="lineNum">    6086 </span>            : #   define CERROR(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Error, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6087 </span>            : #else
<span class="lineNum">    6088 </span>            : #   define CERROR(writer, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6089 </span>            : #endif  // ELPP_ERROR_LOG
<span class="lineNum">    6090 </span>            : #if ELPP_FATAL_LOG
<span class="lineNum">    6091 </span>            : #   define CFATAL(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Fatal, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6092 </span>            : #else
<span class="lineNum">    6093 </span>            : #   define CFATAL(writer, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6094 </span>            : #endif  // ELPP_FATAL_LOG
<span class="lineNum">    6095 </span>            : #if ELPP_TRACE_LOG
<span class="lineNum">    6096 </span>            : #   define CTRACE(writer, dispatchAction, ...) ELPP_WRITE_LOG(writer, el::Level::Trace, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6097 </span>            : #else
<span class="lineNum">    6098 </span>            : #   define CTRACE(writer, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6099 </span>            : #endif  // ELPP_TRACE_LOG
<span class="lineNum">    6100 </span>            : #if ELPP_VERBOSE_LOG
<span class="lineNum">    6101 </span>            : #   define CVERBOSE(writer, vlevel, dispatchAction, ...) if (VLOG_IS_ON(vlevel)) writer(\
<span class="lineNum">    6102 </span>            :        el::Level::Verbose, __FILE__, __LINE__, ELPP_FUNC, dispatchAction, vlevel).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
<span class="lineNum">    6103 </span>            : #else
<span class="lineNum">    6104 </span>            : #   define CVERBOSE(writer, vlevel, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6105 </span>            : #endif  // ELPP_VERBOSE_LOG
<span class="lineNum">    6106 </span>            : // Conditional logs
<span class="lineNum">    6107 </span>            : #if ELPP_INFO_LOG
<span class="lineNum">    6108 </span>            : #   define CINFO_IF(writer, condition_, dispatchAction, ...) \
<span class="lineNum">    6109 </span>            :         ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Info, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6110 </span>            : #else
<span class="lineNum">    6111 </span>            : #   define CINFO_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6112 </span>            : #endif  // ELPP_INFO_LOG
<span class="lineNum">    6113 </span>            : #if ELPP_WARNING_LOG
<span class="lineNum">    6114 </span>            : #   define CWARNING_IF(writer, condition_, dispatchAction, ...)\
<span class="lineNum">    6115 </span>            :         ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Warning, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6116 </span>            : #else
<span class="lineNum">    6117 </span>            : #   define CWARNING_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6118 </span>            : #endif  // ELPP_WARNING_LOG
<span class="lineNum">    6119 </span>            : #if ELPP_DEBUG_LOG
<span class="lineNum">    6120 </span>            : #   define CDEBUG_IF(writer, condition_, dispatchAction, ...)\
<span class="lineNum">    6121 </span>            :         ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Debug, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6122 </span>            : #else
<span class="lineNum">    6123 </span>            : #   define CDEBUG_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6124 </span>            : #endif  // ELPP_DEBUG_LOG
<span class="lineNum">    6125 </span>            : #if ELPP_ERROR_LOG
<span class="lineNum">    6126 </span>            : #   define CERROR_IF(writer, condition_, dispatchAction, ...)\
<span class="lineNum">    6127 </span>            :         ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Error, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6128 </span>            : #else
<span class="lineNum">    6129 </span>            : #   define CERROR_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6130 </span>            : #endif  // ELPP_ERROR_LOG
<span class="lineNum">    6131 </span>            : #if ELPP_FATAL_LOG
<span class="lineNum">    6132 </span>            : #   define CFATAL_IF(writer, condition_, dispatchAction, ...)\
<span class="lineNum">    6133 </span>            :         ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Fatal, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6134 </span>            : #else
<span class="lineNum">    6135 </span>            : #   define CFATAL_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6136 </span>            : #endif  // ELPP_FATAL_LOG
<span class="lineNum">    6137 </span>            : #if ELPP_TRACE_LOG
<span class="lineNum">    6138 </span>            : #   define CTRACE_IF(writer, condition_, dispatchAction, ...)\
<span class="lineNum">    6139 </span>            :         ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Trace, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6140 </span>            : #else
<span class="lineNum">    6141 </span>            : #   define CTRACE_IF(writer, condition_, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6142 </span>            : #endif  // ELPP_TRACE_LOG
<span class="lineNum">    6143 </span>            : #if ELPP_VERBOSE_LOG
<span class="lineNum">    6144 </span>            : #   define CVERBOSE_IF(writer, condition_, vlevel, dispatchAction, ...) if (VLOG_IS_ON(vlevel) &amp;&amp; (condition_)) writer( \
<span class="lineNum">    6145 </span>            :        el::Level::Verbose, __FILE__, __LINE__, ELPP_FUNC, dispatchAction, vlevel).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
<span class="lineNum">    6146 </span>            : #else
<span class="lineNum">    6147 </span>            : #   define CVERBOSE_IF(writer, condition_, vlevel, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6148 </span>            : #endif  // ELPP_VERBOSE_LOG
<span class="lineNum">    6149 </span>            : // Occasional logs
<span class="lineNum">    6150 </span>            : #if ELPP_INFO_LOG
<span class="lineNum">    6151 </span>            : #   define CINFO_EVERY_N(writer, occasion, dispatchAction, ...)\
<span class="lineNum">    6152 </span>            :         ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Info, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6153 </span>            : #else
<span class="lineNum">    6154 </span>            : #   define CINFO_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6155 </span>            : #endif  // ELPP_INFO_LOG
<span class="lineNum">    6156 </span>            : #if ELPP_WARNING_LOG
<span class="lineNum">    6157 </span>            : #   define CWARNING_EVERY_N(writer, occasion, dispatchAction, ...)\
<span class="lineNum">    6158 </span>            :         ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Warning, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6159 </span>            : #else
<span class="lineNum">    6160 </span>            : #   define CWARNING_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6161 </span>            : #endif  // ELPP_WARNING_LOG
<span class="lineNum">    6162 </span>            : #if ELPP_DEBUG_LOG
<span class="lineNum">    6163 </span>            : #   define CDEBUG_EVERY_N(writer, occasion, dispatchAction, ...)\
<span class="lineNum">    6164 </span>            :         ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Debug, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6165 </span>            : #else
<span class="lineNum">    6166 </span>            : #   define CDEBUG_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6167 </span>            : #endif  // ELPP_DEBUG_LOG
<span class="lineNum">    6168 </span>            : #if ELPP_ERROR_LOG
<span class="lineNum">    6169 </span>            : #   define CERROR_EVERY_N(writer, occasion, dispatchAction, ...)\
<span class="lineNum">    6170 </span>            :         ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Error, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6171 </span>            : #else
<span class="lineNum">    6172 </span>            : #   define CERROR_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6173 </span>            : #endif  // ELPP_ERROR_LOG
<span class="lineNum">    6174 </span>            : #if ELPP_FATAL_LOG
<span class="lineNum">    6175 </span>            : #   define CFATAL_EVERY_N(writer, occasion, dispatchAction, ...)\
<span class="lineNum">    6176 </span>            :         ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Fatal, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6177 </span>            : #else
<span class="lineNum">    6178 </span>            : #   define CFATAL_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6179 </span>            : #endif  // ELPP_FATAL_LOG
<span class="lineNum">    6180 </span>            : #if ELPP_TRACE_LOG
<span class="lineNum">    6181 </span>            : #   define CTRACE_EVERY_N(writer, occasion, dispatchAction, ...)\
<span class="lineNum">    6182 </span>            :         ELPP_WRITE_LOG_EVERY_N(writer, occasion, el::Level::Trace, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6183 </span>            : #else
<span class="lineNum">    6184 </span>            : #   define CTRACE_EVERY_N(writer, occasion, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6185 </span>            : #endif  // ELPP_TRACE_LOG
<span class="lineNum">    6186 </span>            : #if ELPP_VERBOSE_LOG
<span class="lineNum">    6187 </span>            : #   define CVERBOSE_EVERY_N(writer, occasion, vlevel, dispatchAction, ...)\
<span class="lineNum">    6188 </span>            :         CVERBOSE_IF(writer, ELPP-&gt;validateEveryNCounter(__FILE__, __LINE__, occasion), vlevel, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6189 </span>            : #else
<span class="lineNum">    6190 </span>            : #   define CVERBOSE_EVERY_N(writer, occasion, vlevel, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6191 </span>            : #endif  // ELPP_VERBOSE_LOG
<span class="lineNum">    6192 </span>            : // After N logs
<span class="lineNum">    6193 </span>            : #if ELPP_INFO_LOG
<span class="lineNum">    6194 </span>            : #   define CINFO_AFTER_N(writer, n, dispatchAction, ...)\
<span class="lineNum">    6195 </span>            :         ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Info, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6196 </span>            : #else
<span class="lineNum">    6197 </span>            : #   define CINFO_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6198 </span>            : #endif  // ELPP_INFO_LOG
<span class="lineNum">    6199 </span>            : #if ELPP_WARNING_LOG
<span class="lineNum">    6200 </span>            : #   define CWARNING_AFTER_N(writer, n, dispatchAction, ...)\
<span class="lineNum">    6201 </span>            :         ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Warning, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6202 </span>            : #else
<span class="lineNum">    6203 </span>            : #   define CWARNING_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6204 </span>            : #endif  // ELPP_WARNING_LOG
<span class="lineNum">    6205 </span>            : #if ELPP_DEBUG_LOG
<span class="lineNum">    6206 </span>            : #   define CDEBUG_AFTER_N(writer, n, dispatchAction, ...)\
<span class="lineNum">    6207 </span>            :         ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Debug, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6208 </span>            : #else
<span class="lineNum">    6209 </span>            : #   define CDEBUG_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6210 </span>            : #endif  // ELPP_DEBUG_LOG
<span class="lineNum">    6211 </span>            : #if ELPP_ERROR_LOG
<span class="lineNum">    6212 </span>            : #   define CERROR_AFTER_N(writer, n, dispatchAction, ...)\
<span class="lineNum">    6213 </span>            :         ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Error, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6214 </span>            : #else
<span class="lineNum">    6215 </span>            : #   define CERROR_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6216 </span>            : #endif  // ELPP_ERROR_LOG
<span class="lineNum">    6217 </span>            : #if ELPP_FATAL_LOG
<span class="lineNum">    6218 </span>            : #   define CFATAL_AFTER_N(writer, n, dispatchAction, ...)\
<span class="lineNum">    6219 </span>            :         ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Fatal, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6220 </span>            : #else
<span class="lineNum">    6221 </span>            : #   define CFATAL_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6222 </span>            : #endif  // ELPP_FATAL_LOG
<span class="lineNum">    6223 </span>            : #if ELPP_TRACE_LOG
<span class="lineNum">    6224 </span>            : #   define CTRACE_AFTER_N(writer, n, dispatchAction, ...)\
<span class="lineNum">    6225 </span>            :         ELPP_WRITE_LOG_AFTER_N(writer, n, el::Level::Trace, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6226 </span>            : #else
<span class="lineNum">    6227 </span>            : #   define CTRACE_AFTER_N(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6228 </span>            : #endif  // ELPP_TRACE_LOG
<span class="lineNum">    6229 </span>            : #if ELPP_VERBOSE_LOG
<span class="lineNum">    6230 </span>            : #   define CVERBOSE_AFTER_N(writer, n, vlevel, dispatchAction, ...)\
<span class="lineNum">    6231 </span>            :         CVERBOSE_IF(writer, ELPP-&gt;validateAfterNCounter(__FILE__, __LINE__, n), vlevel, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6232 </span>            : #else
<span class="lineNum">    6233 </span>            : #   define CVERBOSE_AFTER_N(writer, n, vlevel, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6234 </span>            : #endif  // ELPP_VERBOSE_LOG
<span class="lineNum">    6235 </span>            : // N Times logs
<span class="lineNum">    6236 </span>            : #if ELPP_INFO_LOG
<span class="lineNum">    6237 </span>            : #   define CINFO_N_TIMES(writer, n, dispatchAction, ...)\
<span class="lineNum">    6238 </span>            :         ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Info, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6239 </span>            : #else
<span class="lineNum">    6240 </span>            : #   define CINFO_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6241 </span>            : #endif  // ELPP_INFO_LOG
<span class="lineNum">    6242 </span>            : #if ELPP_WARNING_LOG
<span class="lineNum">    6243 </span>            : #   define CWARNING_N_TIMES(writer, n, dispatchAction, ...)\
<span class="lineNum">    6244 </span>            :         ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Warning, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6245 </span>            : #else
<span class="lineNum">    6246 </span>            : #   define CWARNING_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6247 </span>            : #endif  // ELPP_WARNING_LOG
<span class="lineNum">    6248 </span>            : #if ELPP_DEBUG_LOG
<span class="lineNum">    6249 </span>            : #   define CDEBUG_N_TIMES(writer, n, dispatchAction, ...)\
<span class="lineNum">    6250 </span>            :         ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Debug, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6251 </span>            : #else
<span class="lineNum">    6252 </span>            : #   define CDEBUG_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6253 </span>            : #endif  // ELPP_DEBUG_LOG
<span class="lineNum">    6254 </span>            : #if ELPP_ERROR_LOG
<span class="lineNum">    6255 </span>            : #   define CERROR_N_TIMES(writer, n, dispatchAction, ...)\
<span class="lineNum">    6256 </span>            :         ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Error, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6257 </span>            : #else
<span class="lineNum">    6258 </span>            : #   define CERROR_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6259 </span>            : #endif  // ELPP_ERROR_LOG
<span class="lineNum">    6260 </span>            : #if ELPP_FATAL_LOG
<span class="lineNum">    6261 </span>            : #   define CFATAL_N_TIMES(writer, n, dispatchAction, ...)\
<span class="lineNum">    6262 </span>            :         ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Fatal, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6263 </span>            : #else
<span class="lineNum">    6264 </span>            : #   define CFATAL_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6265 </span>            : #endif  // ELPP_FATAL_LOG
<span class="lineNum">    6266 </span>            : #if ELPP_TRACE_LOG
<span class="lineNum">    6267 </span>            : #   define CTRACE_N_TIMES(writer, n, dispatchAction, ...)\
<span class="lineNum">    6268 </span>            :         ELPP_WRITE_LOG_N_TIMES(writer, n, el::Level::Trace, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6269 </span>            : #else
<span class="lineNum">    6270 </span>            : #   define CTRACE_N_TIMES(writer, n, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6271 </span>            : #endif  // ELPP_TRACE_LOG
<span class="lineNum">    6272 </span>            : #if ELPP_VERBOSE_LOG
<span class="lineNum">    6273 </span>            : #   define CVERBOSE_N_TIMES(writer, n, vlevel, dispatchAction, ...)\
<span class="lineNum">    6274 </span>            :         CVERBOSE_IF(writer, ELPP-&gt;validateNTimesCounter(__FILE__, __LINE__, n), vlevel, dispatchAction, __VA_ARGS__)
<span class="lineNum">    6275 </span>            : #else
<span class="lineNum">    6276 </span>            : #   define CVERBOSE_N_TIMES(writer, n, vlevel, dispatchAction, ...) el::base::NullWriter()
<span class="lineNum">    6277 </span>            : #endif  // ELPP_VERBOSE_LOG
<span class="lineNum">    6278 </span>            : //
<span class="lineNum">    6279 </span>            : // Custom Loggers - Requires (level, dispatchAction, loggerId/s)
<span class="lineNum">    6280 </span>            : //
<span class="lineNum">    6281 </span>            : // undef existing
<span class="lineNum">    6282 </span>            : #undef CLOG
<span class="lineNum">    6283 </span>            : #undef CLOG_VERBOSE
<span class="lineNum">    6284 </span>            : #undef CVLOG
<span class="lineNum">    6285 </span>            : #undef CLOG_IF
<span class="lineNum">    6286 </span>            : #undef CLOG_VERBOSE_IF
<span class="lineNum">    6287 </span>            : #undef CVLOG_IF
<span class="lineNum">    6288 </span>            : #undef CLOG_EVERY_N
<span class="lineNum">    6289 </span>            : #undef CVLOG_EVERY_N
<span class="lineNum">    6290 </span>            : #undef CLOG_AFTER_N
<span class="lineNum">    6291 </span>            : #undef CVLOG_AFTER_N
<span class="lineNum">    6292 </span>            : #undef CLOG_N_TIMES
<span class="lineNum">    6293 </span>            : #undef CVLOG_N_TIMES
<span class="lineNum">    6294 </span>            : // Normal logs
<span class="lineNum">    6295 </span>            : #define CLOG(LEVEL, ...)\
<span class="lineNum">    6296 </span>            :     C##LEVEL(el::base::Writer, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6297 </span>            : #define CVLOG(vlevel, ...) CVERBOSE(el::base::Writer, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6298 </span>            : // Conditional logs
<span class="lineNum">    6299 </span>            : #define CLOG_IF(condition, LEVEL, ...)\
<span class="lineNum">    6300 </span>            :     C##LEVEL##_IF(el::base::Writer, condition, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6301 </span>            : #define CVLOG_IF(condition, vlevel, ...)\
<span class="lineNum">    6302 </span>            :     CVERBOSE_IF(el::base::Writer, condition, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6303 </span>            : // Hit counts based logs
<span class="lineNum">    6304 </span>            : #define CLOG_EVERY_N(n, LEVEL, ...)\
<span class="lineNum">    6305 </span>            :     C##LEVEL##_EVERY_N(el::base::Writer, n, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6306 </span>            : #define CVLOG_EVERY_N(n, vlevel, ...)\
<span class="lineNum">    6307 </span>            :     CVERBOSE_EVERY_N(el::base::Writer, n, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6308 </span>            : #define CLOG_AFTER_N(n, LEVEL, ...)\
<span class="lineNum">    6309 </span>            :     C##LEVEL##_AFTER_N(el::base::Writer, n, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6310 </span>            : #define CVLOG_AFTER_N(n, vlevel, ...)\
<span class="lineNum">    6311 </span>            :     CVERBOSE_AFTER_N(el::base::Writer, n, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6312 </span>            : #define CLOG_N_TIMES(n, LEVEL, ...)\
<span class="lineNum">    6313 </span>            :     C##LEVEL##_N_TIMES(el::base::Writer, n, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6314 </span>            : #define CVLOG_N_TIMES(n, vlevel, ...)\
<span class="lineNum">    6315 </span>            :     CVERBOSE_N_TIMES(el::base::Writer, n, vlevel, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6316 </span>            : //
<span class="lineNum">    6317 </span>            : // Default Loggers macro using CLOG(), CLOG_VERBOSE() and CVLOG() macros
<span class="lineNum">    6318 </span>            : //
<span class="lineNum">    6319 </span>            : // undef existing
<span class="lineNum">    6320 </span>            : #undef LOG
<span class="lineNum">    6321 </span>            : #undef VLOG
<span class="lineNum">    6322 </span>            : #undef LOG_IF
<span class="lineNum">    6323 </span>            : #undef VLOG_IF
<span class="lineNum">    6324 </span>            : #undef LOG_EVERY_N
<span class="lineNum">    6325 </span>            : #undef VLOG_EVERY_N
<span class="lineNum">    6326 </span>            : #undef LOG_AFTER_N
<span class="lineNum">    6327 </span>            : #undef VLOG_AFTER_N
<span class="lineNum">    6328 </span>            : #undef LOG_N_TIMES
<span class="lineNum">    6329 </span>            : #undef VLOG_N_TIMES
<span class="lineNum">    6330 </span>            : #undef ELPP_CURR_FILE_LOGGER_ID
<span class="lineNum">    6331 </span>            : #if defined(ELPP_DEFAULT_LOGGER)
<span class="lineNum">    6332 </span>            : #   define ELPP_CURR_FILE_LOGGER_ID ELPP_DEFAULT_LOGGER
<span class="lineNum">    6333 </span>            : #else
<span class="lineNum">    6334 </span>            : #   define ELPP_CURR_FILE_LOGGER_ID el::base::consts::kDefaultLoggerId
<span class="lineNum">    6335 </span>            : #endif
<span class="lineNum">    6336 </span>            : #undef ELPP_TRACE
<span class="lineNum">    6337 </span>            : #define ELPP_TRACE CLOG(TRACE, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6338 </span>            : // Normal logs
<span class="lineNum">    6339 </span>            : #define LOGG(LEVEL) CLOG(LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6340 </span>            : #define VLOG(vlevel) CVLOG(vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6341 </span>            : // Conditional logs
<span class="lineNum">    6342 </span>            : #define LOG_IF(condition, LEVEL) CLOG_IF(condition, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6343 </span>            : #define VLOG_IF(condition, vlevel) CVLOG_IF(condition, vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6344 </span>            : // Hit counts based logs
<span class="lineNum">    6345 </span>            : #define LOG_EVERY_N(n, LEVEL) CLOG_EVERY_N(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6346 </span>            : #define VLOG_EVERY_N(n, vlevel) CVLOG_EVERY_N(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6347 </span>            : #define LOG_AFTER_N(n, LEVEL) CLOG_AFTER_N(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6348 </span>            : #define VLOG_AFTER_N(n, vlevel) CVLOG_AFTER_N(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6349 </span>            : #define LOG_N_TIMES(n, LEVEL) CLOG_N_TIMES(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6350 </span>            : #define VLOG_N_TIMES(n, vlevel) CVLOG_N_TIMES(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6351 </span>            : // Generic PLOG()
<span class="lineNum">    6352 </span>            : #undef CPLOG
<span class="lineNum">    6353 </span>            : #undef CPLOG_IF
<span class="lineNum">    6354 </span>            : #undef PLOG
<span class="lineNum">    6355 </span>            : #undef PLOG_IF
<span class="lineNum">    6356 </span>            : #undef DCPLOG
<span class="lineNum">    6357 </span>            : #undef DCPLOG_IF
<span class="lineNum">    6358 </span>            : #undef DPLOG
<span class="lineNum">    6359 </span>            : #undef DPLOG_IF
<span class="lineNum">    6360 </span>            : #define CPLOG(LEVEL, ...)\
<span class="lineNum">    6361 </span>            :     C##LEVEL(el::base::PErrorWriter, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6362 </span>            : #define CPLOG_IF(condition, LEVEL, ...)\
<span class="lineNum">    6363 </span>            :     C##LEVEL##_IF(el::base::PErrorWriter, condition, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6364 </span>            : #define DCPLOG(LEVEL, ...)\
<span class="lineNum">    6365 </span>            :     if (ELPP_DEBUG_LOG) C##LEVEL(el::base::PErrorWriter, el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6366 </span>            : #define DCPLOG_IF(condition, LEVEL, ...)\
<span class="lineNum">    6367 </span>            :     C##LEVEL##_IF(el::base::PErrorWriter, (ELPP_DEBUG_LOG) &amp;&amp; (condition), el::base::DispatchAction::NormalLog, __VA_ARGS__)
<span class="lineNum">    6368 </span>            : #define PLOG(LEVEL) CPLOG(LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6369 </span>            : #define PLOG_IF(condition, LEVEL) CPLOG_IF(condition, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6370 </span>            : #define DPLOG(LEVEL) DCPLOG(LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6371 </span>            : #define DPLOG_IF(condition, LEVEL) DCPLOG_IF(condition, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6372 </span>            : // Generic SYSLOG()
<span class="lineNum">    6373 </span>            : #undef CSYSLOG
<span class="lineNum">    6374 </span>            : #undef CSYSLOG_IF
<span class="lineNum">    6375 </span>            : #undef CSYSLOG_EVERY_N
<span class="lineNum">    6376 </span>            : #undef CSYSLOG_AFTER_N
<span class="lineNum">    6377 </span>            : #undef CSYSLOG_N_TIMES
<span class="lineNum">    6378 </span>            : #undef SYSLOG
<span class="lineNum">    6379 </span>            : #undef SYSLOG_IF
<span class="lineNum">    6380 </span>            : #undef SYSLOG_EVERY_N
<span class="lineNum">    6381 </span>            : #undef SYSLOG_AFTER_N
<span class="lineNum">    6382 </span>            : #undef SYSLOG_N_TIMES
<span class="lineNum">    6383 </span>            : #undef DCSYSLOG
<span class="lineNum">    6384 </span>            : #undef DCSYSLOG_IF
<span class="lineNum">    6385 </span>            : #undef DCSYSLOG_EVERY_N
<span class="lineNum">    6386 </span>            : #undef DCSYSLOG_AFTER_N
<span class="lineNum">    6387 </span>            : #undef DCSYSLOG_N_TIMES
<span class="lineNum">    6388 </span>            : #undef DSYSLOG
<span class="lineNum">    6389 </span>            : #undef DSYSLOG_IF
<span class="lineNum">    6390 </span>            : #undef DSYSLOG_EVERY_N
<span class="lineNum">    6391 </span>            : #undef DSYSLOG_AFTER_N
<span class="lineNum">    6392 </span>            : #undef DSYSLOG_N_TIMES
<span class="lineNum">    6393 </span>            : #if defined(ELPP_SYSLOG)
<span class="lineNum">    6394 </span>            : #   define CSYSLOG(LEVEL, ...)\
<span class="lineNum">    6395 </span>            :         C##LEVEL(el::base::Writer, el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6396 </span>            : #   define CSYSLOG_IF(condition, LEVEL, ...)\
<span class="lineNum">    6397 </span>            :         C##LEVEL##_IF(el::base::Writer, condition, el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6398 </span>            : #   define CSYSLOG_EVERY_N(n, LEVEL, ...) C##LEVEL##_EVERY_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6399 </span>            : #   define CSYSLOG_AFTER_N(n, LEVEL, ...) C##LEVEL##_AFTER_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6400 </span>            : #   define CSYSLOG_N_TIMES(n, LEVEL, ...) C##LEVEL##_N_TIMES(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6401 </span>            : #   define SYSLOG(LEVEL) CSYSLOG(LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6402 </span>            : #   define SYSLOG_IF(condition, LEVEL) CSYSLOG_IF(condition, LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6403 </span>            : #   define SYSLOG_EVERY_N(n, LEVEL) CSYSLOG_EVERY_N(n, LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6404 </span>            : #   define SYSLOG_AFTER_N(n, LEVEL) CSYSLOG_AFTER_N(n, LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6405 </span>            : #   define SYSLOG_N_TIMES(n, LEVEL) CSYSLOG_N_TIMES(n, LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6406 </span>            : #   define DCSYSLOG(LEVEL, ...) if (ELPP_DEBUG_LOG) C##LEVEL(el::base::Writer, el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6407 </span>            : #   define DCSYSLOG_IF(condition, LEVEL, ...)\
<span class="lineNum">    6408 </span>            :         C##LEVEL##_IF(el::base::Writer, (ELPP_DEBUG_LOG) &amp;&amp; (condition), el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6409 </span>            : #   define DCSYSLOG_EVERY_N(n, LEVEL, ...)\
<span class="lineNum">    6410 </span>            :         if (ELPP_DEBUG_LOG) C##LEVEL##_EVERY_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6411 </span>            : #   define DCSYSLOG_AFTER_N(n, LEVEL, ...)\
<span class="lineNum">    6412 </span>            :         if (ELPP_DEBUG_LOG) C##LEVEL##_AFTER_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6413 </span>            : #   define DCSYSLOG_N_TIMES(n, LEVEL, ...)\
<span class="lineNum">    6414 </span>            :         if (ELPP_DEBUG_LOG) C##LEVEL##_EVERY_N(el::base::Writer, n, el::base::DispatchAction::SysLog, __VA_ARGS__)
<span class="lineNum">    6415 </span>            : #   define DSYSLOG(LEVEL) DCSYSLOG(LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6416 </span>            : #   define DSYSLOG_IF(condition, LEVEL) DCSYSLOG_IF(condition, LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6417 </span>            : #   define DSYSLOG_EVERY_N(n, LEVEL) DCSYSLOG_EVERY_N(n, LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6418 </span>            : #   define DSYSLOG_AFTER_N(n, LEVEL) DCSYSLOG_AFTER_N(n, LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6419 </span>            : #   define DSYSLOG_N_TIMES(n, LEVEL) DCSYSLOG_N_TIMES(n, LEVEL, el::base::consts::kSysLogLoggerId)
<span class="lineNum">    6420 </span>            : #else
<span class="lineNum">    6421 </span>            : #   define CSYSLOG(LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6422 </span>            : #   define CSYSLOG_IF(condition, LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6423 </span>            : #   define CSYSLOG_EVERY_N(n, LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6424 </span>            : #   define CSYSLOG_AFTER_N(n, LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6425 </span>            : #   define CSYSLOG_N_TIMES(n, LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6426 </span>            : #   define SYSLOG(LEVEL) el::base::NullWriter()
<span class="lineNum">    6427 </span>            : #   define SYSLOG_IF(condition, LEVEL) el::base::NullWriter()
<span class="lineNum">    6428 </span>            : #   define SYSLOG_EVERY_N(n, LEVEL) el::base::NullWriter()
<span class="lineNum">    6429 </span>            : #   define SYSLOG_AFTER_N(n, LEVEL) el::base::NullWriter()
<span class="lineNum">    6430 </span>            : #   define SYSLOG_N_TIMES(n, LEVEL) el::base::NullWriter()
<span class="lineNum">    6431 </span>            : #   define DCSYSLOG(LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6432 </span>            : #   define DCSYSLOG_IF(condition, LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6433 </span>            : #   define DCSYSLOG_EVERY_N(n, LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6434 </span>            : #   define DCSYSLOG_AFTER_N(n, LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6435 </span>            : #   define DCSYSLOG_N_TIMES(n, LEVEL, ...) el::base::NullWriter()
<span class="lineNum">    6436 </span>            : #   define DSYSLOG(LEVEL) el::base::NullWriter()
<span class="lineNum">    6437 </span>            : #   define DSYSLOG_IF(condition, LEVEL) el::base::NullWriter()
<span class="lineNum">    6438 </span>            : #   define DSYSLOG_EVERY_N(n, LEVEL) el::base::NullWriter()
<span class="lineNum">    6439 </span>            : #   define DSYSLOG_AFTER_N(n, LEVEL) el::base::NullWriter()
<span class="lineNum">    6440 </span>            : #   define DSYSLOG_N_TIMES(n, LEVEL) el::base::NullWriter()
<span class="lineNum">    6441 </span>            : #endif  // defined(ELPP_SYSLOG)
<span class="lineNum">    6442 </span>            : //
<span class="lineNum">    6443 </span>            : // Custom Debug Only Loggers - Requires (level, loggerId/s)
<span class="lineNum">    6444 </span>            : //
<span class="lineNum">    6445 </span>            : // undef existing
<span class="lineNum">    6446 </span>            : #undef DCLOG
<span class="lineNum">    6447 </span>            : #undef DCVLOG
<span class="lineNum">    6448 </span>            : #undef DCLOG_IF
<span class="lineNum">    6449 </span>            : #undef DCVLOG_IF
<span class="lineNum">    6450 </span>            : #undef DCLOG_EVERY_N
<span class="lineNum">    6451 </span>            : #undef DCVLOG_EVERY_N
<span class="lineNum">    6452 </span>            : #undef DCLOG_AFTER_N
<span class="lineNum">    6453 </span>            : #undef DCVLOG_AFTER_N
<span class="lineNum">    6454 </span>            : #undef DCLOG_N_TIMES
<span class="lineNum">    6455 </span>            : #undef DCVLOG_N_TIMES
<span class="lineNum">    6456 </span>            : // Normal logs
<span class="lineNum">    6457 </span>            : #define DCLOG(LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG(LEVEL, __VA_ARGS__)
<span class="lineNum">    6458 </span>            : #define DCLOG_VERBOSE(vlevel, ...) if (ELPP_DEBUG_LOG) CLOG_VERBOSE(vlevel, __VA_ARGS__)
<span class="lineNum">    6459 </span>            : #define DCVLOG(vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG(vlevel, __VA_ARGS__)
<span class="lineNum">    6460 </span>            : // Conditional logs
<span class="lineNum">    6461 </span>            : #define DCLOG_IF(condition, LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG_IF(condition, LEVEL, __VA_ARGS__)
<span class="lineNum">    6462 </span>            : #define DCVLOG_IF(condition, vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG_IF(condition, vlevel, __VA_ARGS__)
<span class="lineNum">    6463 </span>            : // Hit counts based logs
<span class="lineNum">    6464 </span>            : #define DCLOG_EVERY_N(n, LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG_EVERY_N(n, LEVEL, __VA_ARGS__)
<span class="lineNum">    6465 </span>            : #define DCVLOG_EVERY_N(n, vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG_EVERY_N(n, vlevel, __VA_ARGS__)
<span class="lineNum">    6466 </span>            : #define DCLOG_AFTER_N(n, LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG_AFTER_N(n, LEVEL, __VA_ARGS__)
<span class="lineNum">    6467 </span>            : #define DCVLOG_AFTER_N(n, vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG_AFTER_N(n, vlevel, __VA_ARGS__)
<span class="lineNum">    6468 </span>            : #define DCLOG_N_TIMES(n, LEVEL, ...) if (ELPP_DEBUG_LOG) CLOG_N_TIMES(n, LEVEL, __VA_ARGS__)
<span class="lineNum">    6469 </span>            : #define DCVLOG_N_TIMES(n, vlevel, ...) if (ELPP_DEBUG_LOG) CVLOG_N_TIMES(n, vlevel, __VA_ARGS__)
<span class="lineNum">    6470 </span>            : //
<span class="lineNum">    6471 </span>            : // Default Debug Only Loggers macro using CLOG(), CLOG_VERBOSE() and CVLOG() macros
<span class="lineNum">    6472 </span>            : //
<span class="lineNum">    6473 </span>            : // undef existing
<span class="lineNum">    6474 </span>            : #undef DLOG
<span class="lineNum">    6475 </span>            : #undef DVLOG
<span class="lineNum">    6476 </span>            : #undef DLOG_IF
<span class="lineNum">    6477 </span>            : #undef DVLOG_IF
<span class="lineNum">    6478 </span>            : #undef DLOG_EVERY_N
<span class="lineNum">    6479 </span>            : #undef DVLOG_EVERY_N
<span class="lineNum">    6480 </span>            : #undef DLOG_AFTER_N
<span class="lineNum">    6481 </span>            : #undef DVLOG_AFTER_N
<span class="lineNum">    6482 </span>            : #undef DLOG_N_TIMES
<span class="lineNum">    6483 </span>            : #undef DVLOG_N_TIMES
<span class="lineNum">    6484 </span>            : // Normal logs
<span class="lineNum">    6485 </span>            : #define DLOG(LEVEL) DCLOG(LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6486 </span>            : #define DVLOG(vlevel) DCVLOG(vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6487 </span>            : // Conditional logs
<span class="lineNum">    6488 </span>            : #define DLOG_IF(condition, LEVEL) DCLOG_IF(condition, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6489 </span>            : #define DVLOG_IF(condition, vlevel) DCVLOG_IF(condition, vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6490 </span>            : // Hit counts based logs
<span class="lineNum">    6491 </span>            : #define DLOG_EVERY_N(n, LEVEL) DCLOG_EVERY_N(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6492 </span>            : #define DVLOG_EVERY_N(n, vlevel) DCVLOG_EVERY_N(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6493 </span>            : #define DLOG_AFTER_N(n, LEVEL) DCLOG_AFTER_N(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6494 </span>            : #define DVLOG_AFTER_N(n, vlevel) DCVLOG_AFTER_N(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6495 </span>            : #define DLOG_N_TIMES(n, LEVEL) DCLOG_N_TIMES(n, LEVEL, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6496 </span>            : #define DVLOG_N_TIMES(n, vlevel) DCVLOG_N_TIMES(n, vlevel, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6497 </span>            : // Check macros
<span class="lineNum">    6498 </span>            : #undef CCHECK
<span class="lineNum">    6499 </span>            : #undef CPCHECK
<span class="lineNum">    6500 </span>            : #undef CCHECK_EQ
<span class="lineNum">    6501 </span>            : #undef CCHECK_NE
<span class="lineNum">    6502 </span>            : #undef CCHECK_LT
<span class="lineNum">    6503 </span>            : #undef CCHECK_GT
<span class="lineNum">    6504 </span>            : #undef CCHECK_LE
<span class="lineNum">    6505 </span>            : #undef CCHECK_GE
<span class="lineNum">    6506 </span>            : #undef CCHECK_BOUNDS
<span class="lineNum">    6507 </span>            : #undef CCHECK_NOTNULL
<span class="lineNum">    6508 </span>            : #undef CCHECK_STRCASEEQ
<span class="lineNum">    6509 </span>            : #undef CCHECK_STRCASENE
<span class="lineNum">    6510 </span>            : #undef CHECK
<span class="lineNum">    6511 </span>            : #undef PCHECK
<span class="lineNum">    6512 </span>            : #undef CHECK_EQ
<span class="lineNum">    6513 </span>            : #undef CHECK_NE
<span class="lineNum">    6514 </span>            : #undef CHECK_LT
<span class="lineNum">    6515 </span>            : #undef CHECK_GT
<span class="lineNum">    6516 </span>            : #undef CHECK_LE
<span class="lineNum">    6517 </span>            : #undef CHECK_GE
<span class="lineNum">    6518 </span>            : #undef CHECK_BOUNDS
<span class="lineNum">    6519 </span>            : #undef CHECK_NOTNULL
<span class="lineNum">    6520 </span>            : #undef CHECK_STRCASEEQ
<span class="lineNum">    6521 </span>            : #undef CHECK_STRCASENE
<span class="lineNum">    6522 </span>            : #define CCHECK(condition, ...) CLOG_IF(!(condition), FATAL, __VA_ARGS__) &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #condition &lt;&lt; &quot;] &quot;
<span class="lineNum">    6523 </span>            : #define CPCHECK(condition, ...) CPLOG_IF(!(condition), FATAL, __VA_ARGS__) &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #condition &lt;&lt; &quot;] &quot;
<span class="lineNum">    6524 </span>            : #define CHECK(condition) CCHECK(condition, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6525 </span>            : #define PCHECK(condition) CPCHECK(condition, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6526 </span>            : #define CCHECK_EQ(a, b, ...) CCHECK(a == b, __VA_ARGS__)
<span class="lineNum">    6527 </span>            : #define CCHECK_NE(a, b, ...) CCHECK(a != b, __VA_ARGS__)
<span class="lineNum">    6528 </span>            : #define CCHECK_LT(a, b, ...) CCHECK(a &lt; b, __VA_ARGS__)
<span class="lineNum">    6529 </span>            : #define CCHECK_GT(a, b, ...) CCHECK(a &gt; b, __VA_ARGS__)
<span class="lineNum">    6530 </span>            : #define CCHECK_LE(a, b, ...) CCHECK(a &lt;= b, __VA_ARGS__)
<span class="lineNum">    6531 </span>            : #define CCHECK_GE(a, b, ...) CCHECK(a &gt;= b, __VA_ARGS__)
<span class="lineNum">    6532 </span>            : #define CCHECK_BOUNDS(val, min, max, ...) CCHECK(val &gt;= min &amp;&amp; val &lt;= max, __VA_ARGS__)
<span class="lineNum">    6533 </span>            : #define CHECK_EQ(a, b) CCHECK_EQ(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6534 </span>            : #define CHECK_NE(a, b) CCHECK_NE(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6535 </span>            : #define CHECK_LT(a, b) CCHECK_LT(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6536 </span>            : #define CHECK_GT(a, b) CCHECK_GT(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6537 </span>            : #define CHECK_LE(a, b) CCHECK_LE(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6538 </span>            : #define CHECK_GE(a, b) CCHECK_GE(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6539 </span>            : #define CHECK_BOUNDS(val, min, max) CCHECK_BOUNDS(val, min, max, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6540 </span>            : namespace el {
<span class="lineNum">    6541 </span>            : namespace base {
<span class="lineNum">    6542 </span>            : namespace utils {
<span class="lineNum">    6543 </span>            : template &lt;typename T&gt;
<span class="lineNum">    6544 </span>            : static T* checkNotNull(T* ptr, const char* name, const char* loggers, ...) {
<span class="lineNum">    6545 </span>            :     CLOG_IF(ptr == nullptr, FATAL, loggers) &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; name &lt;&lt; &quot; != nullptr]&quot;;
<span class="lineNum">    6546 </span>            :     return ptr;
<span class="lineNum">    6547 </span>            : }
<span class="lineNum">    6548 </span>            : }  // namespace utils
<span class="lineNum">    6549 </span>            : }  // namespace base
<span class="lineNum">    6550 </span>            : }  // namespace el
<span class="lineNum">    6551 </span>            : #define CCHECK_NOTNULL(ptr, ...) el::base::utils::checkNotNull(ptr, #ptr, __VA_ARGS__)
<span class="lineNum">    6552 </span>            : #define CCHECK_STREQ(str1, str2, ...) CLOG_IF(!el::base::utils::Str::cStringEq(str1, str2), FATAL, __VA_ARGS__) \
<span class="lineNum">    6553 </span>            :                         &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #str1 &lt;&lt; &quot; == &quot; &lt;&lt; #str2 &lt;&lt; &quot;] &quot;
<span class="lineNum">    6554 </span>            : #define CCHECK_STRNE(str1, str2, ...) CLOG_IF(el::base::utils::Str::cStringEq(str1, str2), FATAL, __VA_ARGS__) \
<span class="lineNum">    6555 </span>            :                         &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #str1 &lt;&lt; &quot; != &quot; &lt;&lt; #str2 &lt;&lt; &quot;] &quot;
<span class="lineNum">    6556 </span>            : #define CCHECK_STRCASEEQ(str1, str2, ...) CLOG_IF(!el::base::utils::Str::cStringCaseEq(str1, str2), FATAL, __VA_ARGS__) \
<span class="lineNum">    6557 </span>            :                         &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #str1 &lt;&lt; &quot; == &quot; &lt;&lt; #str2 &lt;&lt; &quot;] &quot;
<span class="lineNum">    6558 </span>            : #define CCHECK_STRCASENE(str1, str2, ...) CLOG_IF(el::base::utils::Str::cStringCaseEq(str1, str2), FATAL, __VA_ARGS__) \
<span class="lineNum">    6559 </span>            :                         &lt;&lt; &quot;Check failed: [&quot; &lt;&lt; #str1 &lt;&lt; &quot; != &quot; &lt;&lt; #str2 &lt;&lt; &quot;] &quot;
<span class="lineNum">    6560 </span>            : #define CHECK_NOTNULL(ptr) CCHECK_NOTNULL(ptr, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6561 </span>            : #define CHECK_STREQ(str1, str2) CCHECK_STREQ(str1, str2, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6562 </span>            : #define CHECK_STRNE(str1, str2) CCHECK_STRNE(str1, str2, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6563 </span>            : #define CHECK_STRCASEEQ(str1, str2) CCHECK_STRCASEEQ(str1, str2, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6564 </span>            : #define CHECK_STRCASENE(str1, str2) CCHECK_STRCASENE(str1, str2, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6565 </span>            : #undef DCCHECK
<span class="lineNum">    6566 </span>            : #undef DCCHECK_EQ
<span class="lineNum">    6567 </span>            : #undef DCCHECK_NE
<span class="lineNum">    6568 </span>            : #undef DCCHECK_LT
<span class="lineNum">    6569 </span>            : #undef DCCHECK_GT
<span class="lineNum">    6570 </span>            : #undef DCCHECK_LE
<span class="lineNum">    6571 </span>            : #undef DCCHECK_GE
<span class="lineNum">    6572 </span>            : #undef DCCHECK_BOUNDS
<span class="lineNum">    6573 </span>            : #undef DCCHECK_NOTNULL
<span class="lineNum">    6574 </span>            : #undef DCCHECK_STRCASEEQ
<span class="lineNum">    6575 </span>            : #undef DCCHECK_STRCASENE
<span class="lineNum">    6576 </span>            : #undef DCPCHECK
<span class="lineNum">    6577 </span>            : #undef DCHECK
<span class="lineNum">    6578 </span>            : #undef DCHECK_EQ
<span class="lineNum">    6579 </span>            : #undef DCHECK_NE
<span class="lineNum">    6580 </span>            : #undef DCHECK_LT
<span class="lineNum">    6581 </span>            : #undef DCHECK_GT
<span class="lineNum">    6582 </span>            : #undef DCHECK_LE
<span class="lineNum">    6583 </span>            : #undef DCHECK_GE
<span class="lineNum">    6584 </span>            : #undef DCHECK_BOUNDS_
<span class="lineNum">    6585 </span>            : #undef DCHECK_NOTNULL
<span class="lineNum">    6586 </span>            : #undef DCHECK_STRCASEEQ
<span class="lineNum">    6587 </span>            : #undef DCHECK_STRCASENE
<span class="lineNum">    6588 </span>            : #undef DPCHECK
<span class="lineNum">    6589 </span>            : #define DCCHECK(condition, ...) if (ELPP_DEBUG_LOG) CCHECK(condition, __VA_ARGS__)
<span class="lineNum">    6590 </span>            : #define DCCHECK_EQ(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_EQ(a, b, __VA_ARGS__)
<span class="lineNum">    6591 </span>            : #define DCCHECK_NE(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_NE(a, b, __VA_ARGS__)
<span class="lineNum">    6592 </span>            : #define DCCHECK_LT(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_LT(a, b, __VA_ARGS__)
<span class="lineNum">    6593 </span>            : #define DCCHECK_GT(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_GT(a, b, __VA_ARGS__)
<span class="lineNum">    6594 </span>            : #define DCCHECK_LE(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_LE(a, b, __VA_ARGS__)
<span class="lineNum">    6595 </span>            : #define DCCHECK_GE(a, b, ...) if (ELPP_DEBUG_LOG) CCHECK_GE(a, b, __VA_ARGS__)
<span class="lineNum">    6596 </span>            : #define DCCHECK_BOUNDS(val, min, max, ...) if (ELPP_DEBUG_LOG) CCHECK_BOUNDS(val, min, max, __VA_ARGS__)
<span class="lineNum">    6597 </span>            : #define DCCHECK_NOTNULL(ptr, ...) if (ELPP_DEBUG_LOG) CCHECK_NOTNULL(ptr, __VA_ARGS__)
<span class="lineNum">    6598 </span>            : #define DCCHECK_STREQ(str1, str2, ...) if (ELPP_DEBUG_LOG) CCHECK_STREQ(str1, str2, __VA_ARGS__)
<span class="lineNum">    6599 </span>            : #define DCCHECK_STRNE(str1, str2, ...) if (ELPP_DEBUG_LOG) CCHECK_STRNE(str1, str2, __VA_ARGS__)
<span class="lineNum">    6600 </span>            : #define DCCHECK_STRCASEEQ(str1, str2, ...) if (ELPP_DEBUG_LOG) CCHECK_STRCASEEQ(str1, str2, __VA_ARGS__)
<span class="lineNum">    6601 </span>            : #define DCCHECK_STRCASENE(str1, str2, ...) if (ELPP_DEBUG_LOG) CCHECK_STRCASENE(str1, str2, __VA_ARGS__)
<span class="lineNum">    6602 </span>            : #define DCPCHECK(condition, ...) if (ELPP_DEBUG_LOG) CPCHECK(condition, __VA_ARGS__)
<span class="lineNum">    6603 </span>            : #define DCHECK(condition) DCCHECK(condition, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6604 </span>            : #define DCHECK_EQ(a, b) DCCHECK_EQ(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6605 </span>            : #define DCHECK_NE(a, b) DCCHECK_NE(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6606 </span>            : #define DCHECK_LT(a, b) DCCHECK_LT(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6607 </span>            : #define DCHECK_GT(a, b) DCCHECK_GT(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6608 </span>            : #define DCHECK_LE(a, b) DCCHECK_LE(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6609 </span>            : #define DCHECK_GE(a, b) DCCHECK_GE(a, b, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6610 </span>            : #define DCHECK_BOUNDS(val, min, max) DCCHECK_BOUNDS(val, min, max, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6611 </span>            : #define DCHECK_NOTNULL(ptr) DCCHECK_NOTNULL(ptr, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6612 </span>            : #define DCHECK_STREQ(str1, str2) DCCHECK_STREQ(str1, str2, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6613 </span>            : #define DCHECK_STRNE(str1, str2) DCCHECK_STRNE(str1, str2, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6614 </span>            : #define DCHECK_STRCASEEQ(str1, str2) DCCHECK_STRCASEEQ(str1, str2, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6615 </span>            : #define DCHECK_STRCASENE(str1, str2) DCCHECK_STRCASENE(str1, str2, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6616 </span>            : #define DPCHECK(condition) DCPCHECK(condition, ELPP_CURR_FILE_LOGGER_ID)
<span class="lineNum">    6617 </span>            : #if defined(ELPP_DISABLE_DEFAULT_CRASH_HANDLING)
<span class="lineNum">    6618 </span>            : #   define ELPP_USE_DEF_CRASH_HANDLER false
<span class="lineNum">    6619 </span>            : #else
<span class="lineNum">    6620 </span>            : #   define ELPP_USE_DEF_CRASH_HANDLER true
<span class="lineNum">    6621 </span>            : #endif  // defined(ELPP_DISABLE_DEFAULT_CRASH_HANDLING)
<span class="lineNum">    6622 </span>            : #define ELPP_CRASH_HANDLER_INIT
<span class="lineNum">    6623 </span>            : #define ELPP_INIT_EASYLOGGINGPP(val)\
<span class="lineNum">    6624 </span>            :     ELPP_INITI_BASIC_DECLR\
<span class="lineNum">    6625 </span>            :     namespace el {\
<span class="lineNum">    6626 </span>            :         namespace base {\
<span class="lineNum">    6627 </span>            :             el::base::type::StoragePointer elStorage(val);\
<span class="lineNum">    6628 </span>            :         }\
<span class="lineNum">    6629 </span>            :         el::base::debug::CrashHandler elCrashHandler(ELPP_USE_DEF_CRASH_HANDLER);\
<span class="lineNum">    6630 </span>            :     }
<span class="lineNum">    6631 </span>            : 
<span class="lineNum">    6632 </span>            : #if ELPP_ASYNC_LOGGING
<span class="lineNum">    6633 </span>            : #   define INITIALIZE_EASYLOGGINGPP\
<span class="lineNum">    6634 </span>            :        ELPP_INIT_EASYLOGGINGPP(new el::base::Storage(el::LogBuilderPtr(new el::base::DefaultLogBuilder()),\
<span class="lineNum">    6635 </span>            :                                                           new el::base::AsyncDispatchWorker()))\
<span class="lineNum">    6636 </span>            :        
<span class="lineNum">    6637 </span>            : #else
<span class="lineNum">    6638 </span>            : #   define INITIALIZE_EASYLOGGINGPP\
<span class="lineNum">    6639 </span>            :        ELPP_INIT_EASYLOGGINGPP(new el::base::Storage(el::LogBuilderPtr(new el::base::DefaultLogBuilder())))
<span class="lineNum">    6640 </span>            : #endif  // ELPP_ASYNC_LOGGING
<span class="lineNum">    6641 </span>            : #define INITIALIZE_NULL_EASYLOGGINGPP\
<span class="lineNum">    6642 </span>            :     ELPP_INITI_BASIC_DECLR\
<span class="lineNum">    6643 </span>            :     namespace el {\
<span class="lineNum">    6644 </span>            :         namespace base {\
<span class="lineNum">    6645 </span>            :             el::base::type::StoragePointer elStorage;\
<span class="lineNum">    6646 </span>            :         }\
<span class="lineNum">    6647 </span>            :         el::base::debug::CrashHandler elCrashHandler(ELPP_USE_DEF_CRASH_HANDLER);\
<span class="lineNum">    6648 </span>            :     }
<span class="lineNum">    6649 </span>            : // NOTE: no ELPP_INITI_BASIC_DECLR when sharing - causes double free corruption on external symbols
<span class="lineNum">    6650 </span>            : #define SHARE_EASYLOGGINGPP(initializedStorage)\
<span class="lineNum">    6651 </span>            :     namespace el {\
<span class="lineNum">    6652 </span>            :         namespace base {\
<span class="lineNum">    6653 </span>            :             el::base::type::StoragePointer elStorage(initializedStorage);\
<span class="lineNum">    6654 </span>            :         }\
<span class="lineNum">    6655 </span>            :         el::base::debug::CrashHandler elCrashHandler(ELPP_USE_DEF_CRASH_HANDLER);\
<span class="lineNum">    6656 </span>            :     }
<span class="lineNum">    6657 </span>            : 
<span class="lineNum">    6658 </span>            : #if defined(ELPP_UNICODE)
<span class="lineNum">    6659 </span>            : #   define START_EASYLOGGINGPP(argc, argv) el::Helpers::setArgs(argc, argv); std::locale::global(std::locale(&quot;&quot;))
<span class="lineNum">    6660 </span>            : #else
<span class="lineNum">    6661 </span>            : #   define START_EASYLOGGINGPP(argc, argv) el::Helpers::setArgs(argc, argv)
<span class="lineNum">    6662 </span>            : #endif  // defined(ELPP_UNICODE)
<span class="lineNum">    6663 </span>            : #endif // EASYLOGGINGPP_H
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12-4-g04a3c0e</a></td></tr>
  </table>
  <br>

</body>
</html>
